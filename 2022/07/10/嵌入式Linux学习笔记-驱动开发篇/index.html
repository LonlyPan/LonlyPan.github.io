

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="LonlyPan">
  <meta name="keywords" content="LonlyPan个人站，LonlyPan，Lonly，致简，丢了幸福的猪，逍遥勿忘心安">
  
    <meta name="description" content="Linux 中的三大类驱动：字符设备驱动、块设备驱动和网络  字符设备驱动是占用篇幅最大的一类驱动，因为字符设备最多，从最简单的点灯到 I2C、SPI、音频等都属于字符设备驱动的类型。 块设备驱动就是存储器设备的驱动，比如 EMMC、NAND、SD 卡和 U 盘等存储设备，因为这些存储设备的特点是以存储块为基础，因此叫做块设备。 网络设备驱动就更好理解了，就是网络驱动，不管是有线的还是无线的，都属">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式Linux学习笔记-驱动开发篇">
<meta property="og:url" content="http://lonlypan.com/2022/07/10/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/index.html">
<meta property="og:site_name" content="LonlyPan个人站">
<meta property="og:description" content="Linux 中的三大类驱动：字符设备驱动、块设备驱动和网络  字符设备驱动是占用篇幅最大的一类驱动，因为字符设备最多，从最简单的点灯到 I2C、SPI、音频等都属于字符设备驱动的类型。 块设备驱动就是存储器设备的驱动，比如 EMMC、NAND、SD 卡和 U 盘等存储设备，因为这些存储设备的特点是以存储块为基础，因此叫做块设备。 网络设备驱动就更好理解了，就是网络驱动，不管是有线的还是无线的，都属">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/嵌入式Linux学习笔记/1654315471941.png">
<meta property="article:published_time" content="2022-07-10T14:35:00.000Z">
<meta property="article:modified_time" content="2022-07-10T14:35:00.000Z">
<meta property="article:author" content="LonlyPan">
<meta property="article:tag" content="LonlyPan个人站，LonlyPan，Lonly，致简，丢了幸福的猪，逍遥勿忘心安">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/嵌入式Linux学习笔记/1654315471941.png">
  
  
  <title>嵌入式Linux学习笔记-驱动开发篇 - LonlyPan个人站</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"lonlypan.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":2},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"f56279d43c733d547ea06f75f8e05d89","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>LonlyPan的博客站</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/books/">
                <i class="iconfont icon-book"></i>
                书影
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                朋友
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="嵌入式Linux学习笔记-驱动开发篇"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-07-10 22:35" pubdate>
          2022年7月10日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          68k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          563 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">嵌入式Linux学习笔记-驱动开发篇</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2022年7月10日 晚上
                  
                
              </p>
            
            <div class="markdown-body">
              
              <p>Linux 中的三大类驱动：字符设备驱动、块设备驱动和网络</p>
<ul>
<li>字符设备驱动是占用篇幅最大的一类驱动，因为字符设备最多，从最简单的点灯到 I2C、SPI、音频等都属于字符设备驱动的类型。</li>
<li>块设备驱动就是存储器设备的驱动，比如 EMMC、NAND、SD 卡和 U 盘等存储设备，因为这些存储设备的特点是以存储块为基础，因此叫做块设备。</li>
<li>网络设备驱动就更好理解了，就是网络驱动，不管是有线的还是无线的，都属于网络设备驱动的范畴。</li>
</ul>
<p>块设备和网络设备驱动要比字符设备驱动复杂，就是因为其复杂所以半导体厂商一般都给我们编写好了，大多数情况下都是直接可以使用的。</p>
<p>一个设备可以属于多种设备驱动类型，比如 USB WIFI，其使用 USB 接口，所以属于字符设备，但是其又能上网，所以也属于网络设备驱动。</p>
<p>本书使用的 Linux 内核版本为 4.1.15，其支持设备树(Device tree)，所以本篇所有例程均采用设备树。设备树将是本篇的重点！</p>
<p>Linux 应用程序对驱动程序的调用如图所示：</p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658498584694.png" srcset="/img/loading.gif" lazyload alt="Linux 应用程序对驱动程序的调用流程"></p>
<p>在 Linux 中一切皆为文件，驱动加载成功以后会在“&#x2F;dev”目录下生成一个相应的文件，应用程序通过对这个名为“&#x2F;dev&#x2F;xxx”(xxx 是具体的驱动文件名字)的文件进行相应的操作即可实现对硬件的操作。</p>
<p>比如现在有个叫做&#x2F;dev&#x2F;led 的驱动文件，此文件是 led 灯的驱动文件。应用程序使用 open 函数来打开文件&#x2F;dev&#x2F;led，使用完成以后使用 close 函数关闭&#x2F;dev&#x2F;led 这个文件。open和 close 就是打开和关闭 led 驱动的函数，如果要点亮或关闭 led，那么就使用 write 函数来操作，也就是向此驱动写入数据，这个数据就是要关闭还是要打开 led 的控制参数。如果要获取led 灯的状态，就用 read 函数从驱动中读取相应的状态。</p>
<p>应用程序运行在用户空间，而 Linux 驱动属于内核的一部分，因此驱动运行于内核空间。当我们在用户空间想要实现对内核的操作，比如使用 open 函数打开&#x2F;dev&#x2F;led 这个驱动，因为用户空间不能直接对内核进行操作，因此必须使用一个叫做“系统调用”的方法来实现从用户空间“陷入”到内核空间，这样才能实现对底层驱动的操作。open、close、write 和 read 等这些函数是由 C 库提供的，在 Linux 系统中，系统调用作为 C 库的一部分。当我们调用 open 函数的时候流程如图 40.1.2 所示：</p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658498683107.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<h1 id="旧字符设备驱动"><a href="#旧字符设备驱动" class="headerlink" title="旧字符设备驱动"></a>旧字符设备驱动</h1><p>字符设备是 Linux 驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。比如我们最常见的点灯、按键、IIC、SPI，LCD 等等都是字符设备，这些设备的驱动就叫做字符设备驱动。</p>
<p>驱动编译成模块（编译进内核这里不讲解）</p>
<ol>
<li>编写驱动函数和APP函数：</li>
<li>模块加载（insmod或modprobe ）：调用驱动程序中的 module_init(xxx_init)，再调用和初始化函数，xxx_init()</li>
<li>注册字符设备：一般加载时，在初始化函数中同时会调用register_chrdev() 函数完成注册</li>
<li>创建设备节点文件，APP通过操作该文件控制设备。实际就是驱动文件的一个映射。因为用户空间无法直接操作内核空间，驱动属于内核空间</li>
<li>通过给APP文件传输参数，从而控制设备</li>
<li>卸载设备</li>
</ol>
<h2 id="静态分配设备号"><a href="#静态分配设备号" class="headerlink" title="静态分配设备号"></a>静态分配设备号</h2><p>册字符设备的时候需要给设备指定一个设备号，这个设备号可以是驱动开发者静态的指定一个设备号，比如选择 200 这个主设备号。有一些常用的设备号已经被 Linux 内核开发者给分配掉了，具体分配的内容可以查看文档 Documentation&#x2F;devices.txt。并不是说内核开发者已经分配掉的主设备号我们就不能用了，具体能不能用还得看我们的硬件平台运行过程中有没有使用这个主设备号，使用 </p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>devices<br></code></pre></td></tr></table></figure>
<p>命令即可查看当前系统中所有已经使用了的设备号。</p>
<h2 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h2><h3 id="1、创建-VSCode-工程"><a href="#1、创建-VSCode-工程" class="headerlink" title="1、创建 VSCode 工程"></a>1、创建 VSCode 工程</h3><p>在 Ubuntu 中创建一个目录用来存放 Linux 驱动程序，比如我创建了一个名为 Linux_Drivers的目录来存放所有的 Linux 驱动。在 Linux_Drivers 目录下新建一个名为 1_chrdevbase 的子目录来存放本实验所有文件</p>
<p>在 1_chrdevbase 目录中新建 VSCode 工程，并且新建 chrdevbase.c 文件，完成以后1_chrdevbase 目录中的文件如图 40.4.1.2 所示：</p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658499335278.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<h3 id="2、添加头文件路径"><a href="#2、添加头文件路径" class="headerlink" title="2、添加头文件路径"></a>2、添加头文件路径</h3><p>因为是编写 Linux 驱动，因此会用到 Linux 源码中的函数。我们需要在 VSCode 中添加 Linux源码中的头文件路径。打开 VSCode，按下“Crtl+Shift+P”打开 VSCode 的控制台，然后输入“C&#x2F;C++: Edit configurations(JSON) ”，打开 C&#x2F;C++编辑配置文件，如图所示：</p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658499365413.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>打开以后会自动在.vscode 目录下生成一个名为 c_cpp_properties.json 的文件，第 5 行的 includePath 表示头文件路径，需要将 Linux 源码里面的头文件路径添加进来，也就是我们前面移植的 Linux 源码中的头文件路径。添加头文件路径以后的 c_cpp_properties.json的文件内容如下所示：</p>
<blockquote>
<p>这里的头文件是我们移植到开发板的linux源码头文件，不是ubuntu中的，因为软件最终是在板子上跑的</p>
</blockquote>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-number">1</span> &#123;<br><span class="hljs-number">2</span> 	<span class="hljs-string">&quot;configurations&quot;</span>: [<br><span class="hljs-number">3</span> 		&#123;<br><span class="hljs-number">4</span> 			<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Linux&quot;</span>,<br><span class="hljs-number">5</span> 			<span class="hljs-string">&quot;includePath&quot;</span>: [<br><span class="hljs-number">6</span> 				<span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>,<br><span class="hljs-number">7</span>				 <span class="hljs-string">&quot;/home/zuozhongkai/linux/IMX6ULL/linux/temp/linux-imx-rel_imx_4.1.15_2.1.0_ga_alientek/include&quot;</span>,<br><span class="hljs-number">8</span> 				<span class="hljs-string">&quot;/home/zuozhongkai/linux/IMX6ULL/linux/temp/linux-imx-rel_imx_4.1.15_2.1.0_ga_alientek/arch/arm/include&quot;</span>,<br><span class="hljs-number">9</span> 				<span class="hljs-string">&quot;/home/zuozhongkai/linux/IMX6ULL/linux/temp/linux-imx-rel_imx_4.1.15_2.1.0_ga_alientek/arch/arm/include/generated/&quot;</span><br><span class="hljs-number">10</span> 			],<br><span class="hljs-number">11</span> 			<span class="hljs-string">&quot;defines&quot;</span>: [],<br>......<br><span class="hljs-number">16</span> 		&#125;<br><span class="hljs-number">17</span> 	],<br><span class="hljs-number">18</span> 	<span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-number">4</span><br><span class="hljs-number">19</span> &#125;<br></code></pre></td></tr></table></figure>

<p>第 7~9 行就是添加好的 Linux 头文件路径。分别是开发板所使用的 Linux 源码下的 include、arch&#x2F;arm&#x2F;include 和 arch&#x2F;arm&#x2F;include&#x2F;generated 这三个目录的路径，注意，这里使用了绝对路径。</p>
<h3 id="3、-驱动编写"><a href="#3、-驱动编写" class="headerlink" title="3、 驱动编写"></a>3、 驱动编写</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;linux/types.h&gt;<br>#<span class="hljs-keyword">include</span> &lt;linux/kernel.h&gt;<br>#<span class="hljs-keyword">include</span> &lt;linux/delay.h&gt;<br>#<span class="hljs-keyword">include</span> &lt;linux/ide.h&gt;<br>#<span class="hljs-keyword">include</span> &lt;linux/init.h&gt;<br>#<span class="hljs-keyword">include</span> &lt;linux/<span class="hljs-keyword">module</span>.h&gt;<br><br>#define CHRDEVBASE_MAJOR	<span class="hljs-number">200</span>				<span class="hljs-comment">/* 主设备号 */</span><br>#define CHRDEVBASE_NAME		<span class="hljs-string">&quot;chrdevbase&quot;</span> 	<span class="hljs-comment">/* 设备名     */</span><br><br>static <span class="hljs-built_in">char</span> readbuf<span class="hljs-literal">[<span class="hljs-number">100</span>]</span>;		<span class="hljs-comment">/* 读缓冲区 */</span><br>static <span class="hljs-built_in">char</span> writebuf<span class="hljs-literal">[<span class="hljs-number">100</span>]</span>;		<span class="hljs-comment">/* 写缓冲区 */</span><br>static <span class="hljs-built_in">char</span> kerneldata<span class="hljs-literal">[]</span> = &#123;<span class="hljs-string">&quot;kernel data!&quot;</span>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description		: 打开设备</span><br><span class="hljs-comment"> * @param - inode 	: 传递给驱动的inode</span><br><span class="hljs-comment"> * @param - filp 	: 设备文件，file结构体有个叫做private_data的成员变量</span><br><span class="hljs-comment"> * 					  一般在open的时候将private_data指向设备结构体。</span><br><span class="hljs-comment"> * @return 			: 0 成功;其他 失败</span><br><span class="hljs-comment"> */</span><br>static <span class="hljs-built_in">int</span> chrdevbase<span class="hljs-constructor">_open(<span class="hljs-params">struct</span> <span class="hljs-params">inode</span> <span class="hljs-operator">*</span><span class="hljs-params">inode</span>, <span class="hljs-params">struct</span> <span class="hljs-params">file</span> <span class="hljs-operator">*</span><span class="hljs-params">filp</span>)</span><br>&#123;<br>	<span class="hljs-comment">//printk(&quot;chrdevbase open!\r\n&quot;);</span><br>	return <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description		: 从设备读取数据 </span><br><span class="hljs-comment"> * @param - filp 	: 要打开的设备文件(文件描述符)</span><br><span class="hljs-comment"> * @param - buf 	: 返回给用户空间的数据缓冲区</span><br><span class="hljs-comment"> * @param - cnt 	: 要读取的数据长度</span><br><span class="hljs-comment"> * @param - offt 	: 相对于文件首地址的偏移</span><br><span class="hljs-comment"> * @return 			: 读取的字节数，如果为负值，表示读取失败</span><br><span class="hljs-comment"> */</span><br>static ssize_t chrdevbase<span class="hljs-constructor">_read(<span class="hljs-params">struct</span> <span class="hljs-params">file</span> <span class="hljs-operator">*</span><span class="hljs-params">filp</span>, <span class="hljs-params">char</span> <span class="hljs-params">__user</span> <span class="hljs-operator">*</span><span class="hljs-params">buf</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">cnt</span>, <span class="hljs-params">loff_t</span> <span class="hljs-operator">*</span><span class="hljs-params">offt</span>)</span><br>&#123;<br>	<span class="hljs-built_in">int</span> retvalue = <span class="hljs-number">0</span>;<br>	<br>	<span class="hljs-comment">/* 向用户空间发送数据 */</span><br>	memcpy(readbuf, kerneldata, sizeof(kerneldata));<br>	retvalue = copy<span class="hljs-constructor">_to_user(<span class="hljs-params">buf</span>, <span class="hljs-params">readbuf</span>, <span class="hljs-params">cnt</span>)</span>;<br>	<span class="hljs-keyword">if</span>(retvalue<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>		printk(<span class="hljs-string">&quot;kernel senddata ok!\r\n&quot;</span>);<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		printk(<span class="hljs-string">&quot;kernel senddata failed!\r\n&quot;</span>);<br>	&#125;<br>	<br>	<span class="hljs-comment">//printk(&quot;chrdevbase read!\r\n&quot;);</span><br>	return <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description		: 向设备写数据 </span><br><span class="hljs-comment"> * @param - filp 	: 设备文件，表示打开的文件描述符</span><br><span class="hljs-comment"> * @param - buf 	: 要写给设备写入的数据</span><br><span class="hljs-comment"> * @param - cnt 	: 要写入的数据长度</span><br><span class="hljs-comment"> * @param - offt 	: 相对于文件首地址的偏移</span><br><span class="hljs-comment"> * @return 			: 写入的字节数，如果为负值，表示写入失败</span><br><span class="hljs-comment"> */</span><br>static ssize_t chrdevbase<span class="hljs-constructor">_write(<span class="hljs-params">struct</span> <span class="hljs-params">file</span> <span class="hljs-operator">*</span><span class="hljs-params">filp</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-params">__user</span> <span class="hljs-operator">*</span><span class="hljs-params">buf</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">cnt</span>, <span class="hljs-params">loff_t</span> <span class="hljs-operator">*</span><span class="hljs-params">offt</span>)</span><br>&#123;<br>	<span class="hljs-built_in">int</span> retvalue = <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">/* 接收用户空间传递给内核的数据并且打印出来 */</span><br>	retvalue = copy<span class="hljs-constructor">_from_user(<span class="hljs-params">writebuf</span>, <span class="hljs-params">buf</span>, <span class="hljs-params">cnt</span>)</span>;<br>	<span class="hljs-keyword">if</span>(retvalue<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>		printk(<span class="hljs-string">&quot;kernel recevdata:%s\r\n&quot;</span>, writebuf);<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		printk(<span class="hljs-string">&quot;kernel recevdata failed!\r\n&quot;</span>);<br>	&#125;<br>	<br>	<span class="hljs-comment">//printk(&quot;chrdevbase write!\r\n&quot;);</span><br>	return <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description		: 关闭/释放设备</span><br><span class="hljs-comment"> * @param - filp 	: 要关闭的设备文件(文件描述符)</span><br><span class="hljs-comment"> * @return 			: 0 成功;其他 失败</span><br><span class="hljs-comment"> */</span><br>static <span class="hljs-built_in">int</span> chrdevbase<span class="hljs-constructor">_release(<span class="hljs-params">struct</span> <span class="hljs-params">inode</span> <span class="hljs-operator">*</span><span class="hljs-params">inode</span>, <span class="hljs-params">struct</span> <span class="hljs-params">file</span> <span class="hljs-operator">*</span><span class="hljs-params">filp</span>)</span><br>&#123;<br>	<span class="hljs-comment">//printk(&quot;chrdevbase release！\r\n&quot;);</span><br>	return <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 设备操作函数结构体</span><br><span class="hljs-comment"> */</span><br>static <span class="hljs-keyword">struct</span> file_operations chrdevbase_fops = &#123;<br>	.owner = THIS_MODULE,	<br>	.<span class="hljs-keyword">open</span> = chrdevbase_open,<br>	.read = chrdevbase_read,<br>	.write = chrdevbase_write,<br>	.release = chrdevbase_release,<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description	: 驱动入口函数 </span><br><span class="hljs-comment"> * @param 		: 无</span><br><span class="hljs-comment"> * @return 		: 0 成功;其他 失败</span><br><span class="hljs-comment"> */</span><br>static <span class="hljs-built_in">int</span> __init chrdevbase<span class="hljs-constructor">_init(<span class="hljs-params">void</span>)</span><br>&#123;<br>	<span class="hljs-built_in">int</span> retvalue = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">/* 注册字符设备驱动 */</span><br>	retvalue = register<span class="hljs-constructor">_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME, &amp;<span class="hljs-params">chrdevbase_fops</span>)</span>;<br>	<span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;<br>		printk(<span class="hljs-string">&quot;chrdevbase driver register failed\r\n&quot;</span>);<br>	&#125;<br>	printk(<span class="hljs-string">&quot;chrdevbase init!\r\n&quot;</span>);<br>	return <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description	: 驱动出口函数</span><br><span class="hljs-comment"> * @param 		: 无</span><br><span class="hljs-comment"> * @return 		: 无</span><br><span class="hljs-comment"> */</span><br>static void __exit chrdevbase<span class="hljs-constructor">_exit(<span class="hljs-params">void</span>)</span><br>&#123;<br>	<span class="hljs-comment">/* 注销字符设备驱动 */</span><br>	unregister<span class="hljs-constructor">_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME)</span>;<br>	printk(<span class="hljs-string">&quot;chrdevbase exit!\r\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * 将上面两个函数指定为驱动的入口和出口函数 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">module</span><span class="hljs-constructor">_init(<span class="hljs-params">chrdevbase_init</span>)</span>;<br><span class="hljs-keyword">module</span><span class="hljs-constructor">_exit(<span class="hljs-params">chrdevbase_exit</span>)</span>;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * LICENSE和作者信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-constructor">MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>)</span>;<br><span class="hljs-constructor">MODULE_AUTHOR(<span class="hljs-string">&quot;zuozhongkai&quot;</span>)</span>;<br><br></code></pre></td></tr></table></figure>

<p>编译生成.ko驱动文件</p>
<p>“__init”、“__exit”修饰。实际上是汇编指示，编译器会把所有修饰过的放在一起，用在系统初始化，一旦内核启动后，就释放这些东西。只有在kernel初始化的时候会被调用，以后一定不会被使用，kernel可能会在以后的某个时候释放掉这个段所占用的内存，给别的地方使用</p>
<h3 id="4、-APP编写"><a href="#4、-APP编写" class="headerlink" title="4、 APP编写"></a>4、 APP编写</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;unistd.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fcntl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> usrdata[] = &#123;<span class="hljs-string">&quot;usr data!&quot;</span>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description		: main主程序</span><br><span class="hljs-comment"> * @param - argc 	: argv数组元素个数</span><br><span class="hljs-comment"> * @param - argv 	: 具体参数</span><br><span class="hljs-comment"> * @return 			: 0 成功;其他 失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> fd, retvalue;<br>	<span class="hljs-type">char</span> *filename;<br>	<span class="hljs-type">char</span> readbuf[<span class="hljs-number">100</span>], writebuf[<span class="hljs-number">100</span>];<br><br>	<span class="hljs-keyword">if</span>(argc != <span class="hljs-number">3</span>)&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error Usage!\r\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	&#125;<br><br>	filename = argv[<span class="hljs-number">1</span>];<br><br>	<span class="hljs-comment">/* 打开驱动文件 */</span><br>	fd  = <span class="hljs-built_in">open</span>(filename, O_RDWR);<br>	<span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Can&#x27;t open file %s\r\n&quot;</span>, filename);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]) == <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">/* 从驱动文件读取数据 */</span><br>		retvalue = <span class="hljs-built_in">read</span>(fd, readbuf, <span class="hljs-number">50</span>);<br>		<span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read file %s failed!\r\n&quot;</span>, filename);<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-comment">/*  读取成功，打印出读取成功的数据 */</span><br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read data:%s\r\n&quot;</span>,readbuf);<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]) == <span class="hljs-number">2</span>)&#123;<br> 	<span class="hljs-comment">/* 向设备驱动写数据 */</span><br>		<span class="hljs-built_in">memcpy</span>(writebuf, usrdata, <span class="hljs-built_in">sizeof</span>(usrdata));<br>		retvalue = <span class="hljs-built_in">write</span>(fd, writebuf, <span class="hljs-number">50</span>);<br>		<span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write file %s failed!\r\n&quot;</span>, filename);<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">/* 关闭设备 */</span><br>	retvalue = <span class="hljs-built_in">close</span>(fd);<br>	<span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Can&#x27;t close file %s\r\n&quot;</span>, filename);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<ul>
<li><p>数组 usrdata 是测试 APP 要向 chrdevbase 设备写入的数据。</p>
</li>
<li><p><code>if(argc != 3)</code>，判断运行测试 APP 的时候输入的参数是不是为 3 个，main 函数的 argc 参数表示参数数量，argv[]保存着具体的参数，如果参数不为 3 个的话就表示测试 APP 用法错误。<br>比如，现在要从 chrdevbase 设备中读取数据，需要输入如下命令：<code>./chrdevbaseApp /dev/chrdevbase 1</code>上述命令一共有三个参数“.&#x2F;chrdevbaseApp”、“&#x2F;dev&#x2F;chrdevbase”和“1”，这三个参数分别对应 argv[0]、argv[1]和 argv[2]。</p>
<ul>
<li>第一个参数表示运行 chrdevbaseAPP 这个软件，</li>
<li>第二个参数表示测试APP要打开&#x2F;dev&#x2F;chrdevbase这个设备。</li>
<li>第三个参数就是要执行的操作，1表示从chrdevbase中读取数据，2 表示向 chrdevbase 写数据。</li>
</ul>
</li>
<li><p><code>if(atoi(argv[2]) == 1)</code>判断 argv[2]参数的值是 1 还是 2，因为输入命令的时候其参数都是字符串格式的，因此需要借助 atoi 函数将字符串格式的数字转换为真实的数字。</p>
<ul>
<li>当 argv[2]为 1 的时候表示要从 chrdevbase 设备中读取数据，一共读取 50 字节的<br>数据，读取到的数据保存在 readbuf 中，读取成功以后就在终端上打印出读取到的数据。</li>
<li>当 argv[2]为 2 的时候表示要向 chrdevbase 设备写数据。</li>
</ul>
</li>
</ul>
<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><h3 id="1、加载驱动模块"><a href="#1、加载驱动模块" class="headerlink" title="1、加载驱动模块"></a>1、加载驱动模块</h3><p>为了方便测试，Linux 系统选择通过 TFTP 从网络启动，并且使用 NFS 挂载网络根文件系统，确保 uboot 中环境变量的值为：</p>
<ul>
<li>从网络启动内核和设备树</li>
<li>从网络启动根文件系统</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">setenv</span> bootcmd &#x27;tftp <span class="hljs-number">80800000</span> zImage; tftp <span class="hljs-number">83000000</span> imx6ull-alientek-emmc.dtb; bootz <span class="hljs-number">80800000</span> - <span class="hljs-number">83000000</span>&#x27;<br><span class="hljs-attribute">setenv</span> bootargs &#x27;console=ttymxc0,<span class="hljs-number">115200</span> root=/dev/nfs nfsroot=<span class="hljs-number">192.168.0.254</span>:/home/lonly/linux/nfs/rootfs,proto=tcp rw ip=<span class="hljs-number">192.168.0.121:192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">254</span>:<span class="hljs-number">192.168.0.1:255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">0</span>::eth0:<span class="hljs-literal">off</span>&#x27;<br><br><span class="hljs-attribute">saveenv</span><br></code></pre></td></tr></table></figure>

<p>设置好以后启动 Linux 系统，检查开发板根文件系统中有没有“&#x2F;lib&#x2F;modules&#x2F;4.1.15”这个目录，如果没有的话自行创建。注意，“&#x2F;lib&#x2F;modules&#x2F;4.1.15”这个目录用来存放驱动模块，使用modprobe 命令加载驱动模块的时候，驱动模块要存放在此目录下。“&#x2F;lib&#x2F;modules”是通用的，不管你用的什么板子、什么内核，这部分是一样的。不一样的是后面的“4.1.15”，这里要根据你所使用的 Linux 内核版本来设置，比如 ALPHA 开发板现在用的是 4.1.15 版本的 Linux 内核，因此就是“&#x2F;lib&#x2F;modules&#x2F;4.1.15”。</p>
<p>因为是通过 NFS 将 Ubuntu 中的 rootfs(第三十八章制作好的根文件系统)目录挂载为根文件系统，所以可以很方便的将 chrdevbase.ko 和 chrdevbaseAPP 复制到 rootfs&#x2F;lib&#x2F;modules&#x2F;4.1.15 目录中，命令如下：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo cp chrdevbase.ko chrdevbaseApp <span class="hljs-regexp">/home/</span>zuozhongkai<span class="hljs-regexp">/linux/</span>nfs<span class="hljs-regexp">/rootfs/</span>lib<span class="hljs-regexp">/modules/</span><span class="hljs-number">4.1</span>.<span class="hljs-number">15</span>/ -f<br></code></pre></td></tr></table></figure>
<p>拷 贝 完 成 以 后 就 会 在 开 发 板 的 &#x2F;lib&#x2F;modules&#x2F;4.1.15 目 录 下 存 在 chrdevbase.ko 和chrdevbaseAPP 这两个文件，如图所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658499732376.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>输入如下命令加载 chrdevbase.ko 驱动文件：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">insmod </span>chrdevbase.ko<br></code></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">modprobe</span> chrdevbase.ko<br></code></pre></td></tr></table></figure>
<p>如果使用 modprobe 加载驱动的话，可能会出现如图所示的提示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658499758940.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>直接输入 depmod 命令即可自动生成modules.dep，有些根文件系统可能没有 depmod 这个命令，如果没有这个命令就只能重新配置busybox，使能此命令，然后重新编译 busybox。输入“depmod”命令以后会自动生成 modules.alias、modules.symbols 和 modules.dep 这三个文件，如图 40.4.4.3 所示</p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658499803604.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>重新使用 modprobe 加载 chrdevbase.ko，结果如图 40.4.4.4 所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658499833966.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>可以看到“chrdevbase init！”这一行，这一行正是 chrdevbase.c 中模块入口函数 chrdevbase_init 输出的信息，说明模块加载成功！输入“lsmod”命令即可查看当前系统中存在的模块，结果如图所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658499857642.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>从图 40.4.4.5 可以看出，当前系统只有“chrdevbase”这一个模块。输入如下命令查看当前系统中有没有 chrdevbase 这个设备：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>devices<br></code></pre></td></tr></table></figure>

<h3 id="2、创建设备节点文件"><a href="#2、创建设备节点文件" class="headerlink" title="2、创建设备节点文件"></a>2、创建设备节点文件</h3><p>驱动加载成功需要在&#x2F;dev 目录下创建一个与之对应的设备节点文件，应用程序就是通过操作这个设备节点文件来完成对具体设备的操作。输入如下命令创建<br><code>/dev/chrdevbase</code>这个设备节点文件：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mknod</span> /dev/chrdevbase c <span class="hljs-number">200</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li>“mknod”是创建节点命令，</li>
<li>“&#x2F;dev&#x2F;chrdevbase”是要创建的节点文件，</li>
<li>“c”表示这是个字符设备，</li>
<li>“200”是设备的主设备号，</li>
<li>“0”是设备的次设备号。</li>
</ul>
<p>创建完成以后就会存在&#x2F;dev&#x2F;chrdevbase 这个文件：</p>
<h3 id="3、chrdevbase-设备操作测试"><a href="#3、chrdevbase-设备操作测试" class="headerlink" title="3、chrdevbase 设备操作测试"></a>3、chrdevbase 设备操作测试</h3><p>一切准备就绪，使用 chrdevbaseApp 软件操作 chrdevbase 这个设备，看看读写是否正常，首先进行读操作，输入如下命令：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/chrdevbaseApp /</span>dev/chrdevbase <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658500242854.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>首先输出“kernel senddata ok!”这一行信息，这是驱动程序中 chrdevbase_read 函数输出的信息，因为 chrdevbaseAPP 使用 read 函数从 chrdevbase 设备读取数据，因此 chrdevbase_read 函数就会执行。chrdevbase_read 函数向 chrdevbaseAPP 发送“kerneldata!”数据，chrdevbaseAPP 接收到以后就打印出来，“read data:kernel data!”就是 chrdevbaseAPP打印出来的接收到的数据。说明对 chrdevbase 的读操作正常，接下来测试对 chrdevbase 设备的写操作，输入如下命令：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/chrdevbaseApp /</span>dev/chrdevbase <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658500296784.png" srcset="/img/loading.gif" lazyload alt="enter description here"><br>只有一行“kernel recevdata:usr data!”，这个是驱动程序中的 chrdevbase_write 函数输出的。chrdevbaseAPP 使用 write 函数向 chrdevbase 设备写入数据“usr data!”。chrdevbase_write 函数接收到以后将其打印出来。说明对 chrdevbase 的写操作正常，既然读写都没问题，说明我们编写的 chrdevbase 驱动是没有问题的。</p>
<h3 id="4、卸载驱动模块"><a href="#4、卸载驱动模块" class="headerlink" title="4、卸载驱动模块"></a>4、卸载驱动模块</h3><p>如果不再使用某个设备的话可以将其驱动卸载掉，比如输入如下命令卸载掉 chrdevbase 这个设备：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">rmmod</span> chrdevbase.ko<br></code></pre></td></tr></table></figure>


<h1 id="新字符设备驱动实验"><a href="#新字符设备驱动实验" class="headerlink" title="新字符设备驱动实验"></a>新字符设备驱动实验</h1><p>字符设备驱动开发重点是使用 register_chrdev 函数注册字符设备，当不再使用设备的时候就使用unregister_chrdev 函数注销字符设备，驱动模块加载成功以后还需要手动使用 mknod 命令创建设备节点。register_chrdev 和 unregister_chrdev 这两个函数是老版本驱动使用的函数，现在新的字符设备驱动已经不再使用这两个函数，而是使用Linux内核推荐的新字符设备驱动API函数。</p>
<p>本节我们就来学习一下如何编写新字符设备驱动，并且在驱动模块加载的时候自动创建设备节点文件。</p>
<h2 id="动态分配设备号"><a href="#动态分配设备号" class="headerlink" title="动态分配设备号"></a>动态分配设备号</h2><p>Linux 社区推荐使用动态分配设备号，在注册字符设备之前先申请一个设备号，系统会自动给你一个没有被使用的设备号，这样就避免了冲突。卸载驱动的时候释放掉这个设备号即可，设备号的申请函数如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> alloc<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dev</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">baseminor</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">count</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">name</span>)</span><br></code></pre></td></tr></table></figure>

<ul>
<li>dev：保存申请到的设备号。</li>
<li>baseminor：次设备号起始地址，alloc_chrdev_region 可以申请一段连续的多个设备号，这些设备号的主设备号一样，但是次设备号不同，次设备号以 baseminor 为起始地址地址开始递增。一般 baseminor 为 0，也就是说次设备号从 0 开始。</li>
<li>count：要申请的设备号数量。</li>
<li>name：设备名字。</li>
</ul>
<p>注销字符设备之后要释放掉设备号，设备号释放函数如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void unregister<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-params">from</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">count</span>)</span><br></code></pre></td></tr></table></figure>
<ul>
<li>from：要释放的设备号。</li>
<li>count：表示从 from 开始，要释放的设备号数量。</li>
</ul>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-keyword">int</span> major;	/* 主设备号*/<br><span class="hljs-symbol">2 </span><span class="hljs-keyword">int</span> minor;	/* 次设备号*/<br><span class="hljs-symbol">3 </span>dev_t devid;	/* 设备号*/<br><span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-keyword">if</span> (major) &#123;	/* 定义了主设备号*/<br><span class="hljs-number">6</span>	devid = MKDEV(major, <span class="hljs-number">0</span>);	/* 大部分驱动次设备号都选择 <span class="hljs-number">0</span> */<br><span class="hljs-number">7</span>	register_chrdev_region(devid, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;test&quot;</span>);<br><span class="hljs-symbol">8 </span>&#125; <span class="hljs-keyword">else</span> &#123;	/* 没有定义设备号*/<br><span class="hljs-number">9</span>	alloc_chrdev_region(&amp;devid, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;test&quot;</span>); /* 申请设备号 */<br><span class="hljs-number">10</span>	major = MAJOR(devid);	/* 获取分配号的主设备号*/<br><span class="hljs-number">11</span>	minor = MINOR(devid);	/* 获取分配号的次设备号*/<br><span class="hljs-symbol">12 </span>&#125;<br></code></pre></td></tr></table></figure>

<p>第 1<del>3 行，定义了主&#x2F;次设备号变量 major 和 minor，以及设备号变量 devid。<br>第 5 行，判断主设备号 major 是否有效，在 Linux 驱动中一般给出主设备号的话就表示这个设备的设备号已经确定了，因为次设备号基本上都选择 0，这算个 Linux 驱动开发中约定俗成的一种规定了。<br>第 6 行，如果 major 有效的话就使用 MKDEV 来构建设备号，次设备号选择 0。<br>第 7 行，使用 register_chrdev_region 函数来注册设备号。<br>第 9</del>11 行，如果 major 无效，那就表示没有给定设备号。此时就要使用 alloc_chrdev_region</p>
<p>函数来申请设备号。设备号申请成功以后使用 MAJOR 和 MINOR 来提取出主设备号和次设备号，当然了，第 10 和 11 行提取主设备号和次设备号的代码可以不要。</p>
<p>如果要注销设备号的话，使用如下代码即可：</p>
<p><code>1 unregister_chrdev_region(devid, 1);	/* 注销设备号 */</code></p>
<h2 id="新的字符设备注册方法"><a href="#新的字符设备注册方法" class="headerlink" title="新的字符设备注册方法"></a>新的字符设备注册方法</h2><p>不再使用下属两种语句实现，而是使用 cdev 结构体</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">* 注册字符设备驱动 */<br>retvalue = register<span class="hljs-constructor">_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME, &amp;<span class="hljs-params">chrdevbase_fops</span>)</span>;<br><br><span class="hljs-comment">/* 注销字符设备驱动 */</span><br>unregister<span class="hljs-constructor">_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME)</span>;<br></code></pre></td></tr></table></figure>

<h3 id="1、字符设备结构"><a href="#1、字符设备结构" class="headerlink" title="1、字符设备结构"></a>1、字符设备结构</h3><p>在 Linux 中使用 cdev 结构体表示一个字符设备，cdev 结构体在 include&#x2F;linux&#x2F;cdev.h 文件中的定义如下：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>struct cdev &#123;<br><span class="hljs-number">2</span>	struct kobject	kobj;<br><span class="hljs-number">3</span>	struct module	*owner;<br><span class="hljs-number">4</span>	const struct file_operations *ops;<br><span class="hljs-number">5</span>	struct list_head <span class="hljs-keyword">list</span>;<br><span class="hljs-number">6</span>	dev_t	dev;<br><span class="hljs-number">7</span>	unsigned <span class="hljs-keyword">int</span>	count;<br><span class="hljs-symbol">8 </span>&#125;;```<br><br></code></pre></td></tr></table></figure>
<p>在 cdev 中有两个重要的成员变量：ops 和 dev，这两个就是字符设备文件操作函数集合file_operations 以及设备号 dev_t。编写字符设备驱动之前需要定义一个 cdev 结构体变量，这个变量就表示一个字符设备，如下所示：<br><code>struct cdev test_cdev;</code></p>
<h3 id="2、cdev-init-函数"><a href="#2、cdev-init-函数" class="headerlink" title="2、cdev_init 函数"></a>2、cdev_init 函数</h3><p>定义好 cdev 变量以后就要使用 cdev_init 函数对其进行初始化，cdev_init 函数原型如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void cdev<span class="hljs-constructor">_init(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">cdev</span>, <span class="hljs-params">const</span> <span class="hljs-params">struct</span> <span class="hljs-params">file_operations</span> <span class="hljs-operator">*</span><span class="hljs-params">fops</span>)</span><br></code></pre></td></tr></table></figure>
<p>参数 cdev 就是要初始化的 cdev 结构体变量，参数 fops 就是字符设备文件操作函数集合。<br>使用 cdev_init 函数初始化 cdev 变量的示例代码如下：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>struct cdev testcdev;<br><span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span>/* 设备操作函数 */<br><span class="hljs-symbol">4 </span>static struct file_operations test_fops = &#123;<br><span class="hljs-symbol">5 </span>	owner = THIS_MODULE,<br><span class="hljs-number">6</span>	/* 其他具体的初始项 */<br><span class="hljs-symbol">7 </span>&#125;;<br><span class="hljs-number">8</span><br><span class="hljs-symbol">9 </span>testcdev.owner = THIS_MODULE;<br><span class="hljs-symbol">10 </span>cdev_init(&amp;testcdev, &amp;test_fops); /* 初始化 cdev 结构体变量 */<br></code></pre></td></tr></table></figure>

<h3 id="3、cdev-add-函数"><a href="#3、cdev-add-函数" class="headerlink" title="3、cdev_add 函数"></a>3、cdev_add 函数</h3><p>cdev_add 函数用于向 Linux 系统添加字符设备(cdev 结构体变量)，首先使用 cdev_init 函数完成对 cdev 结构体变量的初始化，然后使用 cdev_add 函数向 Linux 系统添加这个字符设备。cdev_add 函数原型如下：<br><code>int cdev_add(struct cdev *p, dev_t dev, unsigned count)</code></p>
<ul>
<li>参数 p 指向要添加的字符设备(cdev 结构体变量)</li>
<li>参数 dev 就是设备所使用的设备号</li>
<li>参数 count 是要添加的设备数量。</li>
</ul>
<p>完善上述示例代码，加入 cdev_add 函数，内容如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">1</span> <span class="hljs-keyword">struct</span> cdev testcdev;<br><span class="hljs-number">2</span><br><span class="hljs-number">3</span> <span class="hljs-comment">/* 设备操作函数 */</span><br><span class="hljs-number">4</span> static <span class="hljs-keyword">struct</span> file_operations test_fops = &#123;<br>	<span class="hljs-number">1.</span> owner = THIS_MODULE,<br><span class="hljs-number">6</span>	<span class="hljs-comment">/* 其他具体的初始项 */</span><br><span class="hljs-number">7</span> &#125;;<br><span class="hljs-number">8</span><br><span class="hljs-number">9</span> testcdev.owner = THIS_MODULE;<br><span class="hljs-number">10</span> cdev<span class="hljs-constructor">_init(&amp;<span class="hljs-params">testcdev</span>, &amp;<span class="hljs-params">test_fops</span>)</span>;	<span class="hljs-comment">/* 初始化 cdev 结构体变量*/</span><br><span class="hljs-number">11</span> cdev<span class="hljs-constructor">_add(&amp;<span class="hljs-params">testcdev</span>, <span class="hljs-params">devid</span>, 1)</span>;	<span class="hljs-comment">/* 添加字符设备*/</span><br></code></pre></td></tr></table></figure>

<p>示例代码就是新的注册字符设备代码段，Linux 内核中大量的字符设备驱动都是采用这种方法向 Linux 内核添加字符设备。如果在加上分配设备号的程序，那么就它们一起实现的就是函数 register_chrdev 的功能。</p>
<h3 id="3、cdev-del-函数"><a href="#3、cdev-del-函数" class="headerlink" title="3、cdev_del 函数"></a>3、cdev_del 函数</h3><p>卸载驱动的时候一定要使用 cdev_del 函数从 Linux 内核中删除相应的字符设备，cdev_del函数原型如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void cdev<span class="hljs-constructor">_del(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">p</span>)</span><br></code></pre></td></tr></table></figure>

<p>参数 p 就是要删除的字符设备。如果要删除字符设备，参考如下代码：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>cdev_del(&amp;testcdev); /* 删除 cdev */<br></code></pre></td></tr></table></figure>


<p>cdev_del 和 unregister_chrdev_region 这两个函数合起来的功能相当于unregister_chrdev 函数。</p>
<h2 id="自动创建设备节点"><a href="#自动创建设备节点" class="headerlink" title="自动创建设备节点"></a>自动创建设备节点</h2><p>在驱动中实现自动创建设备节点的功能以后，使用 modprobe 加载驱动模块成功的话就会自动在&#x2F;dev 目录下创建对应的设备文件。</p>
<h3 id="mdev-机制"><a href="#mdev-机制" class="headerlink" title="mdev 机制"></a>mdev 机制</h3><p>udev 是一个用户程序，在 Linux 下通过 udev 来实现设备文件的创建与删除，udev 可以检测系统中硬件设备状态，可以根据系统中硬件设备状态来创建或者删除设备文件。比如使用modprobe 命令成功加载驱动模块以后就自动在&#x2F;dev 目录下创建对应的设备节点文件,使用rmmod 命令卸载驱动模块以后就删除掉&#x2F;dev 目录下的设备节点文件。使用 busybox 构建根文件系统的时候，busybox 会创建一个 udev 的简化版本—mdev，所以在嵌入式 Linux 中我们使用mdev 来实现设备节点文件的自动创建与删除，Linux 系统中的热插拔事件也由 mdev 管理，在&#x2F;etc&#x2F;init.d&#x2F;rcS 文件中如下语句：</p>
<p><code>echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</code></p>
<p>上述命令设置热插拔事件由 mdev 来管理，关于 udev 或 mdev 更加详细的工作原理这里就不详细探讨了，我们重点来学习一下如何通过 mdev 来实现设备文件节点的自动创建与删除。</p>
<h3 id="42-2-1-创建和删除类"><a href="#42-2-1-创建和删除类" class="headerlink" title="42.2.1 创建和删除类"></a>42.2.1 创建和删除类</h3><p>自动创建设备节点的工作是在驱动程序的入口函数中完成的，一般在 cdev_add 函数后面添加自动创建设备节点相关代码。首先要创建一个 class 类，class 是个结构体，定义在文件include&#x2F;linux&#x2F;device.h 里面。class_create 是类创建函数，class_create 是个宏定义，内容如下：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>#define class_create(owner, <span class="hljs-keyword">name</span>) \<br><span class="hljs-symbol">2 </span>(&#123; \<br><span class="hljs-symbol">3 </span>	static struct lock_class_key __<span class="hljs-keyword">key</span>; \<br><span class="hljs-symbol">4 </span>	__class_create(owner, <span class="hljs-keyword">name</span>, &amp;__<span class="hljs-keyword">key</span>); \<br><span class="hljs-symbol">5 </span>&#125;)<br><span class="hljs-number">6</span><br><span class="hljs-symbol">7 </span>struct class *__class_create(struct module *owner, const char *<span class="hljs-keyword">name</span>,<br><span class="hljs-symbol">8 </span>struct lock_class_key *<span class="hljs-keyword">key</span>)<br></code></pre></td></tr></table></figure>
<p>根据上述代码，将宏 class_create 展开以后内容如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">struct <span class="hljs-keyword">class</span> *<span class="hljs-symbol">class_create</span> (<span class="hljs-symbol">struct</span> <span class="hljs-symbol">module</span> *<span class="hljs-symbol">owner, <span class="hljs-symbol">const</span></span> <span class="hljs-symbol">char</span> *<span class="hljs-symbol">name</span>)<br></code></pre></td></tr></table></figure>
<p>class_create 一共有两个参数，参数 owner 一般为 THIS_MODULE，参数 name 是类名字。返回值是个指向结构体 class 的指针，也就是创建的类。<br>卸载驱动程序的时候需要删除掉类，类删除函数为 class_destroy，函数原型如下：<br><code>void class_destroy(struct class *cls);</code><br>参数 cls 就是要删除的类。</p>
<h3 id="创建设备"><a href="#创建设备" class="headerlink" title="创建设备"></a>创建设备</h3><p>我们还需要在这个类下创建一个设备。使用 device_create 函数在类下面创建设备，device_create 函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">device</span> *<span class="hljs-built_in">device_create</span>(<span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span>	*<span class="hljs-keyword">class</span>,<br>	<span class="hljs-keyword">struct</span> device *parent,<br>	<span class="hljs-type">dev_t</span>	devt,<br>	<span class="hljs-type">void</span>	*drvdata,<br>	<span class="hljs-type">const</span> <span class="hljs-type">char</span>	*fmt, ...)<br></code></pre></td></tr></table></figure>

<ul>
<li>device_create 是个可变参数函数，</li>
<li>参数 class 就是设备要创建哪个类下面；</li>
<li>参数 parent 是父设备，一般为 NULL，也就是没有父设备；</li>
<li>参数 devt 是设备号；</li>
<li>参数 drvdata 是设备可能会使用的一些数据，一般为 NULL；</li>
<li>参数 fmt 是设备名字，如果设置 fmt&#x3D;xxx 的话，就会生成&#x2F;dev&#x2F;xxx这个设备文件。</li>
<li>返回值就是创建好的设备</li>
</ul>
<p>同样的，卸载驱动的时候需要删除掉创建的设备，设备删除函数为 device_destroy，函数原型如下：<br><code>void device_destroy(struct class *class, dev_t devt)</code></p>
<p>参数 class 是要删除的设备所处的类，参数 devt 是要删除的设备号。</p>
<h3 id="参考示例"><a href="#参考示例" class="headerlink" title="参考示例"></a>参考示例</h3><p>在驱动入口函数里面创建类和设备，在驱动出口函数里面删除类和设备，参考示例如下：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>struct class *class;	/* 类*/<br><span class="hljs-symbol">2 </span>struct device *device; /* 设备*/<br><span class="hljs-symbol">3 </span>dev_t devid;	/* 设备号 */<br><span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span>/* 驱动入口函数 */<br><span class="hljs-symbol">6 </span>static <span class="hljs-keyword">int</span> __init led_init(void)<br><span class="hljs-symbol">7 </span>&#123;<br><span class="hljs-number">8</span>		/* 创建类 */<br><span class="hljs-number">9</span>		class = class_create(THIS_MODULE, <span class="hljs-string">&quot;xxx&quot;</span>);<br><span class="hljs-number">10</span>		/* 创建设备 */<br><span class="hljs-number">11</span>		device = device_create(class, NULL, devid, NULL, <span class="hljs-string">&quot;xxx&quot;</span>);<br><span class="hljs-number">12</span>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-symbol">13 </span>&#125;<br><span class="hljs-number">14</span><br><span class="hljs-symbol">15 </span>/* 驱动出口函数 */<br><span class="hljs-symbol">16 </span>static void __exit led_exit(void)<br><span class="hljs-symbol">17 </span>&#123;<br><span class="hljs-number">18</span>		/* 删除设备 */<br><span class="hljs-number">19</span>		device_destroy(newchrled.class, newchrled.devid);<br><span class="hljs-number">20</span>		/* 删除类 */<br><span class="hljs-number">21</span>		class_destroy(newchrled.class);<br><span class="hljs-symbol">22 </span>&#125;<br><span class="hljs-number">23</span><br><span class="hljs-symbol">24 </span>module_init(led_init);<br><span class="hljs-symbol">25 </span>module_exit(led_exit);<br></code></pre></td></tr></table></figure>

<h2 id="设置文件私有数据"><a href="#设置文件私有数据" class="headerlink" title="设置文件私有数据"></a>设置文件私有数据</h2><p>每个硬件设备都有一些属性，比如主设备号(dev_t)，类(class)、设备(device)、开关状态(state)等等，在编写驱动的时候你可以将这些属性全部写成变量的形式，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">dev_t</span> devid;	<span class="hljs-comment">/* 设备号 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cdev</span> cdev; <span class="hljs-comment">/* cdev */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">class</span> *<span class="hljs-keyword">class</span>; <span class="hljs-comment">/* 类 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">device</span> *device; <span class="hljs-comment">/* 设备 */</span><br><span class="hljs-type">int</span> major;	<span class="hljs-comment">/* 主设备号 */</span><br><span class="hljs-type">int</span> minor;	<span class="hljs-comment">/* 次设备号 */</span><br></code></pre></td></tr></table></figure>
<p>这样写肯定没有问题，但是这样写不专业！对于一个设备的所有属性信息我们最好将其做成一个结构体。编写驱动 open 函数的时候将设备结构体作为私有数据添加到设备文件中，如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* 设备结构体 */</span><br><span class="hljs-number">1</span> <span class="hljs-keyword">struct</span> test_dev&#123;<br><span class="hljs-number">2</span>	dev_t devid;	<span class="hljs-comment">/* 设备号	*/</span><br><span class="hljs-number">3</span>	<span class="hljs-keyword">struct</span> cdev cdev; <span class="hljs-comment">/* cdev	*/</span><br><span class="hljs-number">4</span>	<span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>; <span class="hljs-comment">/* 类	*/</span><br><span class="hljs-number">5</span>	<span class="hljs-keyword">struct</span> device *device; <span class="hljs-comment">/* 设备 */</span><br><span class="hljs-number">6</span>	<span class="hljs-built_in">int</span> major;	<span class="hljs-comment">/* 主设备号 */</span><br><span class="hljs-number">7</span>	<span class="hljs-built_in">int</span> minor;	<span class="hljs-comment">/* 次设备号 */</span><br><span class="hljs-number">8</span> &#125;;<br><span class="hljs-number">9</span><br><span class="hljs-number">10</span> <span class="hljs-keyword">struct</span> test_dev testdev;<br><span class="hljs-number">11</span><br><span class="hljs-number">12</span> <span class="hljs-comment">/* open 函数 */</span><br><span class="hljs-number">13</span> static <span class="hljs-built_in">int</span> test<span class="hljs-constructor">_open(<span class="hljs-params">struct</span> <span class="hljs-params">inode</span> <span class="hljs-operator">*</span><span class="hljs-params">inode</span>, <span class="hljs-params">struct</span> <span class="hljs-params">file</span> <span class="hljs-operator">*</span><span class="hljs-params">filp</span>)</span><br><span class="hljs-number">14</span> &#123;<br><span class="hljs-number">15</span>	filp-&gt;private_data = &amp;testdev; <span class="hljs-comment">/* 设置私有数据 */</span><br><span class="hljs-number">16</span>	return <span class="hljs-number">0</span>;<br><span class="hljs-number">17</span> &#125;<br></code></pre></td></tr></table></figure>

<p>在 open 函数里面设置好私有数据以后，在 write、read、close 等函数中直接读取 private_data即可得到设备结构体。</p>
<h2 id="程序编写-1"><a href="#程序编写-1" class="headerlink" title="程序编写"></a>程序编写</h2><h3 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NEWCHRLED_CNT			1		  	<span class="hljs-comment">/* 设备号个数 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NEWCHRLED_NAME			<span class="hljs-string">&quot;newchrled&quot;</span>	<span class="hljs-comment">/* 名字 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDOFF 					0			<span class="hljs-comment">/* 关灯 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDON 					1			<span class="hljs-comment">/* 开灯 */</span></span><br> <br><span class="hljs-comment">/* 寄存器物理地址 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CCM_CCGR1_BASE				(0X020C406C)	</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SW_MUX_GPIO1_IO03_BASE		(0X020E0068)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SW_PAD_GPIO1_IO03_BASE		(0X020E02F4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO1_DR_BASE				(0X0209C000)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO1_GDIR_BASE				(0X0209C004)</span><br><br><span class="hljs-comment">/* 映射后的寄存器虚拟地址指针 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *IMX6U_CCM_CCGR1;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *SW_MUX_GPIO1_IO03;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *SW_PAD_GPIO1_IO03;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *GPIO1_DR;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *GPIO1_GDIR;<br><br><span class="hljs-comment">/* newchrled设备结构体 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">newchrled_dev</span>&#123;<br>	<span class="hljs-type">dev_t</span> devid;			<span class="hljs-comment">/* 设备号 	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">cdev</span> cdev;		<span class="hljs-comment">/* cdev 	*/</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">class</span> *<span class="hljs-keyword">class</span>;		<span class="hljs-comment">/* 类 		*/</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">device</span> *device;	<span class="hljs-comment">/* 设备 	 */</span><br>	<span class="hljs-type">int</span> major;				<span class="hljs-comment">/* 主设备号	  */</span><br>	<span class="hljs-type">int</span> minor;				<span class="hljs-comment">/* 次设备号   */</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">newchrled_dev</span> newchrled;	<span class="hljs-comment">/* led设备 */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description		: LED打开/关闭</span><br><span class="hljs-comment"> * @param - sta 	: LEDON(0) 打开LED，LEDOFF(1) 关闭LED</span><br><span class="hljs-comment"> * @return 			: 无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">led_switch</span><span class="hljs-params">(u8 sta)</span></span><br><span class="hljs-function"></span>&#123;<br>	u32 val = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span>(sta == LEDON) &#123;<br>		val = <span class="hljs-built_in">readl</span>(GPIO1_DR);<br>		val &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);	<br>		<span class="hljs-built_in">writel</span>(val, GPIO1_DR);<br>	&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sta == LEDOFF) &#123;<br>		val = <span class="hljs-built_in">readl</span>(GPIO1_DR);<br>		val|= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);	<br>		<span class="hljs-built_in">writel</span>(val, GPIO1_DR);<br>	&#125;	<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description		: 打开设备</span><br><span class="hljs-comment"> * @param - inode 	: 传递给驱动的inode</span><br><span class="hljs-comment"> * @param - filp 	: 设备文件，file结构体有个叫做private_data的成员变量</span><br><span class="hljs-comment"> * 					  一般在open的时候将private_data指向设备结构体。</span><br><span class="hljs-comment"> * @return 			: 0 成功;其他 失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">led_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span></span><br><span class="hljs-function"></span>&#123;<br>	filp-&gt;private_data = &amp;newchrled; <span class="hljs-comment">/* 设置私有数据 */</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description		: 从设备读取数据 </span><br><span class="hljs-comment"> * @param - filp 	: 要打开的设备文件(文件描述符)</span><br><span class="hljs-comment"> * @param - buf 	: 返回给用户空间的数据缓冲区</span><br><span class="hljs-comment"> * @param - cnt 	: 要读取的数据长度</span><br><span class="hljs-comment"> * @param - offt 	: 相对于文件首地址的偏移</span><br><span class="hljs-comment"> * @return 			: 读取的字节数，如果为负值，表示读取失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">led_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description		: 向设备写数据 </span><br><span class="hljs-comment"> * @param - filp 	: 设备文件，表示打开的文件描述符</span><br><span class="hljs-comment"> * @param - buf 	: 要写给设备写入的数据</span><br><span class="hljs-comment"> * @param - cnt 	: 要写入的数据长度</span><br><span class="hljs-comment"> * @param - offt 	: 相对于文件首地址的偏移</span><br><span class="hljs-comment"> * @return 			: 写入的字节数，如果为负值，表示写入失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">led_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> retvalue;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> databuf[<span class="hljs-number">1</span>];<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ledstat;<br><br>	retvalue = <span class="hljs-built_in">copy_from_user</span>(databuf, buf, cnt);<br>	<span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;kernel write failed!\r\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> -EFAULT;<br>	&#125;<br><br>	ledstat = databuf[<span class="hljs-number">0</span>];		<span class="hljs-comment">/* 获取状态值 */</span><br><br>	<span class="hljs-keyword">if</span>(ledstat == LEDON) &#123;	<br>		<span class="hljs-built_in">led_switch</span>(LEDON);		<span class="hljs-comment">/* 打开LED灯 */</span><br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ledstat == LEDOFF) &#123;<br>		<span class="hljs-built_in">led_switch</span>(LEDOFF);	<span class="hljs-comment">/* 关闭LED灯 */</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description		: 关闭/释放设备</span><br><span class="hljs-comment"> * @param - filp 	: 要关闭的设备文件(文件描述符)</span><br><span class="hljs-comment"> * @return 			: 0 成功;其他 失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">led_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 设备操作函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_operations</span> newchrled_fops = &#123;<br>	.owner = THIS_MODULE,<br>	.open = led_open,<br>	.read = led_read,<br>	.write = led_write,<br>	.release = 	led_release,<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description	: 驱动出口函数</span><br><span class="hljs-comment"> * @param 		: 无</span><br><span class="hljs-comment"> * @return 		: 无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title">led_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>	u32 val = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">/* 初始化LED */</span><br>	<span class="hljs-comment">/* 1、寄存器地址映射 */</span><br>  	IMX6U_CCM_CCGR1 = <span class="hljs-built_in">ioremap</span>(CCM_CCGR1_BASE, <span class="hljs-number">4</span>);<br>	SW_MUX_GPIO1_IO03 = <span class="hljs-built_in">ioremap</span>(SW_MUX_GPIO1_IO03_BASE, <span class="hljs-number">4</span>);<br>  	SW_PAD_GPIO1_IO03 = <span class="hljs-built_in">ioremap</span>(SW_PAD_GPIO1_IO03_BASE, <span class="hljs-number">4</span>);<br>	GPIO1_DR = <span class="hljs-built_in">ioremap</span>(GPIO1_DR_BASE, <span class="hljs-number">4</span>);<br>	GPIO1_GDIR = <span class="hljs-built_in">ioremap</span>(GPIO1_GDIR_BASE, <span class="hljs-number">4</span>);<br><br>	<span class="hljs-comment">/* 2、使能GPIO1时钟 */</span><br>	val = <span class="hljs-built_in">readl</span>(IMX6U_CCM_CCGR1);<br>	val &amp;= ~(<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>);	<span class="hljs-comment">/* 清楚以前的设置 */</span><br>	val |= (<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>);	<span class="hljs-comment">/* 设置新值 */</span><br>	<span class="hljs-built_in">writel</span>(val, IMX6U_CCM_CCGR1);<br><br>	<span class="hljs-comment">/* 3、设置GPIO1_IO03的复用功能，将其复用为</span><br><span class="hljs-comment">	 *    GPIO1_IO03，最后设置IO属性。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">writel</span>(<span class="hljs-number">5</span>, SW_MUX_GPIO1_IO03);<br>	<br>	<span class="hljs-comment">/*寄存器SW_PAD_GPIO1_IO03设置IO属性</span><br><span class="hljs-comment">	 *bit 16:0 HYS关闭</span><br><span class="hljs-comment">	 *bit [15:14]: 00 默认下拉</span><br><span class="hljs-comment">     *bit [13]: 0 kepper功能</span><br><span class="hljs-comment">     *bit [12]: 1 pull/keeper使能</span><br><span class="hljs-comment">     *bit [11]: 0 关闭开路输出</span><br><span class="hljs-comment">     *bit [7:6]: 10 速度100Mhz</span><br><span class="hljs-comment">     *bit [5:3]: 110 R0/6驱动能力</span><br><span class="hljs-comment">     *bit [0]: 0 低转换率</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">writel</span>(<span class="hljs-number">0x10B0</span>, SW_PAD_GPIO1_IO03);<br><br>	<span class="hljs-comment">/* 4、设置GPIO1_IO03为输出功能 */</span><br>	val = <span class="hljs-built_in">readl</span>(GPIO1_GDIR);<br>	val &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);	<span class="hljs-comment">/* 清除以前的设置 */</span><br>	val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);	<span class="hljs-comment">/* 设置为输出 */</span><br>	<span class="hljs-built_in">writel</span>(val, GPIO1_GDIR);<br><br>	<span class="hljs-comment">/* 5、默认关闭LED */</span><br>	val = <span class="hljs-built_in">readl</span>(GPIO1_DR);<br>	val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);	<br>	<span class="hljs-built_in">writel</span>(val, GPIO1_DR);<br><br>	<span class="hljs-comment">/* 注册字符设备驱动 */</span><br>	<span class="hljs-comment">/* 1、创建设备号 */</span><br>	<span class="hljs-keyword">if</span> (newchrled.major) &#123;		<span class="hljs-comment">/*  定义了设备号 */</span><br>		newchrled.devid = <span class="hljs-built_in">MKDEV</span>(newchrled.major, <span class="hljs-number">0</span>);<br>		<span class="hljs-built_in">register_chrdev_region</span>(newchrled.devid, NEWCHRLED_CNT, NEWCHRLED_NAME);<br>	&#125; <span class="hljs-keyword">else</span> &#123;						<span class="hljs-comment">/* 没有定义设备号 */</span><br>		<span class="hljs-built_in">alloc_chrdev_region</span>(&amp;newchrled.devid, <span class="hljs-number">0</span>, NEWCHRLED_CNT, NEWCHRLED_NAME);	<span class="hljs-comment">/* 申请设备号 */</span><br>		newchrled.major = <span class="hljs-built_in">MAJOR</span>(newchrled.devid);	<span class="hljs-comment">/* 获取分配号的主设备号 */</span><br>		newchrled.minor = <span class="hljs-built_in">MINOR</span>(newchrled.devid);	<span class="hljs-comment">/* 获取分配号的次设备号 */</span><br>	&#125;<br>	<span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;newcheled major=%d,minor=%d\r\n&quot;</span>,newchrled.major, newchrled.minor);	<br>	<br>	<span class="hljs-comment">/* 2、初始化cdev */</span><br>	newchrled.cdev.owner = THIS_MODULE;<br>	<span class="hljs-built_in">cdev_init</span>(&amp;newchrled.cdev, &amp;newchrled_fops);<br>	<br>	<span class="hljs-comment">/* 3、添加一个cdev */</span><br>	<span class="hljs-built_in">cdev_add</span>(&amp;newchrled.cdev, newchrled.devid, NEWCHRLED_CNT);<br><br>	<span class="hljs-comment">/* 4、创建类 */</span><br>	newchrled.<span class="hljs-keyword">class</span> = <span class="hljs-built_in">class_create</span>(THIS_MODULE, NEWCHRLED_NAME);<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">IS_ERR</span>(newchrled.<span class="hljs-keyword">class</span>)) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">PTR_ERR</span>(newchrled.<span class="hljs-keyword">class</span>);<br>	&#125;<br><br>	<span class="hljs-comment">/* 5、创建设备 */</span><br>	newchrled.device = <span class="hljs-built_in">device_create</span>(newchrled.<span class="hljs-keyword">class</span>, <span class="hljs-literal">NULL</span>, newchrled.devid, <span class="hljs-literal">NULL</span>, NEWCHRLED_NAME);<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">IS_ERR</span>(newchrled.device)) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">PTR_ERR</span>(newchrled.device);<br>	&#125;<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description	: 驱动出口函数</span><br><span class="hljs-comment"> * @param 		: 无</span><br><span class="hljs-comment"> * @return 		: 无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title">led_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">/* 取消映射 */</span><br>	<span class="hljs-built_in">iounmap</span>(IMX6U_CCM_CCGR1);<br>	<span class="hljs-built_in">iounmap</span>(SW_MUX_GPIO1_IO03);<br>	<span class="hljs-built_in">iounmap</span>(SW_PAD_GPIO1_IO03);<br>	<span class="hljs-built_in">iounmap</span>(GPIO1_DR);<br>	<span class="hljs-built_in">iounmap</span>(GPIO1_GDIR);<br><br>	<span class="hljs-comment">/* 注销字符设备驱动 */</span><br>	<span class="hljs-built_in">cdev_del</span>(&amp;newchrled.cdev);<span class="hljs-comment">/*  删除cdev */</span><br>	<span class="hljs-built_in">unregister_chrdev_region</span>(newchrled.devid, NEWCHRLED_CNT); <span class="hljs-comment">/* 注销设备号 */</span><br><br>	<span class="hljs-built_in">device_destroy</span>(newchrled.<span class="hljs-keyword">class</span>, newchrled.devid);<br>	<span class="hljs-built_in">class_destroy</span>(newchrled.<span class="hljs-keyword">class</span>);<br>&#125;<br><br><span class="hljs-built_in">module_init</span>(led_init);<br><span class="hljs-built_in">module_exit</span>(led_exit);<br><span class="hljs-built_in">MODULE_LICENSE</span>(<span class="hljs-string">&quot;GPL&quot;</span>);<br><span class="hljs-built_in">MODULE_AUTHOR</span>(<span class="hljs-string">&quot;zuozhongkai&quot;</span>);<br><br></code></pre></td></tr></table></figure>
<h3 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h3><p>与旧字符设备相同</p>
<h2 id="运行测试-1"><a href="#运行测试-1" class="headerlink" title="运行测试"></a>运行测试</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><h4 id="1、编译驱动程序"><a href="#1、编译驱动程序" class="headerlink" title="1、编译驱动程序"></a>1、编译驱动程序</h4><p>编写 Makefile 文件，本章实验的 Makefile 文件和就旧字符设备实验基本一样，只是将 obj-m 变量的值改为 newchrled.o，Makefile 内容如下所示：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span> KERNELDIR := <span class="hljs-regexp">/home/</span>zuozhongkai<span class="hljs-regexp">/linux/</span>IMX6ULL<span class="hljs-regexp">/linux/</span>temp/linux-imx-<br>rel_imx_4.<span class="hljs-number">1.15</span>_2.<span class="hljs-number">1.0</span>_ga_alientek<br>......<br><span class="hljs-number">4</span> obj-m := newchrled.o<br>......<br><span class="hljs-number">11</span> clean:<br><span class="hljs-number">12</span> $(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) clean<br></code></pre></td></tr></table></figure>
<p>第 4 行，设置 obj-m 变量的值为 newchrled.o。<br>输入如下命令编译出驱动模块文件：<br><code>make -j32</code><br>编译成功以后就会生成一个名为“newchrled.ko”的驱动模块文件。</p>
<h4 id="2、编译测试-APP"><a href="#2、编译测试-APP" class="headerlink" title="2、编译测试 APP"></a>2、编译测试 APP</h4><p>输入如下命令编译测试 ledApp.c 这个测试程序：<br><code>arm-linux-gnueabihf-gcc ledApp.c -o ledApp</code><br>编译成功以后就会生成 ledApp 这个应用程序。</p>
<h3 id="运行测试-2"><a href="#运行测试-2" class="headerlink" title="运行测试"></a>运行测试</h3><p>将上一小节编译出来的 newchrled.ko 和 ledApp 这两个文件拷贝到 rootfs&#x2F;lib&#x2F;modules&#x2F;4.1.15<br>目录中，重启开发板，进入到目录 lib&#x2F;modules&#x2F;4.1.15 中，输入如下命令加载 newchrled.ko 驱动<br>模块：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">depmod	<span class="hljs-regexp">//</span>第一次加载驱动的时候需要运行此命令<br>modprobe newchrled.ko	<span class="hljs-regexp">//</span>加载驱动<br></code></pre></td></tr></table></figure>
<p>驱动加载成功以后会输出申请到的主设备号和次设备号，如图 42.6.2.1 所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658565295083.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>从图 42.6.2.1 可以看出，申请到的主设备号为 249，次设备号为 0。驱动加载成功以后会自动在&#x2F;dev 目录下创建设备节点文件&#x2F;dev&#x2F;newchrdev，输入如下命令查看&#x2F;dev&#x2F;newchrdev 这个设备节点文件是否存在：<br><code>ls /dev/newchrled -l</code><br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658565321117.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>从图 42.6.2.2 中可以看出，&#x2F;dev&#x2F;newchrled 这个设备文件存在，而且主设备号为 249，此设备号为 0，说明设备节点文件创建成功。<br>驱动节点创建成功以后就可以使用 ledApp 软件来测试驱动是否工作正常，输入如下命令打开 LED 灯：</p>
<blockquote>
<p>app 文件要下赋予可执行权限<br>可能是网络不好，我这里执行程序后，串口会卡顿几秒甚至一分钟，然后板子上的灯才会有变化，如果你这里也一样，就耐心等一会<br>后期使用，发现文件夹是复制过来的，没有修改权限，程序卡顿也可能和这个有关。给与777权限后，不卡顿</p>
</blockquote>
<p><code>./ledApp /dev/newchrled 1	//打开 LED 灯</code><br>输入上述命令以后观察 I.MX6U-ALPHA 开发板上的红色 LED 灯是否点亮，如果点亮的话说明驱动工作正常。在输入如下命令关闭 LED 灯：<br><code>./ledApp /dev/newchrled 0	//关闭 LED 灯</code><br>输入上述命令以后观察 I.MX6U-ALPHA 开发板上的红色 LED 灯是否熄灭。如果要卸载驱动的话输入如下命令即可：<br><code>rmmod newchrled.ko</code></p>
<h1 id="linux设备树"><a href="#linux设备树" class="headerlink" title="linux设备树"></a>linux设备树</h1><h2 id="什么是设备树？"><a href="#什么是设备树？" class="headerlink" title="什么是设备树？"></a>什么是设备树？</h2><p>设备树(Device Tree)，将这个词分开就是“设备”和“树”，描述设备树的文件叫做 DTS(Device Tree Source)，这个 DTS 文件采用树形结构描述板级设备，也就是开发板上的设备信息，比如CPU 数量、 内存基地址、IIC 接口上接了哪些设备、SPI 接口上接了哪些设备等等，如图 43.1.1所示：</p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658628442853.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>在图中，树的主干就是系统总线，IIC 控制器、GPIO 控制器、SPI 控制器等都是接<br>到系统主线上的分支。IIC 控制器有分为 IIC1 和 IIC2 两种，其中 IIC1 上接了 FT5206 和 AT24C02这两个 IIC 设备，IIC2 上只接了 MPU6050 这个设备。DTS 文件的主要功能就是按照图所示的结构来描述板子上的设备信息，DTS 文件描述设备信息是有相应的语法规则要求的。</p>
<p>将描述板级硬件信息的内容从 Linux 内核中分离开来，用一个专属的文件格式来描述，这个专属的文件就叫做设备树，文件扩展名为.dts。一个 SOC 可以作出很多不同的板子，这些不同的板子肯定是有共同的信息，将这些共同的信息提取出来作为一个通用的文件，其他的.dts 文件直接引用这个通用文件即可，这个通用文件就是.dtsi 文件，类似于 C 语言中的头文件。</p>
<ul>
<li>.dts 一般用来描述板级信息(也就是开发板上有哪些 IIC 设备、SPI 设备等)，</li>
<li>.dtsi 描述 SOC 级信息(也就是 SOC 有几个 CPU、主频是多少、各个外设控制器信息等)。</li>
</ul>
<h2 id="DTS、DTB-和-DTC"><a href="#DTS、DTB-和-DTC" class="headerlink" title="DTS、DTB 和 DTC"></a>DTS、DTB 和 DTC</h2><p>DTS 是设备树源码文件，DTB 是将 DTS 编译以后得到的二进制文件。<br>DTC是编译工具，相当于gcc编译器，将.dts编译成.dtb。DTC工具源码在Linux内核的scripts&#x2F;dtc 目录下</p>
<p>如果要编译 DTS 文件的话只需要进入到 Linux 源码根目录下，然后执行如下命令：</p>
<ul>
<li><code>make all</code> 编译 Linux 源码中的所有东西，包括 zImage，.ko 驱动模块以及设备树。</li>
<li>或者： <code>make dtbs</code> 只编译设备树。</li>
<li>或者：<code>make xxx.dtb</code> 只编译指定的设备树</li>
</ul>
<p>基于 ARM 架构的 SOC 有很多种，一种 SOC 又可以制作出很多款板子，每个板子都有一个对应的 DTS 文件，那么如何确定编译哪一个 DTS 文件呢？我们就以 I.MX6ULL 这款芯片对应的板子为例来看一下，打开 arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;Makefile，有如下内容：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">381</span> dtb-$(CONFIG_SOC_IMX6UL) += <span class="hljs-string">\</span><br><span class="hljs-number">382</span> imx6ul-<span class="hljs-number">14x</span>14-ddr3-arm2.dtb <span class="hljs-string">\</span><br><span class="hljs-number">383</span> imx6ul-<span class="hljs-number">14x</span>14-ddr3-arm2-emmc.dtb <span class="hljs-string">\</span><br>......<br><span class="hljs-number">400</span> dtb-$(CONFIG_SOC_IMX6ULL) += <span class="hljs-string">\</span><br><span class="hljs-number">401</span> imx6ull-<span class="hljs-number">14x</span>14-ddr3-arm2.dtb <span class="hljs-string">\</span><br><span class="hljs-number">402</span> imx6ull-<span class="hljs-number">14x</span>14-ddr3-arm2-adc.dtb <span class="hljs-string">\</span><br><span class="hljs-number">403</span> imx6ull-<span class="hljs-number">14x</span>14-ddr3-arm2-cs42888.dtb <span class="hljs-string">\</span><br><span class="hljs-number">404</span> imx6ull-<span class="hljs-number">14x</span>14-ddr3-arm2-ecspi.dtb <span class="hljs-string">\</span><br><span class="hljs-number">405</span> imx6ull-<span class="hljs-number">14x</span>14-ddr3-arm2-emmc.dtb <span class="hljs-string">\</span><br><span class="hljs-number">406</span> imx6ull-<span class="hljs-number">14x</span>14-ddr3-arm2-epdc.dtb <span class="hljs-string">\</span><br><span class="hljs-number">407</span> imx6ull-<span class="hljs-number">14x</span>14-ddr3-arm2-flexcan2.dtb <span class="hljs-string">\</span><br><span class="hljs-number">408</span> imx6ull-<span class="hljs-number">14x</span>14-ddr3-arm2-gpmi-weim.dtb <span class="hljs-string">\</span><br><span class="hljs-number">409</span> imx6ull-<span class="hljs-number">14x</span>14-ddr3-arm2-lcdif.dtb <span class="hljs-string">\</span><br><span class="hljs-number">410</span> imx6ull-<span class="hljs-number">14x</span>14-ddr3-arm2-ldo.dtb <span class="hljs-string">\</span><br><span class="hljs-number">411</span> imx6ull-<span class="hljs-number">14x</span>14-ddr3-arm2-qspi.dtb <span class="hljs-string">\</span><br><span class="hljs-number">412</span> imx6ull-<span class="hljs-number">14x</span>14-ddr3-arm2-qspi-all.dtb <span class="hljs-string">\</span><br><span class="hljs-number">413</span> imx6ull-<span class="hljs-number">14x</span>14-ddr3-arm2-tsc.dtb <span class="hljs-string">\</span><br><span class="hljs-number">414</span> imx6ull-<span class="hljs-number">14x</span>14-ddr3-arm2-uart2.dtb <span class="hljs-string">\</span><br><span class="hljs-number">415</span> imx6ull-<span class="hljs-number">14x</span>14-ddr3-arm2-usb.dtb <span class="hljs-string">\</span><br><span class="hljs-number">416</span> imx6ull-<span class="hljs-number">14x</span>14-ddr3-arm2-wm8958.dtb <span class="hljs-string">\</span><br><span class="hljs-number">417</span> imx6ull-<span class="hljs-number">14x</span>14-evk.dtb <span class="hljs-string">\</span><br><span class="hljs-number">418</span> imx6ull-<span class="hljs-number">14x</span>14-evk-btwifi.dtb <span class="hljs-string">\</span><br><span class="hljs-number">419</span> imx6ull-<span class="hljs-number">14x</span>14-evk-emmc.dtb <span class="hljs-string">\</span><br><span class="hljs-number">420</span> imx6ull-<span class="hljs-number">14x</span>14-evk-gpmi-weim.dtb <span class="hljs-string">\</span><br><span class="hljs-number">421</span> imx6ull-<span class="hljs-number">14x</span>14-evk-usb-certi.dtb <span class="hljs-string">\</span><br><span class="hljs-number">422</span> imx6ull-alientek-emmc.dtb <span class="hljs-string">\</span><br><span class="hljs-number">423</span> imx6ull-alientek-nand.dtb <span class="hljs-string">\</span><br><span class="hljs-number">424</span> imx6ull-<span class="hljs-number">9x</span>9-evk.dtb <span class="hljs-string">\</span><br><span class="hljs-number">425</span> imx6ull-<span class="hljs-number">9x</span>9-evk-btwifi.dtb <span class="hljs-string">\</span><br><span class="hljs-number">426</span> imx6ull-<span class="hljs-number">9x</span>9-evk-ldo.dtb<br><span class="hljs-number">427</span> dtb-$(CONFIG_SOC_IMX6SLL) += <span class="hljs-string">\</span><br></code></pre></td></tr></table></figure>

<p>可以看出，当选中 I.MX6ULL 这个 SOC 以后(CONFIG_SOC_IMX6ULL&#x3D;y)，所有使用到I.MX6ULL 这个 SOC 的板子对应的.dts 文件都会被编译为.dtb。如果我们使用 I.MX6ULL 新做了一个板子，只需要新建一个此板子对应的.dts 文件，然后将对应的.dtb 文件名添加到 dtb-$(CONFIG_SOC_IMX6ULL)下，这样在编译设备树的时候就会将对应的.dts 编译为二进制的.dtb文件。</p>
<p>示例代码第 417 和 421 行就是我们在给正点原子的 I.MX6U-ALPHA 开发板移植Linux 系统的时候添加的设备树。</p>
<h2 id="DTS-语法"><a href="#DTS-语法" class="headerlink" title="DTS 语法"></a>DTS 语法</h2><p>大多时候是直接在 SOC 厂商提供的.dts文件上进行修改。我们肯定需要修改.dts文件。</p>
<p>本节我们就以 imx6ull-alientek-emmc.dts 这个文件为例来讲解一下 DTS 语法。关于设备树详细的语法规则请参考开发板光盘中，路 径 为 ： 4 、 参 考 资 料 -&gt;Devicetree SpecificationV0.2.pdf 、 4 、 参 考 资 料 -&gt;Power_ePAPR_APPROVED_v1.12.pdf</p>
<h3 id="dtsi-头文件"><a href="#dtsi-头文件" class="headerlink" title=".dtsi 头文件"></a>.dtsi 头文件</h3><p>和 C 语言一样，设备树也支持头文件，设备树的头文件扩展名为.dtsi。在 imx6ull-alientek-emmc.dts 中有如下所示内容：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">12 </span>#include &lt;dt-bindings/<span class="hljs-keyword">input</span>/<span class="hljs-keyword">input</span>.h&gt;<br><span class="hljs-symbol">13 </span>#include <span class="hljs-string">&quot;imx6ull.dtsi&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>第 12 行，使用“#include”来引用“input.h”这个.h 头文件。</li>
<li>第 13 行，使用“#include”来引用“imx6ull.dtsi”这个.dtsi 头文件。</li>
</ul>
<p>在.dts 设备树文件中，可以通过 “#include”来引用.h、.dtsi 和.dts 文件。只是，我们在编写设备树头文件的时候最好选择.dtsi 后缀。</p>
<p>一般.dtsi 文件用于描述 SOC 的内部外设信息，比如 CPU 架构、主频、外设寄存器地址范围，比如 UART、IIC 等等。比如 imx6ull.dtsi 就是描述 I.MX6ULL 这颗 SOC 内部外设情况信息的</p>
<h3 id="设备节点"><a href="#设备节点" class="headerlink" title="设备节点"></a>设备节点</h3><p>设备树是采用树形结构来描述板子上的设备信息的文件，每个设备都是一个节点，叫做设备节点，每个节点都通过一些属性信息来描述节点信息，属性就是键—值对。以下是从imx6ull.dtsi 文件中缩减出来的设备树文件内容：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>/ &#123;<br><span class="hljs-symbol">2 </span>		aliases &#123;<br><span class="hljs-symbol">3 </span>		can0 = &amp;flexcan1;<br><span class="hljs-symbol">4 </span>		&#125;;<br><span class="hljs-symbol">5 </span><br><span class="hljs-number">6</span>		cpus &#123;<br><span class="hljs-symbol">7 </span>			#address-cells = &lt;<span class="hljs-number">1</span>&gt;;<br><span class="hljs-symbol">8 </span>			#size-cells = &lt;<span class="hljs-number">0</span>&gt;;<br><span class="hljs-number">9</span><br><span class="hljs-symbol">10 </span>			cpu0: cpu@<span class="hljs-number">0</span> &#123;<br><span class="hljs-symbol">11 </span>				compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br><span class="hljs-symbol">12 </span>				device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br><span class="hljs-symbol">13 </span>				reg = &lt;<span class="hljs-number">0</span>&gt;;<br><span class="hljs-symbol">14 </span>			&#125;;<br><span class="hljs-symbol">15 </span>		&#125;;<br><span class="hljs-number">16</span><br><span class="hljs-symbol">17 </span>		intc: interrupt-controller@<span class="hljs-number">00</span>a01000 &#123;<br><span class="hljs-symbol">18 </span>			compatible = <span class="hljs-string">&quot;arm,cortex-a7-gic&quot;</span>;<br><span class="hljs-symbol">19 </span>			#interrupt-cells = &lt;<span class="hljs-number">3</span>&gt;;<br><span class="hljs-symbol">20 </span>			interrupt-controller;<br><span class="hljs-symbol">21 </span>			reg = &lt;<span class="hljs-number">0</span>x00a01000 <span class="hljs-number">0</span>x1000&gt;,<br><span class="hljs-symbol">22 </span>				  &lt;<span class="hljs-number">0</span>x00a02000 <span class="hljs-number">0</span>x100&gt;;<br><span class="hljs-symbol">23 </span>		&#125;;<br><span class="hljs-symbol">24 </span>&#125;<br></code></pre></td></tr></table></figure>

<p>第 1 行，“&#x2F;”是根节点，每个设备树文件只有一个根节点。细心的同学应该会发现， imx6ull.dtsi 和 imx6ull-alientek-emmc.dts 这两个文件都有一个“&#x2F;”根节点，这样不会出错吗？不会的，因为这两个“&#x2F;”根节点的内容会合并成一个根节点。<br>第 2、 6 和 17 行， aliases、 cpus 和 intc 是三个子节点，在设备树中节点命名格式如下：<br><code>node-name@unit-address</code><br>其中“node-name”是节点名字，为 ASCII 字符串，节点名字应该能够清晰的描述出节点的功能，比如“uart1”就表示这个节点是 UART1 外设。“unit-address”一般表示设备的地址或寄存器首地址，如果某个节点没有地址或者寄存器的话“unit-address”可以不要，比如“cpu@0”、“interrupt-controller@00a01000”。</p>
<p>但是我们在示例代码 43.3.2.1 中我们看到的节点命名却如下所示：<br><code>cpu0:cpu@0</code><br>用“：”隔开成了两部分，“：”前面的是节点标签(label)，“：”后面的才是节点名字，格式如下所示：<br><code>label: node-name@unit-address</code><br>引入 label 的目的就是为了方便访问节点，可以直接通过&amp;label 来访问这个节点，比如通过&amp;cpu0 就可以访问“cpu@0”这个节点，而不需要输入完整的节点名字。再比如节点 “intc:interrupt-controller@00a01000”，节点 label 是 intc，而节点名字就很长了，为“ interruptcontroller@00a01000”。很明显通过&amp;intc 来访问“interrupt-controller@00a01000”这个节点要方便很多！<br>第 10 行， cpu0 也是一个节点，只是 cpu0 是 cpus 的子节点。<br>每个节点都有不同属性，不同的属性又有不同的内容，属性都是键值对，值可以为空或任意的字节流。设备树源码中常用的几种数据形式如下所示：</p>
<ul>
<li>①、字符串<br>compatible &#x3D; “arm,cortex-a7”;<br>上述代码设置 compatible 属性的值为字符串“arm,cortex-a7”。</li>
<li>②、 32 位无符号整数<br>reg &#x3D; &lt;0&gt;;<br>上述代码设置 reg 属性的值为 0， reg 的值也可以设置为一组值，比如：<br>reg &#x3D; &lt;0 0x123456 100&gt;;</li>
<li>③、字符串列表<br>属性值也可以为字符串列表，字符串和字符串之间采用“,”隔开，如下所示：<br>compatible &#x3D; “fsl,imx6ull-gpmi-nand”, “fsl, imx6ul-gpmi-nand”;<br>上述代码设置属性 compatible 的值为“fsl,imx6ull-gpmi-nand”和“fsl, imx6ul-gpmi-nand”。</li>
</ul>
<h3 id="标准属性"><a href="#标准属性" class="headerlink" title="标准属性"></a>标准属性</h3><p>节点是由一堆的属性组成，节点都是具体的设备，不同的设备需要的属性不同，用户可以自定义属性。除了用户自定义属性，有很多属性是标准属性， Linux 下的很多外设驱动都会使用这些标准属性，本节我们就来学习一下几个常用的标准属性。</p>
<h4 id="1、-compatible-属性"><a href="#1、-compatible-属性" class="headerlink" title="1、 compatible 属性"></a>1、 compatible 属性</h4><p>compatible 属性也叫做“兼容性”属性，这是非常重要的一个属性！ compatible 属性的值是一个字符串列表， compatible 属性用于将设备和驱动绑定起来。字符串列表用于选择设备所要使用的驱动程序， compatible 属性的值格式如下所示：<br><code>&quot;manufacturer,model&quot;</code><br>其中 manufacturer 表示厂商， model 一般是模块对应的驱动名字。比如 imx6ull-alientekemmc.dts 中 sound 节点是 I.MX6U-ALPHA 开发板的音频设备节点， I.MX6U-ALPHA 开发板上的音频芯片采用的欧胜(WOLFSON)出品的 WM8960， sound 节点的 compatible 属性值如下：<br><code>compatible = &quot;fsl,imx6ul-evk-wm8960&quot;,&quot;fsl,imx-audio-wm8960&quot;;</code><br>属性值有两个，分别为“fsl,imx6ul-evk-wm8960”和“fsl,imx-audio-wm8960”，其中“fsl”表示厂商是飞思卡尔，“imx6ul-evk-wm8960”和“imx-audio-wm8960”表示驱动模块名字。 sound这个设备首先使用第一个兼容值在 Linux 内核里面查找，看看能不能找到与之匹配的驱动文件，如果没有找到的话就使用第二个兼容值查。</p>
<p>驱动程序文件都会有一个 OF 匹配表，此 OF 匹配表保存着一些 compatible 值，如果设备节点的 compatible 属性值和 OF 匹配表中的任何一个值相等，那么就表示设备可以使用这个驱动。比如在驱动文件 imx-wm8960.c 中有如下内容：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">632 </span>static const struct of_device_id imx_wm8960_dt_ids[] = &#123;<br><span class="hljs-symbol">633 </span>	&#123; .compatible = <span class="hljs-string">&quot;fsl,imx-audio-wm8960&quot;</span>, &#125;,<br><span class="hljs-symbol">634 </span>	&#123; /* sentinel */ &#125;<br><span class="hljs-symbol">635 </span>&#125;;<br><span class="hljs-symbol">636 </span>MODULE_DEVICE_TABLE(of, imx_wm8960_dt_ids);<br><span class="hljs-number">637</span><br><span class="hljs-symbol">638 </span>static struct platform_driver imx_wm8960_driver = &#123;<br><span class="hljs-symbol">639 </span>	.driver = &#123;<br><span class="hljs-symbol">640 </span>		.<span class="hljs-keyword">name</span> = <span class="hljs-string">&quot;imx-wm8960&quot;</span>,<br><span class="hljs-symbol">641 </span>		.pm = &amp;snd_soc_pm_ops,<br><span class="hljs-number">642</span>			 .of_match_table = imx_wm8960_dt_ids,<br><span class="hljs-symbol">643 </span>	&#125;,<br><span class="hljs-number">644</span>	 	.probe = imx_wm8960_probe,<br><span class="hljs-symbol">645 </span>	.<span class="hljs-comment">remove = imx_wm8960_remove,</span><br><span class="hljs-symbol">646 </span>&#125;;<br></code></pre></td></tr></table></figure>
<p>第 632~635 行的数组 imx_wm8960_dt_ids 就是 imx-wm8960.c 这个驱动文件的匹配表，此匹配表只有一个匹配值“fsl,imx-audio-wm8960”。如果在设备树中有哪个节点的 compatible 属性值与此相等，那么这个节点就会使用此驱动文件。<br>第 642 行， wm8960 采用了 platform_driver 驱动模式，关于 platform_driver 驱动后面会讲解。此行设置.of_match_table 为 imx_wm8960_dt_ids，也就是设置这个 platform_driver 所使用的OF 匹配表。</p>
<h4 id="2、-model-属性"><a href="#2、-model-属性" class="headerlink" title="2、 model 属性"></a>2、 model 属性</h4><p>model 属性值也是一个字符串，一般 model 属性描述设备模块信息，比如名字什么的，比如：<br><code>model = &quot;wm8960-audio&quot;;</code></p>
<h4 id="3、-status-属性"><a href="#3、-status-属性" class="headerlink" title="3、 status 属性"></a>3、 status 属性</h4><p>status 属性看名字就知道是和设备状态有关的， status 属性值也是字符串，字符串是设备的状态信息，可选的状态如表 43.3.3.1 所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658631410840.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<h4 id="4、-address-cells-和-size-cells-属性"><a href="#4、-address-cells-和-size-cells-属性" class="headerlink" title="4、 #address-cells 和#size-cells 属性"></a>4、 #address-cells 和#size-cells 属性</h4><p>这两个属性的值都是无符号 32 位整形， #address-cells 和#size-cells 这两个属性可以用在任何拥有子节点的设备中，用于描述子节点的地址信息。 #address-cells 属性值决定了子节点 reg 属性中地址信息所占用的字长(32 位)， #size-cells 属性值决定了子节点 reg 属性中长度信息所占的字长(32 位)。 #address-cells 和#size-cells 表明了子节点应该如何编写 reg 属性值，一般 reg 属性<br>都是和地址有关的内容，和地址相关的信息有两种：起始地址和地址长度， reg 属性的格式一为：<br><code>reg = &lt;address1 length1 address2 length2 address3 length3……&gt;</code><br>每个“address length”组合表示一个地址范围，其中 address 是起始地址， length 是地址长度， #address-cells 表明 address 这个数据所占用的字长， #size-cells 表明 length 这个数据所占用的字长，比如:</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>spi4 &#123;<br><span class="hljs-symbol">2 </span>		compatible = <span class="hljs-string">&quot;spi-gpio&quot;</span>;<br><span class="hljs-symbol">3 </span>		#address-cells = &lt;<span class="hljs-number">1</span>&gt;;<br><span class="hljs-symbol">4 </span>		#size-cells = &lt;<span class="hljs-number">0</span>&gt;;<br><span class="hljs-symbol">5 </span><br><span class="hljs-number">6</span>		gpio_spi: gpio_spi@<span class="hljs-number">0</span> &#123;<br><span class="hljs-symbol">7 </span>			compatible = <span class="hljs-string">&quot;fairchild,74hc595&quot;</span>;<br><span class="hljs-symbol">8 </span>			reg = &lt;<span class="hljs-number">0</span>&gt;;<br><span class="hljs-symbol">9 </span>		&#125;;<br><span class="hljs-symbol">10 </span>&#125;;<br><span class="hljs-number">11</span><br><span class="hljs-symbol">12 </span>aips3: aips-bus@<span class="hljs-number">02200000</span> &#123;<br><span class="hljs-symbol">13 </span>		compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br><span class="hljs-symbol">14 </span>		#address-cells = &lt;<span class="hljs-number">1</span>&gt;;<br><span class="hljs-symbol">15 </span>		#size-cells = &lt;<span class="hljs-number">1</span>&gt;;<br><span class="hljs-number">16</span><br><span class="hljs-symbol">17 </span>		dcp: dcp@<span class="hljs-number">02280000</span> &#123;<br><span class="hljs-symbol">18 </span>			compatible = <span class="hljs-string">&quot;fsl,imx6sl-dcp&quot;</span>;<br><span class="hljs-symbol">19 </span>			reg = &lt;<span class="hljs-number">0</span>x02280000 <span class="hljs-number">0</span>x4000&gt;;<br><span class="hljs-symbol">20 </span>		&#125;;<br><span class="hljs-symbol">21 </span>&#125;;<br></code></pre></td></tr></table></figure>
<p>第 3， 4 行，节点 spi4 的#address-cells &#x3D; &lt;1&gt;， #size-cells &#x3D; &lt;0&gt;，说明 spi4 的子节点 reg 属性中起始地址所占用的字长为 1，地址长度所占用的字长为 0。<br>第 8 行，子节点 gpio_spi: gpio_spi@0 的 reg 属性值为 &lt;0&gt;，因为父节点设置了#addresscells &#x3D; &lt;1&gt;， #size-cells &#x3D; &lt;0&gt;，因此 addres&#x3D;0，没有 length 的值，相当于设置了起始地址，而没有设置地址长度。<br>第 14， 15 行，设置 aips3: aips-bus@02200000 节点#address-cells &#x3D; &lt;1&gt;， #size-cells &#x3D; &lt;1&gt;，说明 aips3: aips-bus@02200000 节点起始地址长度所占用的字长为 1，地址长度所占用的字长也为 1。<br>第 19 行，子节点 dcp: dcp@02280000 的 reg 属性值为&lt;0x02280000 0x4000&gt;，因为父节点设置了#address-cells &#x3D; &lt;1&gt;， #size-cells &#x3D; &lt;1&gt;， address&#x3D; 0x02280000， length&#x3D; 0x4000，相当于设置了起始地址为 0x02280000，地址长度为 0x40000。</p>
<h4 id="5、-reg-属性"><a href="#5、-reg-属性" class="headerlink" title="5、 reg 属性"></a>5、 reg 属性</h4><p>reg 属性前面已经提到过了， reg 属性的值一般是(address， length)对。 reg 属性一般用于描述设备地址空间资源信息，一般都是某个外设的寄存器地址范围信息，比如在 imx6ull.dtsi 中有如下内容：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">323 </span>uart1: serial@<span class="hljs-number">02020000</span> &#123;<br><span class="hljs-symbol">324 </span>	compatible = <span class="hljs-string">&quot;fsl,imx6ul-uart&quot;</span>,<br><span class="hljs-symbol">325 </span>		<span class="hljs-string">&quot;fsl,imx6q-uart&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-uart&quot;</span>;<br><span class="hljs-symbol">326 </span>	reg = &lt;<span class="hljs-number">0</span>x02020000 <span class="hljs-number">0</span>x4000&gt;;<br><span class="hljs-symbol">327 </span>	interrupts = &lt;GIC_SPI <span class="hljs-number">26</span> IRQ_TYPE_LEVEL_HIGH&gt;;<br><span class="hljs-symbol">328 </span>	clocks = &lt;&amp;clks IMX6UL_CLK_UART1_IPG&gt;,<br><span class="hljs-symbol">329 </span>		&lt;&amp;clks IMX6UL_CLK_UART1_SERIAL&gt;;<br><span class="hljs-symbol">330 </span>	clock-names = <span class="hljs-string">&quot;ipg&quot;</span>, <span class="hljs-string">&quot;per&quot;</span>;<br><span class="hljs-symbol">331 </span>	status = <span class="hljs-string">&quot;disabled&quot;</span>;<br><span class="hljs-symbol">332 </span>&#125;;<br></code></pre></td></tr></table></figure>

<p>上述代码是节点 uart1， uart1 节点描述了 I.MX6ULL 的 UART1 相关信息，重点是第 326 行的 reg 属性。其中 uart1 的父节点 aips1: aips-bus@02000000 设置了#address-cells &#x3D; &lt;1&gt;、 #sizecells &#x3D; &lt;1&gt;，因此 reg 属性中 address&#x3D;0x02020000， length&#x3D;0x4000。查阅《I.MX6ULL 参考手册》可知， I.MX6ULL 的 UART1 寄存器首地址为 0x02020000，但是 UART1 的地址长度(范围)并没有 0x4000 这么多，这里我们重点是获取 UART1 寄存器首地址。</p>
<h4 id="6、-ranges-属性"><a href="#6、-ranges-属性" class="headerlink" title="6、 ranges 属性"></a>6、 ranges 属性</h4><p>ranges属性值可以为空或者按照(child-bus-address,parent-bus-address,length)格式编写的数字矩阵， ranges 是一个地址映射&#x2F;转换表， ranges 属性每个项目由子地址、父地址和地址空间长度这三部分组成：</p>
<ul>
<li>child-bus-address：子总线地址空间的物理地址，由父节点的#address-cells 确定此物理地址所占用的字长。</li>
<li>parent-bus-address： 父总线地址空间的物理地址，同样由父节点的#address-cells 确定此物理地址所占用的字长。</li>
<li>length： 子地址空间的长度，由父节点的#size-cells 确定此地址长度所占用的字长。如果 ranges 属性值为空值，说明子地址空间和父地址空间完全相同，不需要进行地址转换，对于我们所使用的 I.MX6ULL 来说，子地址空间和父地址空间完全相同，因此会在 imx6ull.dtsi中找到大量的值为空的 ranges 属性，如下所示：</li>
<li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">137</span> soc &#123;<br><span class="hljs-number">138</span> 	<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">139</span> 	<span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">140</span> 	compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<br><span class="hljs-number">141</span> 	interrupt-parent = &lt;&amp;gpc&gt;;<br><span class="hljs-number">142</span> 	ranges;<br>......<br><span class="hljs-number">1177</span> &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>第 142 行定义了 ranges 属性，但是 ranges 属性值为空。<br>ranges 属性不为空的示例代码如下所示：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>soc &#123;<br><span class="hljs-symbol">2 </span>	compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<br><span class="hljs-symbol">3 </span>	#address-cells = &lt;<span class="hljs-number">1</span>&gt;;<br><span class="hljs-symbol">4 </span>	#size-cells = &lt;<span class="hljs-number">1</span>&gt;;<br><span class="hljs-symbol">5 </span>	ranges = &lt;<span class="hljs-number">0</span>x0 <span class="hljs-number">0</span>xe0000000 <span class="hljs-number">0</span>x00100000&gt;;<br><span class="hljs-symbol">6 </span><br><span class="hljs-number">7</span>	serial &#123;<br><span class="hljs-symbol">8 </span>		device_type = <span class="hljs-string">&quot;serial&quot;</span>;<br><span class="hljs-symbol">9 </span>		compatible = <span class="hljs-string">&quot;ns16550&quot;</span>;<br><span class="hljs-symbol">10 </span>		reg = &lt;<span class="hljs-number">0</span>x4600 <span class="hljs-number">0</span>x100&gt;;<br><span class="hljs-symbol">11 </span>		clock-frequency = &lt;<span class="hljs-number">0</span>&gt;;<br><span class="hljs-symbol">12 </span>		interrupts = &lt;<span class="hljs-number">0</span>xA <span class="hljs-number">0</span>x8&gt;;<br><span class="hljs-symbol">13 </span>		interrupt-parent = &lt;&amp;ipic&gt;;<br><span class="hljs-symbol">14 </span>	&#125;;<br><span class="hljs-symbol">15 </span>&#125;;<br></code></pre></td></tr></table></figure>
<p>第 5 行，节点 soc 定义的 ranges 属性，值为&lt;0x0 0xe0000000 0x00100000&gt;，此属性值指定了一个 1024KB(0x00100000)的地址范围，子地址空间的物理起始地址为 0x0，父地址空间的物理起始地址为 0xe0000000。<br>第 10 行， serial 是串口设备节点， reg 属性定义了 serial 设备寄存器的起始地址为 0x4600，寄存器长度为 0x100。经过地址转换， serial 设备可以从 0xe0004600 开始进行读写操作，0xe0004600&#x3D;0x4600+0xe0000000。</p>
<h4 id="7、-name-属性"><a href="#7、-name-属性" class="headerlink" title="7、 name 属性"></a>7、 name 属性</h4><p>name 属性值为字符串， name 属性用于记录节点名字， name 属性已经被弃用，不推荐使用name 属性，一些老的设备树文件可能会使用此属性。</p>
<h4 id="8、-device-type-属性"><a href="#8、-device-type-属性" class="headerlink" title="8、 device_type 属性"></a>8、 device_type 属性</h4><p>device_type 属性值为字符串， IEEE 1275 会用到此属性，用于描述设备的 FCode，但是设备树没有 FCode，所以此属性也被抛弃了。此属性只能用于 cpu 节点或者 memory 节点。imx6ull.dtsi 的 cpu0 节点用到了此属性，内容如下所示：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">54 cpu0: cpu<span class="hljs-meta">@0</span> &#123;<br>55 	compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br>56 	device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br>57 	reg = <span class="hljs-variable">&lt;0&gt;</span>;<br>......<br>89 &#125;;<br></code></pre></td></tr></table></figure>

<h3 id="根节点-compatible-属性"><a href="#根节点-compatible-属性" class="headerlink" title="根节点 compatible 属性"></a>根节点 compatible 属性</h3><p>每个节点都有 compatible 属性，根节点“&#x2F;”也不例外， imx6ull-alientek-emmc.dts 文件中根节点的 compatible 属性内容如下所示：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-number">14</span> / &#123;<br><span class="hljs-number">15</span> 	model = <span class="hljs-string">&quot;Freescale i.MX6 ULL 14x14 EVK Board&quot;</span>;<br><span class="hljs-number">16</span> 	compatible = <span class="hljs-string">&quot;fsl,imx6ull-14x14-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br><span class="hljs-params">...</span><span class="hljs-params">...</span><br><span class="hljs-number">148</span> &#125;<br></code></pre></td></tr></table></figure>

<p>可以看出， compatible 有两个值：“fsl,imx6ull-14x14-evk”和“fsl,imx6ull”。前面我们说了，设备节点的 compatible 属性值是为了匹配 Linux 内核中的驱动程序，那么根节点中的 compatible属性是为了做什么工作的？ 通过根节点的 compatible 属性可以知道我们所使用的设备，一般第一个值描述了所使用的硬件设备名字，比如这里使用的是“imx6ull-14x14-evk”这个设备，第个值描述了设备所使用的 SOC，比如这里使用的是“imx6ull”这颗 SOC。 Linux 内核会通过根节点的 compoatible 属性查看是否支持此设备，如果支持的话设备就会启动 Linux 内核。</p>
<p>接下来我们就来学习一下 Linux 内核在使用设备树前后是如何判断是否支持某款设备的。</p>
<h4 id="1、使用设备树之前设备匹配方法"><a href="#1、使用设备树之前设备匹配方法" class="headerlink" title="1、使用设备树之前设备匹配方法"></a>1、使用设备树之前设备匹配方法</h4><p>在没有使用设备树以前， uboot 会向 Linux 内核传递一个叫做 machine id 的值， machine id 也就是设备 ID，告诉 Linux 内核自己是个什么设备，看看 Linux 内核是否支持。 Linux 内核是支持很多设备的，针对每一个设备(板子)， Linux内核都用MACHINE_START和MACHINE_END来定义一个 machine_desc 结构体来描述这个设备，比如在文件 arch&#x2F;arm&#x2F;mach-imx&#x2F;machmx35_3ds.c 中有如下定义：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">613 </span>MACHINE_START(MX35_3DS, <span class="hljs-string">&quot;Freescale MX35PDK&quot;</span>)<br><span class="hljs-symbol">614 </span>	/* Maintainer: Freescale Semiconductor, Inc */<br><span class="hljs-symbol">615 </span>	.atag_offset = <span class="hljs-number">0</span>x100,<br><span class="hljs-symbol">616 </span>	.map_io = mx35_map_io,<br><span class="hljs-symbol">617 </span>	.init_early = imx35_init_early,<br><span class="hljs-symbol">618 </span>	.init_irq = mx35_init_irq,<br><span class="hljs-symbol">619 </span>	.init_time = mx35pdk_timer_init,<br><span class="hljs-symbol">620 </span>	.init_machine = mx35_3ds_init,<br><span class="hljs-symbol">621 </span>	.reserve = mx35_3ds_reserve,<br><span class="hljs-symbol">622 </span>	.restart = mxc_restart,<br><span class="hljs-symbol">623 </span>MACHINE_END<br></code></pre></td></tr></table></figure>

<p>上述代码就是定义了“ Freescale MX35PDK”这个设备，其中 MACHINE_START 和MACHINE_END 定义在文件 arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;mach&#x2F;arch.h 中，内容如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MACHINE_START(_type,_name) \</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> machine_desc __mach_desc_<span class="hljs-meta">##_type \</span><br>__used \<br>__attribute__((__section__(<span class="hljs-string">&quot;.arch.info.init&quot;</span>))) = &#123; \<br>	.nr = MACH_TYPE_<span class="hljs-meta">##_type, \</span><br>	.name = _name,<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MACHINE_END \</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>根据 MACHINE_START 和 MACHINE_END 的宏定义，将示例代码 43.3.4.2 展开后如下所示：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>static const struct machine_desc __mach_desc_MX35_3DS \<br><span class="hljs-symbol">2 </span>	__used \<br><span class="hljs-symbol">3 </span>	__attribute__((__section__(<span class="hljs-string">&quot;.arch.info.init&quot;</span>))) = &#123;<br><span class="hljs-symbol">4 </span>	.nr = MACH_TYPE_MX35_3DS,<br><span class="hljs-symbol">5 </span>	.<span class="hljs-keyword">name</span> = <span class="hljs-string">&quot;Freescale MX35PDK&quot;</span>,<br><span class="hljs-symbol">6 </span>	/* Maintainer: Freescale Semiconductor, Inc */<br><span class="hljs-symbol">7 </span>	.atag_offset = <span class="hljs-number">0</span>x100,<br><span class="hljs-symbol">8 </span>	.map_io = mx35_map_io,<br><span class="hljs-symbol">9 </span>	.init_early = imx35_init_early,<br><span class="hljs-symbol">10 </span>	.init_irq = mx35_init_irq,<br><span class="hljs-symbol">11 </span>	.init_time = mx35pdk_timer_init,<br><span class="hljs-symbol">12 </span>	.init_machine = mx35_3ds_init,<br><span class="hljs-symbol">13 </span>	.reserve = mx35_3ds_reserve,<br><span class="hljs-symbol">14 </span>	.restart = mxc_restart,<br><span class="hljs-symbol">15 </span>&#125;;<br></code></pre></td></tr></table></figure>

<p>从示例代码 43.3.4.3 中可以看出，这里定义了一个 machine_desc 类型的结构体变量__mach_desc_MX35_3DS ， 这 个 变 量 存 储 在 “ .arch.info.init ” 段 中 。 第 4 行 的MACH_TYPE_MX35_3DS 就 是 “ Freescale MX35PDK ” 这 个 板 子 的 machine id 。MACH_TYPE_MX35_3DS 定义在文件 include&#x2F;generated&#x2F;mach-types.h 中，此文件定义了大量的<br>machine id，内容如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">15</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MACH_TYPE_EBSA110 0</span><br><span class="hljs-number">16</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MACH_TYPE_RISCPC 1</span><br><span class="hljs-number">17</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MACH_TYPE_EBSA285 4</span><br><span class="hljs-number">18</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MACH_TYPE_NETWINDER 5</span><br><span class="hljs-number">19</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MACH_TYPE_CATS 6</span><br><span class="hljs-number">20</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MACH_TYPE_SHARK 15</span><br><span class="hljs-number">21</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MACH_TYPE_BRUTUS 16</span><br><span class="hljs-number">22</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MACH_TYPE_PERSONAL_SERVER 17</span><br>......<br><span class="hljs-number">287</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MACH_TYPE_MX35_3DS 1645</span><br>......<br><span class="hljs-number">1000</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MACH_TYPE_PFLA03 4575</span><br></code></pre></td></tr></table></figure>
<p>第 287 行就是 MACH_TYPE_MX35_3DS 的值，为 1645。前面说了， uboot 会给 Linux 内核传递 machine id 这个参数， Linux 内核会检查这个 machineid，其实就是将 machine id 与示例代码 43.3.4.3 中的这些 MACH_TYPE_XXX 宏进行对比，看看有没有相等的，如果相等的话就表示 Linux 内核支持这个设备，如果不支持的话那么这个设<br>备就没法启动 Linux 内核。</p>
<h4 id="2、使用设备树以后的设备匹配方法"><a href="#2、使用设备树以后的设备匹配方法" class="headerlink" title="2、使用设备树以后的设备匹配方法"></a>2、使用设备树以后的设备匹配方法</h4><p>当 Linux 内 核 引 入 设 备 树 以 后 就 不 再 使 用 MACHINE_START 了 ， 而 是 换 为 了DT_MACHINE_START。 DT_MACHINE_START 也定义在文件 arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;mach&#x2F;arch.h里面，定义如下：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">#define DT_MACHINE_START(_name, _namestr) \</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> struct machine_desc __mach_desc_<span class="hljs-comment">##_name \</span><br>__used <span class="hljs-string">\</span><br>__attribute__((__section__(<span class="hljs-string">&quot;.arch.info.init&quot;</span>))) = &#123; <span class="hljs-string">\</span><br>	.nr = ~<span class="hljs-number">0</span>, <span class="hljs-string">\</span><br>	.name = _namestr,<br></code></pre></td></tr></table></figure>

<p>可以看出， DT_MACHINE_START 和 MACHINE_START 基本相同，只是.nr 的设置不同，在 DT_MACHINE_START 里面直接将.nr 设置为~0。说明引入设备树以后不会再根据 machine id 来检查 Linux 内核是否支持某个设备了。<br>打开文件 arch&#x2F;arm&#x2F;mach-imx&#x2F;mach-imx6ul.c，有如下所示内容：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">208 </span>static const char *imx6ul_dt_compat[] __initconst = &#123;<br><span class="hljs-symbol">209 </span>	<span class="hljs-string">&quot;fsl,imx6ul&quot;</span>,<br><span class="hljs-symbol">210 </span>	<span class="hljs-string">&quot;fsl,imx6ull&quot;</span>,<br><span class="hljs-symbol">211 </span>	NULL,<br><span class="hljs-symbol">212 </span>&#125;;<br><span class="hljs-number">213</span><br><span class="hljs-symbol">214 </span>DT_MACHINE_START(IMX6UL, <span class="hljs-string">&quot;Freescale i.MX6 Ultralite (Device Tree)&quot;</span>)<br><span class="hljs-symbol">215 </span>	.map_io = imx6ul_map_io,<br><span class="hljs-symbol">216 </span>	.init_irq = imx6ul_init_irq,<br><span class="hljs-symbol">217 </span>	.init_machine = imx6ul_init_machine,<br><span class="hljs-symbol">218 </span>	.init_late = imx6ul_init_late,<br><span class="hljs-symbol">219 </span>	.dt_compat = imx6ul_dt_compat,<br><span class="hljs-symbol">220 </span>MACHINE_END<br></code></pre></td></tr></table></figure>

<p>machine_desc 结构体中有个.dt_compat 成员变量，此成员变量保存着本设备兼容属性，示例代码 43.3.4.5 中设置.dt_compat &#x3D; imx6ul_dt_compat， imx6ul_dt_compat 表里面有”fsl,imx6ul”和”fsl,imx6ull”这两个兼容值。只要某个设备(板子)根节点“ &#x2F;”的 compatible 属性值与imx6ul_dt_compat 表中的任何一个值相等，那么就表示 Linux 内核支持此设备。 imx6ull-alientekemmc.dts 中根节点的 compatible 属性值如下：<br><code>compatible = &quot;fsl,imx6ull-14x14-evk&quot;, &quot;fsl,imx6ull&quot;;</code><br>其中“fsl,imx6ull”与 imx6ul_dt_compat 中的“fsl,imx6ull”匹配，因此 I.MX6U-ALPHA 开<br>发板可以正常启动 Linux 内核。如果将 imx6ull-alientek-emmc.dts 根节点的 compatible 属性改为其他的值，比如：<br><code>compatible = &quot;fsl,imx6ull-14x14-evk&quot;, &quot;fsl,imx6ullll&quot;</code><br>重新编译 DTS，并用新的 DTS 启动 Linux 内核，结果如图 43.3.4.1 所示的错误提示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658632385165.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>当我们修改了根节点 compatible 属性内容以后，因为 Linux 内核找不到对应的设备，因此Linux 内核无法启动。在 uboot 输出 Starting kernel…以后就再也没有其他信息输出了。<br>接下来我们简单看一下 Linux 内核是如何根据设备树根节点的 compatible 属性来匹配出对应的 machine_desc， Linux 内核调用 start_kernel 函数来启动内核， start_kernel 函数会调用setup_arch 函数来匹配 machine_desc， setup_arch 函数定义在文件 arch&#x2F;arm&#x2F;kernel&#x2F;setup.c 中，函数内容如下(有缩减)：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-number">913</span> <span class="hljs-keyword">void</span> __<span class="hljs-function"><span class="hljs-keyword">init</span> <span class="hljs-title">setup_arch</span>(<span class="hljs-params"><span class="hljs-built_in">char</span> **cmdline_p</span>)</span><br><span class="hljs-function">914</span> &#123;<br><span class="hljs-number">915</span> 	<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> machine_desc *mdesc;<br><span class="hljs-number">916</span><br><span class="hljs-number">917</span> 	setup_processor();<br><span class="hljs-number">918</span> 	mdesc = setup_machine_fdt(__atags_pointer);<br><span class="hljs-number">919</span>	 	<span class="hljs-keyword">if</span> (!mdesc)<br><span class="hljs-number">920</span> 		mdesc = setup_machine_tags(__atags_pointer,<br>										__machine_arch_type);<br><span class="hljs-number">921</span> 	machine_desc = mdesc;<br><span class="hljs-number">922</span> 	machine_name = mdesc-&gt;name;<br>......<br><span class="hljs-number">986</span> &#125;<br></code></pre></td></tr></table></figure>

<p>第 918 行，调用 setup_machine_fdt 函数来获取匹配的 machine_desc，参数就是 atags 的首地址，也就是 uboot 传递给 Linux 内核的 dtb 文件首地址， setup_machine_fdt 函数的返回值就是找到的最匹配的 machine_desc。函数 setup_machine_fdt 定义在文件 arch&#x2F;arm&#x2F;kernel&#x2F;devtree.c 中，内容如下(有缩减)：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">204</span> const <span class="hljs-keyword">struct</span> machine_desc<span class="hljs-operator"> * </span>__init setup<span class="hljs-constructor">_machine_fdt(<span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">dt_phys</span>)</span><br><span class="hljs-number">205</span> &#123;<br><span class="hljs-number">206</span> 	const <span class="hljs-keyword">struct</span> machine_desc *mdesc, *mdesc_best = NULL;<br>......<br><span class="hljs-number">214</span><br><span class="hljs-number">215</span> 	<span class="hljs-keyword">if</span> (!dt_phys<span class="hljs-operator"> || </span>!early<span class="hljs-constructor">_init_dt_verify(<span class="hljs-params">phys_to_virt</span>(<span class="hljs-params">dt_phys</span>)</span>))<br><span class="hljs-number">216</span> 		return NULL;<br><span class="hljs-number">217</span><br><span class="hljs-number">218</span> 	mdesc = <span class="hljs-keyword">of</span><span class="hljs-constructor">_flat_dt_match_machine(<span class="hljs-params">mdesc_best</span>, <span class="hljs-params">arch_get_next_mach</span>)</span>;<br><span class="hljs-number">219</span><br>......<br><span class="hljs-number">247</span> 	__machine_arch_type = mdesc-&gt;nr;<br><span class="hljs-number">248</span><br><span class="hljs-number">249</span> 	return mdesc;<br><span class="hljs-number">250</span> &#125;<br></code></pre></td></tr></table></figure>

<p>第 218 行，调用函数 of_flat_dt_match_machine 来获取匹配的 machine_desc，参数 mdesc_best是 默 认 的 machine_desc ， 参 数 arch_get_next_mach 是 个 函 数 ， 此 函 数定 义 在arch&#x2F;arm&#x2F;kernel&#x2F;devtree.c 文件中。找到匹配的 machine_desc 的过程就是用设备树根节点的compatible 属性值和 Linux 内核中 machine_desc 下.dt_compat 的值比较，看看那个相等，如果相等的话就表示找到匹配的 machine_desc， arch_get_next_mach 函数的工作就是获取 Linux 内核中下一个 machine_desc 结构体。</p>
<p>最后再来看一下 of_flat_dt_match_machine 函数，此函数定义在文件 drivers&#x2F;of&#x2F;fdt.c 中，内容如下(有缩减)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">705</span> <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">void</span> * __init <span class="hljs-title">of_flat_dt_match_machine</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *default_match, <span class="hljs-type">const</span> <span class="hljs-type">void</span> * (*get_next_compat)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span>**))</span></span><br><span class="hljs-function">707 </span>&#123;<br><span class="hljs-number">708</span> 	<span class="hljs-type">const</span> <span class="hljs-type">void</span> *data = <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">709</span> 	<span class="hljs-type">const</span> <span class="hljs-type">void</span> *best_data = default_match;<br><span class="hljs-number">710</span> 	<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> *compat;<br><span class="hljs-number">711</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> dt_root;<br><span class="hljs-number">712</span> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> best_score = ~<span class="hljs-number">1</span>, score = <span class="hljs-number">0</span>;<br><span class="hljs-number">713</span><br><span class="hljs-number">714</span> 	dt_root = <span class="hljs-built_in">of_get_flat_dt_root</span>();<br><span class="hljs-number">715</span> 	<span class="hljs-keyword">while</span> ((data = <span class="hljs-built_in">get_next_compat</span>(&amp;compat))) &#123;<br><span class="hljs-number">716</span> 		score = <span class="hljs-built_in">of_flat_dt_match</span>(dt_root, compat);<br><span class="hljs-number">717</span> 		<span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">0</span> &amp;&amp; score &lt; best_score) &#123;<br><span class="hljs-number">718</span> 			best_data = data;<br><span class="hljs-number">719</span> 			best_score = score;<br><span class="hljs-number">720</span> 		&#125;<br><span class="hljs-number">721</span> &#125;<br>......<br><span class="hljs-number">739</span><br><span class="hljs-number">740</span> <span class="hljs-built_in">pr_info</span>(<span class="hljs-string">&quot;Machine model: %s\n&quot;</span>, <span class="hljs-built_in">of_flat_dt_get_machine_name</span>());<br><span class="hljs-number">741</span><br><span class="hljs-number">742</span> <span class="hljs-keyword">return</span> best_data;<br><span class="hljs-number">743</span> &#125;<br></code></pre></td></tr></table></figure>

<p>第 714 行，通过函数 of_get_flat_dt_root 获取设备树根节点。<br>第 715~720 行，此循环就是查找匹配的 machine_desc 过程，第 716 行的 of_flat_dt_match 函数会将根节点 compatible 属性的值和每个 machine_desc 结构体中. dt_compat 的值进行比较，直至找到匹配的那个 machine_desc。<br>总结一下， Linux 内核通过根节点 compatible 属性找到对应的设备的函数调用过程，如图43.3.4.2 所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658632543641.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<h3 id="向节点追加或修改内容"><a href="#向节点追加或修改内容" class="headerlink" title="向节点追加或修改内容"></a>向节点追加或修改内容</h3><p>产品开发过程中可能面临着频繁的需求更改，比如第一版硬件上有一个 IIC 接口的六轴芯片 MPU6050，第二版硬件又要把这个 MPU6050 更换为 MPU9250 等。一旦硬件修改了，我们就要同步的修改设备树文件，毕竟设备树是描述板子硬件信息的文件。假设现在有个六轴芯片fxls8471， fxls8471 要接到 I.MX6U-ALPHA 开发板的 I2C1 接口上，那么相当于需要在 i2c1 这个节点上添加一个 fxls8471 子节点。先看一下 I2C1 接口对应的节点，打开文件 imx6ull.dtsi 文件，找到如下所示内容：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">937 </span>i2c1: i2c@<span class="hljs-number">021</span>a0000 &#123;<br><span class="hljs-symbol">938 </span>	#address-cells = &lt;<span class="hljs-number">1</span>&gt;;<br><span class="hljs-symbol">939 </span>	#size-cells = &lt;<span class="hljs-number">0</span>&gt;;<br><span class="hljs-symbol">940 </span>	compatible = <span class="hljs-string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;<br><span class="hljs-symbol">941 </span>	reg = &lt;<span class="hljs-number">0</span>x021a0000 <span class="hljs-number">0</span>x4000&gt;;<br><span class="hljs-symbol">942 </span>	interrupts = &lt;GIC_SPI <span class="hljs-number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;<br><span class="hljs-symbol">943 </span>	clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;<br><span class="hljs-symbol">944 </span>	status = <span class="hljs-string">&quot;disabled&quot;</span>;<br><span class="hljs-symbol">945 </span>&#125;;<br></code></pre></td></tr></table></figure>
<p>示例代码 43.3.5.1 就是 I.MX6ULL 的 I2C1 节点，现在要在 i2c1 节点下创建一个子节点，这个子节点就是 fxls8471，最简单的方法就是在 i2c1 下直接添加一个名为 fxls8471 的子节点，如下所示：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">937 </span>i2c1: i2c@<span class="hljs-number">021</span>a0000 &#123;<br><span class="hljs-symbol">938 </span>	#address-cells = &lt;<span class="hljs-number">1</span>&gt;;<br><span class="hljs-symbol">939 </span>	#size-cells = &lt;<span class="hljs-number">0</span>&gt;;<br><span class="hljs-symbol">940 </span>	compatible = <span class="hljs-string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;<br><span class="hljs-symbol">941 </span>	reg = &lt;<span class="hljs-number">0</span>x021a0000 <span class="hljs-number">0</span>x4000&gt;;<br><span class="hljs-symbol">942 </span>	interrupts = &lt;GIC_SPI <span class="hljs-number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;<br><span class="hljs-symbol">943 </span>	clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;<br><span class="hljs-symbol">944 </span>	status = <span class="hljs-string">&quot;disabled&quot;</span>;<br><span class="hljs-number">945</span><br><span class="hljs-symbol">946 </span>	//fxls8471 子节点<br><span class="hljs-symbol">947 </span>	fxls8471@<span class="hljs-number">1</span>e &#123;<br><span class="hljs-symbol">948 </span>		compatible = <span class="hljs-string">&quot;fsl,fxls8471&quot;</span>;<br><span class="hljs-symbol">949 </span>		reg = &lt;<span class="hljs-number">0</span>x1e&gt;;<br><span class="hljs-symbol">950 </span>	&#125;;<br><span class="hljs-symbol">951 </span>&#125;;<br></code></pre></td></tr></table></figure>

<p>第 947~950 行就是添加的 fxls8471 这个芯片对应的子节点。但是这样会有个问题！ i2c1 节点是定义在 imx6ull.dtsi 文件中的，而 imx6ull.dtsi 是设备树头文件，其他所有使用到 I.MX6ULL这颗 SOC 的板子都会引用 imx6ull.dtsi 这个文件。直接在 i2c1 节点中添加 fxls8471 就相当于在其他的所有板子上都添加了 fxls8471 这个设备，但是其他的板子并没有这个设备啊！因此，按照示例代码 43.3.5.2 这样写肯定是不行的。</p>
<p>这里就要引入另外一个内容，那就是如何向节点追加数据，我们现在要解决的就是如何向i2c1 节点追加一个名为 fxls8471 的子节点，而且不能影响到其他使用到 I.MX6ULL 的板子。I.MX6U-ALPHA 开发板使用的设备树文件为 imx6ull-alientek-emmc.dts，因此我们需要在imx6ull-alientek-emmc.dts 文件中完成数据追加的内容，方式如下：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&amp;i2c1 &#123;<br><span class="hljs-symbol">2 </span>/* 要追加或修改的内容 */<br><span class="hljs-symbol">3 </span>&#125;;<br></code></pre></td></tr></table></figure>

<p>第 1 行， &amp;i2c1 表示要访问 i2c1 这个 label 所对应的节点，也就是 imx6ull.dtsi 中的“i2c1:i2c@021a0000”。<br>第 2 行，花括号内就是要向 i2c1 这个节点添加的内容，包括修改某些属性的值。<br>打开 imx6ull-alientek-emmc.dts，找到如下所示内容：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">224 </span>&amp;i2c1 &#123;<br><span class="hljs-symbol">225 </span>	clock-frequency = &lt;<span class="hljs-number">100000</span>&gt;;<br><span class="hljs-symbol">226 </span>	pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<br><span class="hljs-symbol">227 </span>	pinctrl-<span class="hljs-number">0</span> = &lt;&amp;pinctrl_i2c1&gt;;<br><span class="hljs-symbol">228 </span>	status = <span class="hljs-string">&quot;okay&quot;</span>;<br><span class="hljs-number">229</span><br><span class="hljs-symbol">230 </span>	mag3110@<span class="hljs-number">0</span>e &#123;<br><span class="hljs-symbol">231 </span>		compatible = <span class="hljs-string">&quot;fsl,mag3110&quot;</span>;<br><span class="hljs-symbol">232 </span>		reg = &lt;<span class="hljs-number">0</span>x0e&gt;;<br><span class="hljs-symbol">233 </span>		position = &lt;<span class="hljs-number">2</span>&gt;;<br><span class="hljs-symbol">234 </span>	&#125;;<br><span class="hljs-number">235</span><br><span class="hljs-symbol">236 </span>	fxls8471@<span class="hljs-number">1</span>e &#123;<br><span class="hljs-symbol">237 </span>		compatible = <span class="hljs-string">&quot;fsl,fxls8471&quot;</span>;<br><span class="hljs-symbol">238 </span>		reg = &lt;<span class="hljs-number">0</span>x1e&gt;;<br><span class="hljs-symbol">239 </span>		position = &lt;<span class="hljs-number">0</span>&gt;;<br><span class="hljs-symbol">240 </span>		interrupt-parent = &lt;&amp;gpio5&gt;;<br><span class="hljs-symbol">241 </span>		interrupts = &lt;<span class="hljs-number">0</span> <span class="hljs-number">8</span>&gt;;<br><span class="hljs-symbol">242 </span>	&#125;;<br><span class="hljs-symbol">243 </span>&#125;;<br></code></pre></td></tr></table></figure>

<p>示例代码 43.3.5.4 就是向 i2c1 节点添加&#x2F;修改数据，比如第 225 行的属性“clock-frequency”就表示 i2c1 时钟为 100KHz。“clock-frequency”就是新添加的属性。<br>第 228 行，将 status 属性的值由原来的 disabled 改为 okay。<br>第 230<del>234 行， i2c1 子节点 mag3110，因为 NXP 官方开发板在 I2C1 上接了一个磁力计芯片 mag3110，正点原子的 I.MX6U-ALPHA 开发板并没有使用 mag3110。<br>第 236</del>242 行， i2c1 子节点 fxls8471，同样是因为 NXP 官方开发板在 I2C1 上接了 fxls8471这颗六轴芯片。<br>因为示例代码 43.3.5.4 中的内容是 imx6ull-alientek-emmc.dts 这个文件内的，所以不会对使用 I.MX6ULL 这颗 SOC 的其他板子造成任何影响。这个就是向节点追加或修改内容，重点就是通过&amp;label 来访问节点，然后直接在里面编写要追加或者修改的内容。</p>
<h2 id="创建小型模板设备树"><a href="#创建小型模板设备树" class="headerlink" title="创建小型模板设备树"></a>创建小型模板设备树</h2><p>上一节已经对 DTS 的语法做了比较详细的讲解，本节我们就根据前面讲解的语法，从头到尾编写一个小型的设备树文件。当然了，这个小型设备树没有实际的意义，做这个的目的是为了掌握设备树的语法。在实际产品开发中，我们是不需要完完全全的重写一个.dts 设备树文件，一般都是使用 SOC 厂商提供好的.dts 文件，我们只需要在上面根据自己的实际情况做相应的修改即可。在编写设备树之前要先定义一个设备，我们就以 I.MX6ULL 这个 SOC 为例，我们需要<br>在设备树里面描述的内容如下：</p>
<ul>
<li>①、 I.MX6ULL 这个 Cortex-A7 架构的 32 位 CPU。</li>
<li>②、 I.MX6ULL 内部 ocram，起始地址 0x00900000，大小为 128KB(0x20000)。</li>
<li>③、 I.MX6ULL 内部 aips1 域下的 ecspi1 外设控制器，寄存器起始地址为 0x02008000，大小为 0x4000。</li>
<li>④、 I.MX6ULL 内部 aips2 域下的 usbotg1 外设控制器，寄存器起始地址为 0x02184000，大小为 0x4000。</li>
<li>⑤、 I.MX6ULL 内部 aips3 域下的 rngb 外设控制器，寄存器起始地址为 0x02284000，大小为 0x4000。</li>
</ul>
<p>为了简单起见，我们就在设备树里面就实现这些内容即可，首先，搭建一个仅含有根节点“&#x2F;”的基础的框架，新建一个名为 myfirst.dts 文件，在里面输入如下所示内容：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>/ &#123;<br><span class="hljs-symbol">2 </span>	compatible = <span class="hljs-string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br><span class="hljs-symbol">3 </span>&#125;<br></code></pre></td></tr></table></figure>

<p>设备树框架很简单，就一个根节点“&#x2F;”，根节点里面只有一个 compatible 属性。我们就在这个基础框架上面将上面列出的内容一点点添加进来。</p>
<h3 id="1、添加-cpus-节点"><a href="#1、添加-cpus-节点" class="headerlink" title="1、添加 cpus 节点"></a>1、添加 cpus 节点</h3><p>首先添加 CPU 节点， I.MX6ULL 采用 Cortex-A7 架构，而且只有一个 CPU，因此只有一个cpu0 节点，完成以后如下所示：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>/ &#123;<br><span class="hljs-symbol">2 </span>	compatible = <span class="hljs-string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span>	cpus &#123;<br><span class="hljs-symbol">5 </span>		#address-cells = &lt;<span class="hljs-number">1</span>&gt;;<br><span class="hljs-symbol">6 </span>		#size-cells = &lt;<span class="hljs-number">0</span>&gt;;<br><span class="hljs-symbol">7 </span><br><span class="hljs-number">8</span>		//CPU0 节点<br><span class="hljs-symbol">9 </span>		cpu0: cpu@<span class="hljs-number">0</span> &#123;<br><span class="hljs-symbol">10 </span>			compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br><span class="hljs-symbol">11 </span>			device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br><span class="hljs-symbol">12 </span>			reg = &lt;<span class="hljs-number">0</span>&gt;;<br><span class="hljs-symbol">13 </span>		&#125;;<br><span class="hljs-symbol">14 </span>	&#125;;<br><span class="hljs-symbol">15 </span>&#125;<br></code></pre></td></tr></table></figure>

<p>第 4~14 行， cpus 节点，此节点用于描述 SOC 内部的所有 CPU，因为 I.MX6ULL 只有一个CPU，因此只有一个 cpu0 子节点。</p>
<h3 id="2、添加-soc-节点"><a href="#2、添加-soc-节点" class="headerlink" title="2、添加 soc 节点"></a>2、添加 soc 节点</h3><p>像 uart， iic 控制器等等这些都属于 SOC 内部外设，因此一般会创建一个叫做 soc 的父节点来管理这些 SOC 内部外设的子节点，添加 soc 节点以后的 myfirst.dts 文件内容如下所示：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>/ &#123;<br><span class="hljs-symbol">2 </span>	compatible = <span class="hljs-string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br><span class="hljs-symbol">3 </span><br><span class="hljs-number">4</span>	cpus &#123;<br><span class="hljs-symbol">5 </span>		#address-cells = &lt;<span class="hljs-number">1</span>&gt;;<br><span class="hljs-symbol">6 </span>		#size-cells = &lt;<span class="hljs-number">0</span>&gt;;<br><span class="hljs-symbol">7 </span><br><span class="hljs-number">8</span>		//CPU0 节点<br><span class="hljs-symbol">9 </span>		cpu0: cpu@<span class="hljs-number">0</span> &#123;<br><span class="hljs-symbol">10 </span>			compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br><span class="hljs-symbol">11 </span>			device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br><span class="hljs-symbol">12 </span>			reg = &lt;<span class="hljs-number">0</span>&gt;;<br><span class="hljs-symbol">13 </span>		&#125;;<br><span class="hljs-symbol">14 </span>	&#125;;<br><span class="hljs-number">15</span><br><span class="hljs-symbol">16 </span>	//soc 节点<br><span class="hljs-symbol">17 </span>	soc &#123;<br><span class="hljs-symbol">18 </span>		#address-cells = &lt;<span class="hljs-number">1</span>&gt;;<br><span class="hljs-symbol">19 </span>		#size-cells = &lt;<span class="hljs-number">1</span>&gt;;<br><span class="hljs-symbol">20 </span>		compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<br><span class="hljs-symbol">21 </span>		ranges;<br><span class="hljs-symbol">22 </span>	&#125;<br><span class="hljs-symbol">23 </span>&#125;<br></code></pre></td></tr></table></figure>
<p>第 17~22 行， soc 节点， soc 节点设置#address-cells &#x3D; &lt;1&gt;， #size-cells &#x3D; &lt;1&gt;，这样 soc 子节点的 reg 属性中起始地占用一个字长，地址空间长度也占用一个字长。<br>第 21 行， ranges 属性， rangeWs 属性为空，说明子空间和父空间地址范围相同。</p>
<h3 id="3、添加-ocram-节点"><a href="#3、添加-ocram-节点" class="headerlink" title="3、添加 ocram 节点"></a>3、添加 ocram 节点</h3><p>根据第②点的要求，添加 ocram 节点， ocram 是 I.MX6ULL 内部 RAM，因此 ocram 节点应该是 soc 节点的子节点。 ocram 起始地址为 0x00900000，大小为 128KB(0x20000)，添加 ocram节点以后 myfirst.dts 文件内容如下所示：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>/ &#123;<br><span class="hljs-symbol">2 </span>		compatible = <span class="hljs-string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br><span class="hljs-symbol">3 </span><br><span class="hljs-number">4</span>		cpus &#123;<br><span class="hljs-symbol">5 </span>			#address-cells = &lt;<span class="hljs-number">1</span>&gt;;<br><span class="hljs-symbol">6 </span>			#size-cells = &lt;<span class="hljs-number">0</span>&gt;;<br><span class="hljs-symbol">7 </span><br><span class="hljs-number">8</span>			//CPU0 节点<br><span class="hljs-symbol">9 </span>			cpu0: cpu@<span class="hljs-number">0</span> &#123;<br><span class="hljs-symbol">10 </span>				compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br><span class="hljs-symbol">11 </span>				device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br><span class="hljs-symbol">12 </span>				reg = &lt;<span class="hljs-number">0</span>&gt;;<br><span class="hljs-symbol">13 </span>			&#125;;<br><span class="hljs-symbol">14 </span>		&#125;;<br><span class="hljs-number">15</span><br><span class="hljs-symbol">16 </span>		//soc 节点<br><span class="hljs-symbol">17 </span>		soc &#123;<br><span class="hljs-symbol">18 </span>			#address-cells = &lt;<span class="hljs-number">1</span>&gt;;<br><span class="hljs-symbol">19 </span>			#size-cells = &lt;<span class="hljs-number">1</span>&gt;;<br><span class="hljs-symbol">20 </span>			compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<br><span class="hljs-symbol">21 </span>			ranges;<br><span class="hljs-number">22</span><br><span class="hljs-symbol">23 </span>			//ocram 节点<br><span class="hljs-symbol">24 </span>			ocram: sram@<span class="hljs-number">00900000</span> &#123;<br><span class="hljs-symbol">25 </span>				compatible = <span class="hljs-string">&quot;fsl,lpm-sram&quot;</span>;<br><span class="hljs-symbol">26 </span>				reg = &lt;<span class="hljs-number">0</span>x00900000 <span class="hljs-number">0</span>x20000&gt;;<br><span class="hljs-symbol">27 </span>			&#125;;<br><span class="hljs-symbol">28 </span>		&#125;<br><span class="hljs-symbol">29 </span>&#125;<br></code></pre></td></tr></table></figure>

<p>第 24~27 行， ocram 节点，第 24 行节点名字@后面的 0x00900000 就是 ocram 的起始地址。<br>第 26 行的 reg 属性也指明了 ocram 内存的起始地址为 0x00900000，大小为 0x20000。</p>
<h3 id="4、添加-aips1、-aips2-和-aips3-这三个子节点"><a href="#4、添加-aips1、-aips2-和-aips3-这三个子节点" class="headerlink" title="4、添加 aips1、 aips2 和 aips3 这三个子节点"></a>4、添加 aips1、 aips2 和 aips3 这三个子节点</h3><p>I.MX6ULL 内部分为三个域： aips1<del>3，这三个域分管不同的外设控制器， aips1</del>3 这三个域对应的内存范围如表 43.4.1 所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658632984260.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>我们先在设备树中添加这三个域对应的子节点。aips1~3 这三个域都属于 soc 节点的子节点，完成以后的 myfirst.dts 文件内容如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span> / &#123;<br><span class="hljs-number">2</span> compatible = <span class="hljs-string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br>cpus &#123;<br><span class="hljs-number">5</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">6</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br><span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-comment">//CPU0 节点</span><br><span class="hljs-number">9</span> cpu0: cpu@<span class="hljs-number">0</span> &#123;<br><span class="hljs-number">10</span> compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br><span class="hljs-number">11</span> device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br><span class="hljs-number">12</span> reg = &lt;<span class="hljs-number">0</span>&gt;;<br><span class="hljs-number">13</span> &#125;;<br><span class="hljs-number">14</span> &#125;;<br><span class="hljs-number">15</span><br><span class="hljs-number">16</span> <span class="hljs-comment">//soc 节点</span><br><span class="hljs-number">17</span> soc &#123;<br><span class="hljs-number">18</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">19</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">20</span> compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<br><span class="hljs-number">21</span> ranges;<br><span class="hljs-number">22</span><br><span class="hljs-number">23</span> <span class="hljs-comment">//ocram 节点</span><br><span class="hljs-number">24</span> ocram: sram@<span class="hljs-number">00900000</span> &#123;<br><span class="hljs-number">25</span> compatible = <span class="hljs-string">&quot;fsl,lpm-sram&quot;</span>;<br><span class="hljs-number">26</span> reg = &lt;<span class="hljs-number">0x00900000</span> <span class="hljs-number">0x20000</span>&gt;;<br><span class="hljs-number">27</span> &#125;;<br><span class="hljs-number">28</span><br><span class="hljs-number">29</span> <span class="hljs-comment">//aips1 节点</span><br><span class="hljs-number">30</span> aips1: aips-bus@<span class="hljs-number">02000000</span> &#123;<br><span class="hljs-number">31</span> compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br><span class="hljs-number">32</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">33</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">34</span> reg = &lt;<span class="hljs-number">0x02000000</span> <span class="hljs-number">0x100000</span>&gt;;<br><span class="hljs-number">35</span> ranges;<br><span class="hljs-number">36</span> &#125;<br><span class="hljs-number">37</span><br><span class="hljs-number">38</span> <span class="hljs-comment">//aips2 节点</span><br><span class="hljs-number">39</span> aips2: aips-bus@<span class="hljs-number">02100000</span> &#123;<br><span class="hljs-number">40</span> compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br><span class="hljs-number">41</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">42</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">43</span> reg = &lt;<span class="hljs-number">0x02100000</span> <span class="hljs-number">0x100000</span>&gt;;<br><span class="hljs-number">44</span> ranges;<br><span class="hljs-number">45</span> &#125;<br><span class="hljs-number">46</span><br><span class="hljs-number">47</span> <span class="hljs-comment">//aips3 节点</span><br><span class="hljs-number">48</span> aips3: aips-bus@<span class="hljs-number">02200000</span> &#123;<br><span class="hljs-number">49</span> compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br><span class="hljs-number">50</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">51</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">52</span> reg = &lt;<span class="hljs-number">0x02200000</span> <span class="hljs-number">0x100000</span>&gt;;<br><span class="hljs-number">53</span> ranges;<br><span class="hljs-number">54</span> &#125;<br><span class="hljs-number">55</span> &#125;<br><span class="hljs-number">56</span> &#125;<br></code></pre></td></tr></table></figure>

<p>第 30<del>36 行， aips1 节点。<br>第 39</del>45 行， aips2 节点。<br>第 48~54 行， aips3 节点。</p>
<h3 id="5、添加-ecspi1、-usbotg1-和-rngb-这三个外设控制器节点"><a href="#5、添加-ecspi1、-usbotg1-和-rngb-这三个外设控制器节点" class="headerlink" title="5、添加 ecspi1、 usbotg1 和 rngb 这三个外设控制器节点"></a>5、添加 ecspi1、 usbotg1 和 rngb 这三个外设控制器节点</h3><p>最后我们在 myfirst.dts 文件中加入 ecspi1， usbotg1 和 rngb 这三个外设控制器对应的节点，其中 ecspi1 属于 aips1 的子节点， usbotg1 属于 aips2 的子节点， rngb 属于 aips3 的子节点。最终的 myfirst.dts 文件内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span> / &#123;<br><span class="hljs-number">2</span> compatible = <span class="hljs-string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br>cpus &#123;<br><span class="hljs-number">5</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">6</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br><span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-comment">//CPU0 节点</span><br><span class="hljs-number">9</span> cpu0: cpu@<span class="hljs-number">0</span> &#123;<br><span class="hljs-number">10</span> compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br><span class="hljs-number">11</span> device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br><span class="hljs-number">12</span> reg = &lt;<span class="hljs-number">0</span>&gt;;<br><span class="hljs-number">13</span> &#125;;<br><span class="hljs-number">14</span> &#125;;<br><span class="hljs-number">15</span><br><span class="hljs-number">16</span> <span class="hljs-comment">//soc 节点</span><br><span class="hljs-number">17</span> soc &#123;<br><span class="hljs-number">18</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">19</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">20</span> compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<br><span class="hljs-number">21</span> ranges;<br><span class="hljs-number">22</span><br><span class="hljs-number">23</span> <span class="hljs-comment">//ocram 节点</span><br><span class="hljs-number">24</span> ocram: sram@<span class="hljs-number">00900000</span> &#123;<br><span class="hljs-number">25</span> compatible = <span class="hljs-string">&quot;fsl,lpm-sram&quot;</span>;<br><span class="hljs-number">26</span> reg = &lt;<span class="hljs-number">0x00900000</span> <span class="hljs-number">0x20000</span>&gt;;<br><span class="hljs-number">27</span> &#125;;<br><span class="hljs-number">28</span><br><span class="hljs-number">29</span> <span class="hljs-comment">//aips1 节点</span><br><span class="hljs-number">30</span> aips1: aips-bus@<span class="hljs-number">02000000</span> &#123;<br><span class="hljs-number">31</span> compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br><span class="hljs-number">32</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">33</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">34</span> reg = &lt;<span class="hljs-number">0x02000000</span> <span class="hljs-number">0x100000</span>&gt;;<br><span class="hljs-number">35</span> ranges;<br><span class="hljs-number">36</span><br><span class="hljs-number">37</span> <span class="hljs-comment">//ecspi1 节点</span><br><span class="hljs-number">38</span> ecspi1: ecspi@<span class="hljs-number">02008000</span> &#123;<br><span class="hljs-number">39</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">40</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br><span class="hljs-number">41</span> compatible = <span class="hljs-string">&quot;fsl,imx6ul-ecspi&quot;</span>, <span class="hljs-string">&quot;fsl,imx51-ecspi&quot;</span>;<br><span class="hljs-number">42</span> reg = &lt;<span class="hljs-number">0x02008000</span> <span class="hljs-number">0x4000</span>&gt;;<br><span class="hljs-number">43</span> status = <span class="hljs-string">&quot;disabled&quot;</span>;<br><span class="hljs-number">44</span> &#125;;<br><span class="hljs-number">45</span> &#125;<br><span class="hljs-number">46</span><br><span class="hljs-number">47</span> <span class="hljs-comment">//aips2 节点</span><br><span class="hljs-number">48</span> aips2: aips-bus@<span class="hljs-number">02100000</span> &#123;<br><span class="hljs-number">49</span> compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br><span class="hljs-number">50</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">51</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">52</span> reg = &lt;<span class="hljs-number">0x02100000</span> <span class="hljs-number">0x100000</span>&gt;;<br><span class="hljs-number">53</span> ranges;<br><span class="hljs-number">54</span><br><span class="hljs-number">55</span> <span class="hljs-comment">//usbotg1 节点</span><br><span class="hljs-number">56</span> usbotg1: usb@<span class="hljs-number">02184000</span> &#123;<br><span class="hljs-number">57</span> compatible = <span class="hljs-string">&quot;fsl,imx6ul-usb&quot;</span>, <span class="hljs-string">&quot;fsl,imx27-usb&quot;</span>;<br><span class="hljs-number">58</span> reg = &lt;<span class="hljs-number">0x02184000</span> <span class="hljs-number">0x4000</span>&gt;;<br><span class="hljs-number">59</span> status = <span class="hljs-string">&quot;disabled&quot;</span>;<br><span class="hljs-number">60</span> &#125;;<br><span class="hljs-number">61</span> &#125;<br><span class="hljs-number">62</span><br><span class="hljs-number">63</span> <span class="hljs-comment">//aips3 节点</span><br><span class="hljs-number">64</span> aips3: aips-bus@<span class="hljs-number">02200000</span> &#123;<br><span class="hljs-number">65</span> compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br><span class="hljs-number">66</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">67</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">68</span> reg = &lt;<span class="hljs-number">0x02200000</span> <span class="hljs-number">0x100000</span>&gt;;<br><span class="hljs-number">69</span> ranges;<br><span class="hljs-number">70</span><br><span class="hljs-number">71</span> <span class="hljs-comment">//rngb 节点</span><br><span class="hljs-number">72</span> rngb: rngb@<span class="hljs-number">02284000</span> &#123;<br><span class="hljs-number">73</span> compatible = <span class="hljs-string">&quot;fsl,imx6sl-rng&quot;</span>, <span class="hljs-string">&quot;fsl,imx-rng&quot;</span>, <span class="hljs-string">&quot;imxrng&quot;</span>;<br><span class="hljs-number">74</span> reg = &lt;<span class="hljs-number">0x02284000</span> <span class="hljs-number">0x4000</span>&gt;;<br><span class="hljs-number">75</span> &#125;;<br><span class="hljs-number">76</span> &#125;<br><span class="hljs-number">77</span> &#125;<br><span class="hljs-number">78</span> &#125;<br></code></pre></td></tr></table></figure>

<p>第 38<del>44 行， ecspi1 外设控制器节点。<br>第 56</del>60 行， usbotg1 外设控制器节点。<br>第 72~75 行， rngb 外设控制器节点。<br>至此， myfirst.dts 这个小型的模板设备树就编写好了，基本和 imx6ull.dtsi 很像，可以看做<br>是 imx6ull.dtsi 的缩小版。在 myfirst.dts 里面我们仅仅是编写了 I.MX6ULL 的外设控制器节点，<br>像 IIC 接口， SPI 接口下所连接的具体设备我们并没有写，因为具体的设备其设备树属性内容不<br>同，这个等到具体的实验在详细讲解。</p>
<h2 id="设备树在系统中的体现"><a href="#设备树在系统中的体现" class="headerlink" title="设备树在系统中的体现"></a>设备树在系统中的体现</h2><p>Linux 内核启动的时候会解析设备树中各个节点的信息，并且在根文件系的&#x2F;proc&#x2F;devicetree 目录下根据节点名字创建不同文件夹，如图 43.5.1 所示：</p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658633153328.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>图 43.5.1 就是目录&#x2F;proc&#x2F;device-tree 目录下的内容， &#x2F;proc&#x2F;device-tree 目录下是根节点“&#x2F;”的所有属性和子节点，我们依次来看一下这些属性和子节点。</p>
<h3 id="1、根节点“-x2F-”各个属性"><a href="#1、根节点“-x2F-”各个属性" class="headerlink" title="1、根节点“&#x2F;”各个属性"></a>1、根节点“&#x2F;”各个属性</h3><p>在上图中，根节点属性属性表现为一个个的文件(图中细字体文件)，比如图 43.5.1 中的“#address-cells”、“#size-cells”、“compatible”、“model”和“name”这 5 个文件，它们在设备树中就是根节点的 5个属性。既然是文件那么肯定可以查看其内容，输入cat 命令来查看 model和 compatible 这两个文件的内容，结果如图 43.5.2 所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658647137830.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>从图 43.5.2 可以看出，文件 model 的内容是“Freescale i.MX6 ULL 14x14 EVK Board”，文件 compatible 的内容为“fsl,imx6ull-14x14-evkfsl,imx6ull”。打开文件 imx6ull-alientek-emmc.dts查看一下，这不正是根节点“&#x2F;”的 model 和 compatible 属性值吗！</p>
<h3 id="2、根节点“-x2F-”各子节点"><a href="#2、根节点“-x2F-”各子节点" class="headerlink" title="2、根节点“&#x2F;”各子节点"></a>2、根节点“&#x2F;”各子节点</h3><p>图 43.5.1 中各个文件夹(图中粗字体文件夹)就是根节点“&#x2F;”的各个子节点，比如“aliases”、“ backlight”、“ chosen”和“ clocks”等等。大家可以查看一下 imx6ull-alientek-emmc.dts 和imx6ull.dtsi 这两个文件，看看根节点的子节点都有哪些，看看是否和图 43.5.1 中的一致。<br>&#x2F;proc&#x2F;device-tree 目录就是设备树在根文件系统中的体现，同样是按照树形结构组织的，进入&#x2F;proc&#x2F;device-tree&#x2F;soc 目录中就可以看到 soc 节点的所有子节点，如图 43.5.3 所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658647586626.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>和根节点“&#x2F;”一样，图 43.5.3 中的所有文件分别为 soc 节点的属性文件和子节点文件夹。<br>大家可以自行查看一下这些属性文件的内容是否和 imx6ull.dtsi 中 soc 节点的属性值相同，也可以进入“busfreq”这样的文件夹里面查看 soc 节点的子节点信息</p>
<h2 id="特殊节点"><a href="#特殊节点" class="headerlink" title="特殊节点"></a>特殊节点</h2><p>在根节点“&#x2F;”中有两个特殊的子节点： aliases 和 chosen，我们接下来看一下这两个特殊的子节点。</p>
<h4 id="aliases-子节点"><a href="#aliases-子节点" class="headerlink" title="aliases 子节点"></a>aliases 子节点</h4><p>打开 imx6ull.dtsi 文件， aliases 节点内容如下所示</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-number">18</span> <span class="hljs-title class_">aliases</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-number">19</span> can0 = <span class="hljs-variable">&amp;flexcan1</span><span class="hljs-punctuation">;</span><br><span class="hljs-number">20</span> can1 = <span class="hljs-variable">&amp;flexcan2</span><span class="hljs-punctuation">;</span><br><span class="hljs-number">21</span> ethernet0 = <span class="hljs-variable">&amp;fec1</span><span class="hljs-punctuation">;</span><br><span class="hljs-number">22</span> ethernet1 = <span class="hljs-variable">&amp;fec2</span><span class="hljs-punctuation">;</span><br><span class="hljs-number">23</span> gpio0 = <span class="hljs-variable">&amp;gpio1</span><span class="hljs-punctuation">;</span><br><span class="hljs-number">24</span> gpio1 = <span class="hljs-variable">&amp;gpio2</span><span class="hljs-punctuation">;</span><br>......<br><span class="hljs-number">42</span> spi0 = <span class="hljs-variable">&amp;ecspi1</span><span class="hljs-punctuation">;</span><br><span class="hljs-number">43</span> spi1 = <span class="hljs-variable">&amp;ecspi2</span><span class="hljs-punctuation">;</span><br><span class="hljs-number">44</span> spi2 = <span class="hljs-variable">&amp;ecspi3</span><span class="hljs-punctuation">;</span><br><span class="hljs-number">45</span> spi3 = <span class="hljs-variable">&amp;ecspi4</span><span class="hljs-punctuation">;</span><br><span class="hljs-number">46</span> usbphy0 = <span class="hljs-variable">&amp;usbphy1</span><span class="hljs-punctuation">;</span><br><span class="hljs-number">47</span> usbphy1 = <span class="hljs-variable">&amp;usbphy2</span><span class="hljs-punctuation">;</span><br><span class="hljs-number">48</span> <span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure>
<p>单词 aliases 的意思是“别名”，因此 aliases 节点的主要功能就是定义别名，定义别名的目的就是为了方便访问节点。不过我们一般会在节点命名的时候会加上 label，然后通过&amp;label来访问节点，这样也很方便，而且设备树里面大量的使用&amp;label 的形式来访问节点。</p>
<h4 id="chosen-子节点"><a href="#chosen-子节点" class="headerlink" title="chosen 子节点"></a>chosen 子节点</h4><p>chosen 并不是一个真实的设备， chosen 节点主要是为了 uboot 向 Linux 内核传递数据，重点是 bootargs 参数。一般.dts 文件中 chosen 节点通常为空或者内容很少， imx6ull-alientekemmc.dts 中 chosen 节点内容如下所示：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">18 </span>chosen &#123;<br><span class="hljs-symbol">19 </span>stdout-path = &amp;uart1;<br><span class="hljs-symbol">20 </span>&#125;;<br></code></pre></td></tr></table></figure>
<p>从示例代码 43.6.2.1 中可以看出， chosen 节点仅仅设置了属性“stdout-path”，表示标准输出使用 uart1。但是当我们进入到&#x2F;proc&#x2F;device-tree&#x2F;chosen 目录里面，会发现多了 bootargs 这个属性，如图 43.6.2.1 所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658648294643.png" srcset="/img/loading.gif" lazyload alt="enter description here"><br>输入 cat 命令查看 bootargs 这个文件的内容，结果如图 43.6.2.2 所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658648317421.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>从图 43.6.2.2 可以看出， bootargs 这个文件的内容为“console&#x3D;ttymxc0,115200……”，这个不就是我们在 uboot 中设置的 bootargs 环境变量的值吗？现在有两个疑点：</p>
<ul>
<li>①、我们并没有在设备树中设置 chosen 节点的 bootargs 属性，那么图 43.6.2.1 中 bootargs这个属性是怎么产生的？</li>
<li>②、为何 bootargs 文件的内容和 uboot 中 bootargs 环境变量的值一样？它们之间有什么关系？</li>
</ul>
<p>前面讲解 uboot 的时候说过， uboot 在启动 Linux 内核的时候会将 bootargs 的值传递给 Linux内核， bootargs 会作为 Linux 内核的命令行参数， Linux 内核启动的时候会打印出命令行参数(也就是 uboot 传递进来的 bootargs 的值)，如图 43.6.2.3 所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658648354853.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>既然 chosen 节点的 bootargs 属性不是我们在设备树里面设置的，那么只有一种可能，那就是 uboot 自己在 chosen 节点里面添加了 bootargs 属性！并且设置 bootargs 属性的值为 bootargs环境变量的值。因为在启动 Linux 内核之前，只有 uboot 知道 bootargs 环境变量的值，并且 uboot 也知道.dtb 设备树文件在 DRAM 中的位置，因此 uboot 的“作案”嫌疑最大。在 uboot 源码中全局搜索“ chosen”这个字符串，看看能不能找到一些蛛丝马迹。果然不出所料，在common&#x2F;fdt_support.c 文件中发现了“chosen”的身影， fdt_support.c 文件中有个 fdt_chosen 函数，此函数内容如下所示：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">275 </span><span class="hljs-keyword">int</span> fdt_chosen(void *fdt)<br><span class="hljs-symbol">276 </span>&#123;<br><span class="hljs-symbol">277 </span><span class="hljs-keyword">int</span> nodeoffset;<br><span class="hljs-symbol">278 </span><span class="hljs-keyword">int</span> <span class="hljs-keyword">err</span>;<br><span class="hljs-symbol">279 </span>char *str; /* used <span class="hljs-keyword">to</span> set string properties */<br><span class="hljs-number">280</span><br><span class="hljs-symbol">281 </span><span class="hljs-keyword">err</span> = fdt_check_header(fdt);<br><span class="hljs-symbol">282 </span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">err</span> &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-symbol">283 </span>printf(<span class="hljs-string">&quot;fdt_chosen: %s\n&quot;</span>, fdt_strerror(<span class="hljs-keyword">err</span>));<br><span class="hljs-symbol">284 </span><span class="hljs-keyword">return</span> <span class="hljs-keyword">err</span>;<br><span class="hljs-symbol">285 </span>&#125;<br><span class="hljs-number">286</span><br><span class="hljs-symbol">287 </span>/* find <span class="hljs-keyword">or</span> create <span class="hljs-string">&quot;/chosen&quot;</span> node. */<br><span class="hljs-symbol">288 </span>nodeoffset = fdt_find_or_add_subnode(fdt, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;chosen&quot;</span>);<br><span class="hljs-symbol">289 </span><span class="hljs-keyword">if</span> (nodeoffset &lt; <span class="hljs-number">0</span>)<br><span class="hljs-symbol">290 </span><span class="hljs-keyword">return</span> nodeoffset;<br><span class="hljs-number">291</span><br><span class="hljs-symbol">292 </span>str = getenv(<span class="hljs-string">&quot;bootargs&quot;</span>);<br><span class="hljs-symbol">293 </span><span class="hljs-keyword">if</span> (str) &#123;<br><span class="hljs-symbol">294 </span><span class="hljs-keyword">err</span> = fdt_setprop(fdt, nodeoffset, <span class="hljs-string">&quot;bootargs&quot;</span>, str,<br><span class="hljs-symbol">295 </span>strlen(str) + <span class="hljs-number">1</span>);<br><span class="hljs-symbol">296 </span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">err</span> &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-symbol">297 </span>printf(<span class="hljs-string">&quot;WARNING: could not set bootargs %s.\n&quot;</span>,<br><span class="hljs-symbol">298 </span>fdt_strerror(<span class="hljs-keyword">err</span>));<br><span class="hljs-symbol">299 </span><span class="hljs-keyword">return</span> <span class="hljs-keyword">err</span>;<br><span class="hljs-symbol">300 </span>&#125;<br><span class="hljs-symbol">301 </span>&#125;<br><span class="hljs-number">302</span><br><span class="hljs-symbol">303 </span><span class="hljs-keyword">return</span> fdt_fixup_stdout(fdt, nodeoffset);<br><span class="hljs-symbol">304 </span>&#125;<br></code></pre></td></tr></table></figure>

<p>第 288 行，调用函数 fdt_find_or_add_subnode 从设备树(.dtb)中找到 chosen 节点，如果没有找到的话就会自己创建一个 chosen 节点。<br>第 292 行，读取 uboot 中 bootargs 环境变量的内容。<br>第 294 行，调用函数 fdt_setprop 向 chosen 节点添加 bootargs 属性，并且 bootargs 属性的值就是环境变量 bootargs 的内容。</p>
<p>证据“实锤”了，就是 uboot 中的 fdt_chosen 函数在设备树的 chosen 节点中加入了 bootargs属性，并且还设置了 bootargs 属性值。接下来我们顺着 fdt_chosen 函数一点点的抽丝剥茧，看看都有哪些函数调用了 fdt_chosen，一直找到最终的源头。这里我就不卖关子了，直接告诉大家<br>整个流程是怎么样的，见图 43.6.2.4：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658648460428.png" srcset="/img/loading.gif" lazyload alt="enter description here"><br>图 43.6.2.4 中框起来的部分就是函数 do_bootm_linux 函数的执行流程，也就是说do_bootm_linux 函数会通过一系列复杂的调用，最终通过 fdt_chosen 函数在 chosen 节点中加入了 bootargs 属性。而我们通过 bootz 命令启动 Linux 内核的时候会运行 do_bootm_linux 函数，至此，真相大白，一切事情的源头都源于如下命令：<br><code>bootz 80800000 – 83000000</code><br>当我们输入上述命令并执行以后， do_bootz 函数就会执行，然后一切就按照图 43.6.2.4 中所示的流程开始运行。</p>
<h2 id="Linux-内核解析-DTB-文件"><a href="#Linux-内核解析-DTB-文件" class="headerlink" title="Linux 内核解析 DTB 文件"></a>Linux 内核解析 DTB 文件</h2><p>Linux 内核在启动的时候会解析 DTB 文件，然后在&#x2F;proc&#x2F;device-tree 目录下生成相应的设备树节点文件。接下来我们简单分析一下 Linux 内核是如何解析 DTB 文件的，流程如图 43.7.1 所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658648534547.png" srcset="/img/loading.gif" lazyload alt="enter description here"><br>从图 43.7.1 中可以看出，在 start_kernel 函数中完成了设备树节点解析的工作，最终实际工作的函数为 unflatten_dt_node。</p>
<h2 id="绑定信息文档"><a href="#绑定信息文档" class="headerlink" title="绑定信息文档"></a>绑定信息文档</h2><p>设备树是用来描述板子上的设备信息的，不同的设备其信息不同，反映到设备树中就是属性不同。那么我们在设备树中添加一个硬件对应的节点的时候从哪里查阅相关的说明呢？在Linux 内核源码中有详细的.txt 文档描述了如何添加节点，这些.txt 文档叫做绑定文档，路径为：Linux 源码目录&#x2F;Documentation&#x2F;devicetree&#x2F;bindings，如图 43.8.1 所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AF%87/1658648591216.png" srcset="/img/loading.gif" lazyload alt="enter description here"><br>比如我们现在要想在 I.MX6ULL 这颗 SOC 的 I2C 下添加一个节点，那么就可以查看<br>Documentation&#x2F;devicetree&#x2F;bindings&#x2F;i2c&#x2F;i2c-imx.txt，此文档详细的描述了 I.MX 系列的 SOC 如何在设备树中添加 I2C 设备节点，文档内容如下所示：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs pf">* Freescale Inter IC (I2C) and High Speed Inter IC (HS-I2C) <span class="hljs-keyword">for</span> i.MX<br>Required properties:<br>- compatible :<br>- <span class="hljs-string">&quot;fsl,imx1-i2c&quot;</span> <span class="hljs-keyword">for</span> I2C compatible with the one integrated <span class="hljs-keyword">on</span> i.MX1<br>SoC<br>- <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span> <span class="hljs-keyword">for</span> I2C compatible with the one integrated <span class="hljs-keyword">on</span> i.MX21<br>SoC<br>- <span class="hljs-string">&quot;fsl,vf610-i2c&quot;</span> <span class="hljs-keyword">for</span> I2C compatible with the one integrated <span class="hljs-keyword">on</span> Vybrid<br>vf610 SoC<br>- reg : Should contain I2C/HS-I2C registers location and length<br>- interrupts : Should contain I2C/HS-I2C interrupt<br>- clocks : Should contain the I2C/HS-I2C clock specifier<br>Optional properties:<br>- clock-frequency : Constains desired I2C/HS-I2C bus clock frequency <span class="hljs-keyword">in</span><br>Hz.<br>The absence of the propoerty indicates the <span class="hljs-keyword">default</span> frequency <span class="hljs-number">100</span> kHz.<br>- dmas: A list of two dma specifiers, one <span class="hljs-keyword">for</span> each entry <span class="hljs-keyword">in</span> dma-names.<br>- dma-names: should contain <span class="hljs-string">&quot;tx&quot;</span> and <span class="hljs-string">&quot;rx&quot;</span>.<br>Examples:<br>i2c@<span class="hljs-number">83</span>fc4000 &#123; /* I2C2 <span class="hljs-keyword">on</span> i.MX51 */<br>compatible = <span class="hljs-string">&quot;fsl,imx51-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;<br>reg = <span class="hljs-variable">&lt;0x83fc4000 0x4000&gt;</span>;<br>interrupts = <span class="hljs-variable">&lt;63&gt;</span>;<br>&#125;;<br>i2c@<span class="hljs-number">70038000</span> &#123; /* HS-I2C <span class="hljs-keyword">on</span> i.MX51 */<br>compatible = <span class="hljs-string">&quot;fsl,imx51-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;<br>reg = <span class="hljs-variable">&lt;0x70038000 0x4000&gt;</span>;<br>interrupts = <span class="hljs-variable">&lt;64&gt;</span>;<br>clock-frequency = <span class="hljs-variable">&lt;400000&gt;</span>;<br>&#125;;<br>i2c0: i2c@<span class="hljs-number">40066000</span> &#123; /* i2c0 <span class="hljs-keyword">on</span> vf610 */<br>compatible = <span class="hljs-string">&quot;fsl,vf610-i2c&quot;</span>;<br>reg = <span class="hljs-variable">&lt;0x40066000 0x1000&gt;</span>;<br>interrupts =<span class="hljs-variable">&lt;0 71 0x04&gt;</span>;<br>dmas = <span class="hljs-variable">&lt;&amp;edma0 0 50&gt;</span>,<br><span class="hljs-variable">&lt;&amp;edma0 0 51&gt;</span>;<br>dma-names = <span class="hljs-string">&quot;rx&quot;</span>,<span class="hljs-string">&quot;tx&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>有时候使用的一些芯片在 Documentation&#x2F;devicetree&#x2F;bindings 目录下找不到对应的文档，这个时候就要咨询芯片的提供商，让他们给你提供参考的设备树文件。</p>
<h2 id="设备树常用-OF-操作函数"><a href="#设备树常用-OF-操作函数" class="headerlink" title="设备树常用 OF 操作函数"></a>设备树常用 OF 操作函数</h2><p>设备树描述了设备的详细信息，这些信息包括数字类型的、字符串类型的、数组类型的，我们在编写驱动的时候需要获取到这些信息。比如设备树使用 reg 属性描述了某个外设的寄存器地址为 0X02005482，长度为 0X400，我们在编写驱动的时候需要获取到 reg 属性的0X02005482 和 0X400 这两个值，然后初始化外设。 Linux 内核给我们提供了一系列的函数来获取设备树中的节点或者属性信息，这一系列的函数都有一个统一的前缀“of_”，所以在很多资料里面也被叫做 OF 函数。这些 OF 函数原型都定义在 include&#x2F;linux&#x2F;of.h 文件中</p>
<h3 id="查找节点的-OF-函数"><a href="#查找节点的-OF-函数" class="headerlink" title="查找节点的 OF 函数"></a>查找节点的 OF 函数</h3><p>设备都是以节点的形式“挂”到设备树上的，因此要想获取这个设备的其他属性信息，必<br>须先获取到这个设备的节点。 Linux 内核使用 device_node 结构体来描述一个节点，此结构体定义在文件 include&#x2F;linux&#x2F;of.h 中，定义如下：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">49 </span>struct device_node &#123;<br><span class="hljs-symbol">50 </span>const char *<span class="hljs-keyword">name</span>; /* 节点名字 */<br><span class="hljs-symbol">51 </span>const char *type; /* 设备类型 */<br><span class="hljs-symbol">52 </span>phandle phandle;<br><span class="hljs-symbol">53 </span>const char *full_name; /* 节点全名 */<br><span class="hljs-symbol">54 </span>struct fwnode_handle fwnode;<br><span class="hljs-number">55</span><br><span class="hljs-symbol">56 </span>struct property *properties; /* 属性 */<br><span class="hljs-symbol">57 </span>struct property *deadprops; /* <span class="hljs-comment">removed 属性 */</span><br><span class="hljs-symbol">58 </span>struct device_node *parent; /* 父节点 */<br><span class="hljs-symbol">59 </span>struct device_node *child; /* 子节点 */<br><span class="hljs-symbol">60 </span>struct device_node *sibling;<br><span class="hljs-symbol">61 </span>struct kobject kobj;<br><span class="hljs-symbol">62 </span>unsigned long _flags;<br><span class="hljs-symbol">63 </span>void *<span class="hljs-keyword">data</span>;<br><span class="hljs-symbol">64 </span>#<span class="hljs-keyword">if</span> defined(CONFIG_SPARC)<br><span class="hljs-symbol">65 </span>const char *path_component_name;<br><span class="hljs-symbol">66 </span>unsigned <span class="hljs-keyword">int</span> unique_id;<br><span class="hljs-symbol">67 </span>struct of_irq_controller *irq_trans;<br><span class="hljs-symbol">68 </span>#endif<br><span class="hljs-symbol">69 </span>&#125;;<br></code></pre></td></tr></table></figure>

<p>与查找节点有关的 OF 函数有 5 个，我们依次来看一下。</p>
<h4 id="1、-of-find-node-by-name-函数"><a href="#1、-of-find-node-by-name-函数" class="headerlink" title="1、 of_find_node_by_name 函数"></a>1、 of_find_node_by_name 函数</h4><p>of_find_node_by_name 函数通过节点名字查找指定的节点，函数原型如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> device_node *of_find_node_by_name(<span class="hljs-keyword">struct</span> device_node *<span class="hljs-keyword">from</span>,<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *name);<br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：</p>
<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>name：要查找的节点名字。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败。</li>
</ul>
<h4 id="2、-of-find-node-by-type-函数"><a href="#2、-of-find-node-by-type-函数" class="headerlink" title="2、 of_find_node_by_type 函数"></a>2、 of_find_node_by_type 函数</h4><p>of_find_node_by_type 函数通过 device_type 属性查找指定的节点，函数原型如下：<br><code>struct device_node *of_find_node_by_type(struct device_node *from, const char *type)</code></p>
<p>函数参数和返回值含义如下：</p>
<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>type：要查找的节点对应的 type 字符串，也就是 device_type 属性值。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败。</li>
</ul>
<h4 id="3、-of-find-compatible-node-函数"><a href="#3、-of-find-compatible-node-函数" class="headerlink" title="3、 of_find_compatible_node 函数"></a>3、 of_find_compatible_node 函数</h4><p>of_find_compatible_node 函数根据 device_type 和 compatible 这两个属性查找指定的节点，函数原型如下：<br><code>struct device_node *of_find_compatible_node(struct device_node *from, const char *type,const char *compatible)</code></p>
<p>函数参数和返回值含义如下：</p>
<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>type：要查找的节点对应的 type 字符串，也就是 device_type 属性值，可以为 NULL，表示忽略掉 device_type 属性。</li>
<li>compatible： 要查找的节点所对应的 compatible 属性列表。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败</li>
</ul>
<h4 id="4、-of-find-matching-node-and-match-函数"><a href="#4、-of-find-matching-node-and-match-函数" class="headerlink" title="4、 of_find_matching_node_and_match 函数"></a>4、 of_find_matching_node_and_match 函数</h4><p>of_find_matching_node_and_match 函数通过 of_device_id 匹配表来查找指定的节点，函数原型如下：</p>
<figure class="highlight plaintext"><figcaption><span>device_node *of_find_matching_node_and_match(struct device_node *from, const struct of_device_id *matches, const struct of_device_id **match)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs struct">```<br>函数参数和返回值含义如下：<br>- from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br>- matches： of_device_id 匹配表，也就是在此匹配表里面查找节点。<br>- match： 找到的匹配的 of_device_id。<br>- 返回值： 找到的节点，如果为 NULL 表示查找失败<br><br>#### 5、 of_find_node_by_path 函数<br>of_find_node_by_path 函数通过路径来查找指定的节点，函数原型如下：<br>```inline struct device_node *of_find_node_by_path(const char *path)```<br>函数参数和返回值含义如下：<br>- path：带有全路径的节点名，可以使用节点的别名，比如“/backlight”就是 backlight 这个节点的全路径。<br>- 返回值： 找到的节点，如果为 NULL 表示查找失败<br><br>### 查找父/子节点的 OF 函数<br>Linux 内核提供了几个查找节点对应的父节点或子节点的 OF 函数，我们依次来看一下。<br>#### 1、 of_get_parent 函数<br>of_get_parent 函数用于获取指定节点的父节点(如果有父节点的话)，函数原型如下：<br>```struct device_node *of_get_parent(const struct device_node *node)```<br>函数参数和返回值含义如下：<br>- node：要查找的父节点的节点。<br>- 返回值： 找到的父节点。<br>#### 2、 of_get_next_child 函数<br><br>of_get_next_child 函数用迭代的方式查找子节点，函数原型如下：<br>```struct device_node *of_get_next_child(const struct device_node *node,struct device_node *prev)```<br>函数参数和返回值含义如下：<br>- node：父节点。<br>- prev：前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为<br>- NULL，表示从第一个子节点开始。<br>- 返回值： 找到的下一个子节点。<br><br>### 提取属性值的 OF 函数<br><br>节点的属性信息里面保存了驱动所需要的内容，因此对于属性值的提取非常重要， Linux 内核中使用结构体 property 表示属性，此结构体同样定义在文件 include/linux/of.h 中，内容如下：<br></code></pre></td></tr></table></figure>
<p>35 struct property {<br>36 char <em>name; &#x2F;</em> 属性名字 <em>&#x2F;<br>37 int length; &#x2F;</em> 属性长度 *&#x2F;<br>38 void <em>value; &#x2F;</em> 属性值 *&#x2F;<br>39 struct property <em>next; &#x2F;</em> 下一个属性 *&#x2F;<br>40 unsigned long _flags;<br>41 unsigned int unique_id;<br>42 struct bin_attribute attr;<br>43 };</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>Linux 内核也提供了提取属性值的 OF 函数，我们依次来看一下。<br>#### <span class="hljs-number">1</span>、 of_find_property 函数<br>of_find_property 函数用于查找指定的属性，函数原型如下：<br></code></pre></td></tr></table></figure>
<p>property *of_find_property(const struct device_node *np,<br>const char *name,<br>int *lenp)</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">函数参数和返回值含义如下：<br>- np：设备节点。<br>- name： 属性名字。<br>- lenp：属性值的字节数<br>- 返回值： 找到的属性。<br> <br>#### <span class="hljs-number">2</span>、 of_property_count_elems_of_size 函数<br>of_property_count_elems_of_size 函数用于获取属性中元素的数量，比如 reg 属性值是一个数组，那么使用此函数可以获取到这个数组的大小，此函数原型如下：<br>```<span class="hljs-built_in">int</span> <span class="hljs-keyword">of</span><span class="hljs-constructor">_property_count_elems_of_size(<span class="hljs-params">const</span> <span class="hljs-params">struct</span> <span class="hljs-params">device_node</span> <span class="hljs-operator">*</span><span class="hljs-params">np</span>,<span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">propname</span>,<span class="hljs-params">int</span> <span class="hljs-params">elem_size</span>)</span>```<br><br>函数参数和返回值含义如下：<br>- np：设备节点。<br>- proname： 需要统计元素数量的属性名字。<br>- elem_size：元素长度。<br>- 返回值： 得到的属性元素数量。<br><br>#### <span class="hljs-number">3</span>、 of_property_read_u32_index 函数<br>of_property_read_u32_index 函数用于从属性中获取指定标号的 u32 类型数据值(无符号 <span class="hljs-number">32</span>位)，比如某个属性有多个 u32 类型的值，那么就可以使用此函数来获取指定标号的数据值，此函数原型如下：<br>```<span class="hljs-built_in">int</span> <span class="hljs-keyword">of</span><span class="hljs-constructor">_property_read_u32_index(<span class="hljs-params">const</span> <span class="hljs-params">struct</span> <span class="hljs-params">device_node</span> <span class="hljs-operator">*</span><span class="hljs-params">np</span>,<span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">propname</span>,<span class="hljs-params">u32</span> <span class="hljs-params">index</span>,<span class="hljs-params">u32</span> <span class="hljs-operator">*</span><span class="hljs-params">out_value</span>)</span>```<br><br>函数参数和返回值含义如下：<br>- np：设备节点。<br>- proname： 要读取的属性名字。<br>- index：要读取的值标号。<br>- out_value：读取到的值<br>- 返回值： <span class="hljs-number">0</span> 读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。<br><br>#### <span class="hljs-number">4</span>、 of_property_read_u8_array 函数<br>of_property_read_u16_array 函数<br>of_property_read_u32_array 函数<br>of_property_read_u64_array 函数<br><br>这 <span class="hljs-number">4</span> 个函数分别是读取属性中 u8、 u16、 u32 和 u64 类型的数组数据，比如大多数的 reg 属性都是数组数据，可以使用这 <span class="hljs-number">4</span> 个函数一次读取出 reg 属性中的所有数据。这四个函数的原型如下：<br></code></pre></td></tr></table></figure>
<p>int of_property_read_u8_array(const struct device_node *np,<br>const char *propname,<br>u8 *out_values,<br>size_t sz)<br>int of_property_read_u16_array(const struct device_node *np,<br>const char *propname,<br>u16 *out_values,<br>size_t sz)<br>int of_property_read_u32_array(const struct device_node *np,<br>const char *propname,<br>u32 *out_values,<br>size_t sz)<br>int of_property_read_u64_array(const struct device_node *np,<br>const char *propname,<br>u64 *out_values,<br>size_t sz)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust">函数参数和返回值含义如下：<br>- np：设备节点。<br>- proname： 要读取的属性名字。<br>- out_value：读取到的数组值，分别为 <span class="hljs-type">u8</span>、 <span class="hljs-type">u16</span>、 <span class="hljs-type">u32</span> 和 <span class="hljs-type">u64</span>。<br>- sz： 要读取的数组元素数量。<br>- 返回值： <span class="hljs-number">0</span>，读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。<br><br>#### <span class="hljs-number">5</span>、 of_property_read_u8 函数<br>of_property_read_u16 函数<br>of_property_read_u32 函数<br>of_property_read_u64 函数<br><br>有些属性只有一个整形值，这四个函数就是用于读取这种只有一个整形值的属性，分别用于读取 <span class="hljs-type">u8</span>、 <span class="hljs-type">u16</span>、 <span class="hljs-type">u32</span> 和 <span class="hljs-type">u64</span> 类型属性值，函数原型如下：<br></code></pre></td></tr></table></figure>
<p>int of_property_read_u8(const struct device_node *np,<br>const char *propname,<br>u8 *out_value)<br>int of_property_read_u16(const struct device_node *np,<br>const char *propname,<br>u16 *out_value)<br>int of_property_read_u32(const struct device_node *np,<br>const char *propname,<br>u32 *out_value)<br>int of_property_read_u64(const struct device_node *np,<br>const char *propname,<br>u64 *out_value)</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">函数参数和返回值含义如下：<br><span class="hljs-bullet">- </span>np：设备节点。<br><span class="hljs-bullet">- </span>proname： 要读取的属性名字。<br><span class="hljs-bullet">- </span>out_value：读取到的数组值。<br><span class="hljs-bullet">- </span>返回值： 0，读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。<br><br>#### 6、 of<span class="hljs-emphasis">_property_read_string 函数</span><br><span class="hljs-emphasis">of_property_read_</span>string 函数用于读取属性中字符串值，函数原型如下：<br></code></pre></td></tr></table></figure>
<p>int of_property_read_string(struct device_node *np,const char *propname,const char **out_string)</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">函数参数和返回值含义如下：<br>- np：设备节点。<br>- proname： 要读取的属性名字。<br>- out_string：读取到的字符串值。<br>- 返回值： <span class="hljs-number">0</span>，读取成功，负值，读取失败。<br><br>#### <span class="hljs-number">7</span>、 of_n_addr_cells 函数<br>of_n_addr_cells 函数用于获取#address-cells 属性值，函数原型如下：<br>```<span class="hljs-built_in">int</span> <span class="hljs-keyword">of</span><span class="hljs-constructor">_n_addr_cells(<span class="hljs-params">struct</span> <span class="hljs-params">device_node</span> <span class="hljs-operator">*</span><span class="hljs-params">np</span>)</span>```<br>函数参数和返回值含义如下：<br>- np：设备节点。<br>- 返回值： 获取到的#address-cells 属性值。<br><br>#### <span class="hljs-number">8</span>、 of_n_size_cells 函数<br>of_size_cells 函数用于获取#size-cells 属性值，函数原型如下：<br>```<span class="hljs-built_in">int</span> <span class="hljs-keyword">of</span><span class="hljs-constructor">_n_size_cells(<span class="hljs-params">struct</span> <span class="hljs-params">device_node</span> <span class="hljs-operator">*</span><span class="hljs-params">np</span>)</span>```<br>函数参数和返回值含义如下：<br>- np：设备节点。<br>- 返回值： 获取到的#size-cells 属性值。<br><br>### 其他常用的 OF 函数<br><br>#### <span class="hljs-number">1</span>、 of_device_is_compatible 函数<br>of_device_is_compatible 函数用于查看节点的 compatible 属性是否有包含 compat 指定的字符串，也就是检查设备节点的兼容性，函数原型如下：<br>```<span class="hljs-built_in">int</span> <span class="hljs-keyword">of</span><span class="hljs-constructor">_device_is_compatible(<span class="hljs-params">const</span> <span class="hljs-params">struct</span> <span class="hljs-params">device_node</span> <span class="hljs-operator">*</span><span class="hljs-params">device</span>,<span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">compat</span>)</span>```<br>函数参数和返回值含义如下：<br>- device：设备节点。<br>- compat：要查看的字符串。<br>- 返回值： <span class="hljs-number">0</span>，节点的 compatible 属性中不包含 compat 指定的字符串； 正数，节点的 compatible属性中包含 compat 指定的字符串。<br><br>#### <span class="hljs-number">2</span>、 of_get_address 函数<br>of_get_address 函数用于获取地址相关属性，主要是“reg”或者“assigned-addresses”属性值，函数原型如下：<br>```const __be32 *<span class="hljs-keyword">of</span><span class="hljs-constructor">_get_address(<span class="hljs-params">struct</span> <span class="hljs-params">device_node</span> <span class="hljs-operator">*</span><span class="hljs-params">dev</span>,<span class="hljs-params">int</span> <span class="hljs-params">index</span>,<span class="hljs-params">u64</span> <span class="hljs-operator">*</span><span class="hljs-params">size</span>,<span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">flags</span>)</span>```<br>函数参数和返回值含义如下：<br>- dev：设备节点。<br>- index：要读取的地址标号。<br>- size：地址长度。<br>- flags：参数，比如 IORESOURCE_IO、 IORESOURCE_MEM 等<br>- 返回值： 读取到的地址数据首地址，为 NULL 的话表示读取失败。<br>#### <span class="hljs-number">3</span>、 of_translate_address 函数<br>of_translate_address 函数负责将从设备树读取到的地址转换为物理地址，函数原型如下：<br>```u64 <span class="hljs-keyword">of</span><span class="hljs-constructor">_translate_address(<span class="hljs-params">struct</span> <span class="hljs-params">device_node</span> <span class="hljs-operator">*</span><span class="hljs-params">dev</span>,<span class="hljs-params">const</span> <span class="hljs-params">__be32</span> <span class="hljs-operator">*</span><span class="hljs-params">in_addr</span>)</span>```<br>函数参数和返回值含义如下：<br>- dev：设备节点。<br>- in_addr：要转换的地址。<br>- 返回值： 得到的物理地址，如果为 OF_BAD_ADDR 的话表示转换失败。<br>#### <span class="hljs-number">4</span>、 of_address_to_resource 函数<br>IIC、 SPI、 GPIO 等这些外设都有对应的寄存器，这些寄存器其实就是一组内存空间， Linux内核使用 resource 结构体来描述一段内存空间，“resource”翻译出来就是“资源”，因此用 resource结构体描述的都是设备资源信息， resource 结构体定义在文件 <span class="hljs-keyword">include</span>/linux/ioport.h 中，定义如下：<br></code></pre></td></tr></table></figure>
<p>18 struct resource {<br>19 resource_size_t start;<br>20 resource_size_t end;<br>21 const char *name;<br>22 unsigned long flags;<br>23 struct resource *parent, *sibling, *child;<br>24 };</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">对于 <span class="hljs-number">32</span> 位的 SOC 来说， resource_size_t 是 u32 类型的。其中 <span class="hljs-keyword">start</span> 表示开始地址， <span class="hljs-keyword">end</span> 表示结束地址， <span class="hljs-type">name</span> 是这个资源的名字， flags 是资源标志位，一般表示资源类型，可选的资源标志定义在文件 <span class="hljs-keyword">include</span>/linux/ioport.h 中，如下所示：<br></code></pre></td></tr></table></figure>
<p>1 #define IORESOURCE_BITS 0x000000ff<br>2 #define IORESOURCE_TYPE_BITS 0x00001f00<br>3 #define IORESOURCE_IO 0x00000100<br>4 #define IORESOURCE_MEM 0x00000200<br>5 #define IORESOURCE_REG 0x00000300<br>6 #define IORESOURCE_IRQ 0x00000400<br>7 #define IORESOURCE_DMA 0x00000800<br>8 #define IORESOURCE_BUS 0x00001000<br>9 #define IORESOURCE_PREFETCH 0x00002000<br>10 #define IORESOURCE_READONLY 0x00004000<br>11 #define IORESOURCE_CACHEABLE 0x00008000<br>12 #define IORESOURCE_RANGELENGTH 0x00010000<br>13 #define IORESOURCE_SHADOWABLE 0x00020000<br>14 #define IORESOURCE_SIZEALIGN 0x00040000<br>15 #define IORESOURCE_STARTALIGN 0x00080000<br>16 #define IORESOURCE_MEM_64 0x00100000<br>17 #define IORESOURCE_WINDOW 0x00200000<br>18 #define IORESOURCE_MUXED 0x00400000<br>19 #define IORESOURCE_EXCLUSIVE 0x08000000<br>20 #define IORESOURCE_DISABLED 0x10000000<br>21 #define IORESOURCE_UNSET 0x20000000<br>22 #define IORESOURCE_AUTO 0x40000000<br>23 #define IORESOURCE_BUSY 0x80000000</p>
<pre><code class="hljs">大 家 一 般 最 常 见 的 资 源 标 志 就 是 IORESOURCE_MEM 、 IORESOURCE_REG 和IORESOURCE_IRQ 等。接下来我们回到 of_address_to_resource 函数，此函数看名字像是从设备树里面提取资源值，但是本质上就是将 reg 属性值，然后将其转换为 resource 结构体类型，函数原型如下所示
```int of_address_to_resource(struct device_node *dev,int index,struct resource *r)```
函数参数和返回值含义如下：
- dev：设备节点。
- index：地址资源标号。
- r：得到的 resource 类型的资源值。
- 返回值： 0，成功；负值，失败。

#### 5、 of_iomap 函数
of_iomap 函数用于直接内存映射，以前我们会通过 ioremap 函数来完成物理地址到虚拟地址的映射，采用设备树以后就可以直接通过 of_iomap 函数来获取内存地址所对应的虚拟地址，不需要使用 ioremap 函数了。当然了，你也可以使用 ioremap 函数来完成物理地址到虚拟地址的内存映射，只是在采用设备树以后，大部分的驱动都使用 of_iomap 函数了。 of_iomap 函数本质上也是将 reg 属性中地址信息转换为虚拟地址，如果 reg 属性有多段的话，可以通过 index 参数指定要完成内存映射的是哪一段， of_iomap 函数原型如下：
```void __iomem *of_iomap(struct device_node *np,int index)```
函数参数和返回值含义如下：
- np：设备节点。
- index： reg 属性中要完成内存映射的段，如果 reg 属性只有一段的话 index 就设置为 0。
- 返回值： 经过内存映射后的虚拟内存首地址，如果为 NULL 的话表示内存映射失败。

关于设备树常用的 OF 函数就先讲解到这里， Linux 内核中关于设备树的 OF 函数不仅仅只有前面讲的这几个，还有很多 OF 函数我们并没有讲解，这些没有讲解的 OF 函数要结合具体的驱动，比如获取中断号的 OF 函数、获取 GPIO 的 OF 函数等等，这些 OF 函数我们在后面的驱动实验中再详细的讲解。

关于设备树就讲解到这里，关于设备树我们重点要了解一下几点内容：
- ①、 DTS、 DTB 和 DTC 之间的区别，如何将.dts 文件编译为.dtb 文件。
- ②、设备树语法，这个是重点，因为在实际工作中我们是需要修改设备树的。
- ③、设备树的几个特殊子节点。
- ④、关于设备树的 OF 操作函数，也是重点，因为设备树最终是被驱动文件所使用的，而驱动文件必须要读取设备树中的属性信息，比如内存信息、 GPIO 信息、中断信息等等。要想在驱动中读取设备树的属性值，那么就必须使用 Linux 内核提供的众多的 OF 函数。

# 自学补充-Linux设备与驱动

设备模型：
- 设备：连接到总线上的物理或虚拟对象
- 驱动：负责探测并关联设备的代码实体，也可以执行部分管理功能
- 总线：为其它设备提供接入点的设备
设备模型围绕3个主要的数据结构
- device 数据结构表示一个连接到总线上设备（设备的描述，设备是什么)
- device_driver 数据结构表示一个能够处理特定总线上特定设备的驱动程序（设备的操作，设备怎么用）
- bus_type 数据结构表示某种类型的总线（USB、PCI、I2C）
 
## 设备树
## 模型与总线

在Linux设备模型中，Bus（总线）是一类特殊的设备，它是连接处理器和其它设备之间的通道（channel）。为了方便设备模型的实现，内核规定，系统中的每个设备都要连接在一个Bus上，这个Bus可以是一个内部Bus、虚拟Bus或者Platform Bus。

在Linux内核中，有三种比较特殊的bus（或者是子系统），分别是system bus、virtual bus和platform bus。它们并不是一个实际存在的bus（像USB、I2C等），而是为了方便设备模型的抽象，而虚构的。

system bus是旧版内核提出的概念，用于抽象系统设备（如CPU、Timer等等）。而新版内核认为它是个坏点子，因为任何设备都应归属于一个普通的子系统（New subsystems should use plain subsystems, drivers/base/bus.c, line 1264），所以就把它抛弃了（不建议再使用，它的存在只为兼容旧有的实现）。

virtaul bus是一个比较新的bus，主要用来抽象那些虚拟设备，所谓的虚拟设备，是指不是真实的硬件设备，而是用软件模拟出来的设备，例如虚拟机中使用的虚拟的网络设备（有关该bus的描述，可参考该链接处的解释：https://lwn.net/Articles/326540/）。

platform bus就比较普通，它主要抽象集成在CPU（SOC）中的各种设备。这些设备直接和CPU连接，通过总线寻址和中断的方式，和CPU交互信息。 

我们会在后续的文章中，进一步分析这些特殊的bus，这里就暂时不详细描述了。
## platform设备驱动

platform设备驱动又叫平台设备驱动。在一个产品中，大量设备均直接属于片上系统（SOC、芯片），如UART、以太网、SPI等。

但是在 SOC 中有些外设是没有总线这个概念的，但是又要使用总线、驱动和设备模型框架，该怎么办呢？为了解决此问题，提出了 platform 这个虚拟总线，相应的就有 platform_driver 和 platform_device（一般平台设备被设备树替代，我们只需编写平台驱动）。

&gt; platform设备是被静态枚举而不是动态。它是一种框架，是一种虚拟总线。

# 设备树下的 LED 驱动实验

# 设备树下的platform驱动编写


&lt;!--more--
&gt;
</code></pre>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/01-%E4%B8%93%E4%B8%9A/" class="category-chain-item">01-专业</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>嵌入式Linux学习笔记-驱动开发篇</div>
      <div>http://lonlypan.com/2022/07/10/嵌入式Linux学习笔记-驱动开发篇/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>LonlyPan</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年7月10日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
              <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
              <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                <i class="iconfont icon-nc"></i>
              </span>
              </a>
            
              <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
              <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                <i class="iconfont icon-sa"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/07/10/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AF%87/" title="嵌入式Linux学习笔记-系统移植篇">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">嵌入式Linux学习笔记-系统移植篇</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/03/%E4%B8%BA%E4%BB%80%E4%B9%88-%E5%85%B3%E4%BA%8E%E5%9B%A0%E6%9E%9C%E5%85%B3%E7%B3%BB%E7%9A%84%E6%96%B0%E7%A7%91%E5%AD%A6%20/" title="为什么-关于因果关系的新科学 ">
                        <span class="hidden-mobile">为什么-关于因果关系的新科学 </span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.16/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"geH90Q7ihl9Si5Llagt8GcC2-MdYXbMMI","appKey":"fO2rYFt9wStdv0SX7C7omkal","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://geh90q7i.api.lncldglobal.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <i class="iconfont icon-copyright"> 2019-2022 |</i> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?f56279d43c733d547ea06f75f8e05d89";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  

  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
