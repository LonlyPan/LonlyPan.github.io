

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="LonlyPan">
  <meta name="keywords" content="LonlyPan个人站，LonlyPan，Lonly，致简，丢了幸福的猪，逍遥勿忘心安">
  
    <meta name="description" content="Ubuntu系统入门篇一、 基础概念嵌入式和单片机的区别较早的定义  英国电器工程师协会定义的： 嵌入式系统（Embedded System），是一种“完全嵌入受控器件内部，为特定应用而设计的专用计算机系统”。 行业定义： 以应用为中心，计算机技术为基础，软硬件可剪裁，适应应用系统对功能、成本、体积、可靠性、功耗严格要求的计算机系统。 个人总结：除PC外的所有带有程序，可独立工作的系统都是嵌入式">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式Linux学习笔记-精简版">
<meta property="og:url" content="http://lonlypan.com/2022/04/06/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%B2%BE%E7%AE%80%E7%89%88/index.html">
<meta property="og:site_name" content="LonlyPan个人站">
<meta property="og:description" content="Ubuntu系统入门篇一、 基础概念嵌入式和单片机的区别较早的定义  英国电器工程师协会定义的： 嵌入式系统（Embedded System），是一种“完全嵌入受控器件内部，为特定应用而设计的专用计算机系统”。 行业定义： 以应用为中心，计算机技术为基础，软硬件可剪裁，适应应用系统对功能、成本、体积、可靠性、功耗严格要求的计算机系统。 个人总结：除PC外的所有带有程序，可独立工作的系统都是嵌入式">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/嵌入式Linux学习笔记/1654315471941.png">
<meta property="article:published_time" content="2022-04-05T16:00:00.000Z">
<meta property="article:modified_time" content="2022-06-12T15:19:00.000Z">
<meta property="article:author" content="LonlyPan">
<meta property="article:tag" content="LonlyPan个人站，LonlyPan，Lonly，致简，丢了幸福的猪，逍遥勿忘心安">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/嵌入式Linux学习笔记/1654315471941.png">
  
  
  <title>嵌入式Linux学习笔记-精简版 - LonlyPan个人站</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"lonlypan.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":2},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"f56279d43c733d547ea06f75f8e05d89","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>LonlyPan的博客站</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/books/">
                <i class="iconfont icon-book"></i>
                书影
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                朋友
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="嵌入式Linux学习笔记-精简版"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-04-06 00:00" pubdate>
          2022年4月6日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          123k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          1029 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">嵌入式Linux学习笔记-精简版</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2022年6月12日 晚上
                  
                
              </p>
            
            <div class="markdown-body">
              
              <span id="more"></span>
<h1 id="Ubuntu系统入门篇"><a href="#Ubuntu系统入门篇" class="headerlink" title="Ubuntu系统入门篇"></a>Ubuntu系统入门篇</h1><h2 id="一、-基础概念"><a href="#一、-基础概念" class="headerlink" title="一、 基础概念"></a>一、 基础概念</h2><h3 id="嵌入式和单片机的区别"><a href="#嵌入式和单片机的区别" class="headerlink" title="嵌入式和单片机的区别"></a>嵌入式和单片机的区别</h3><p><strong>较早的定义</strong></p>
<ul>
<li><strong>英国电器工程师协会定义的：</strong> 嵌入式系统（Embedded System），是一种“完全嵌入受控器件内部，为特定应用而设计的专用计算机系统”。</li>
<li><strong>行业定义：</strong> 以应用为中心，计算机技术为基础，<strong>软硬件可剪裁，适应应用系统对功能、成本、体积、可靠性、功耗严格要求的计算机系统</strong>。</li>
<li><strong>个人总结</strong>：除PC外的所有带有程序，可独立工作的系统都是嵌入式系统，包含单片机</li>
</ul>
<p><strong>目前行业定义</strong></p>
<ul>
<li>行业中普遍将两者区分开来，依据则是从软件上进行区分。</li>
</ul>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1654947926414.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/22db60b9-1d64-4af5-832f-a0b661b7b1c9.png" srcset="/img/loading.gif" lazyload alt="22db60b9-1d64-4af5-832f-a0b661b7b1c9"></p>
<blockquote>
<p>CPU概念基本指中央处理器，微处理器都可以称为CPU<br>MPU，和SOC概念模糊，不做区分，认为是一个</p>
</blockquote>
<p><strong>参考资料</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/y4247464/p/12910642.html">CPU、MPU、MCU、SOC的区别（概念）</a></li>
<li><a target="_blank" rel="noopener" href="https://book.crifan.com/books/ic_chip_industry_chain_summary/website/ic_chip_summary/chip_names_compare.html">芯片名词对比</a></li>
<li><a target="_blank" rel="noopener" href="http://www.xzclass.com/?p=464">嵌入式和单片机，是同一个东西吗？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.eet-china.com/mp/a125116.html">嵌入式Linux和stm32区别?之间有什么关系吗？</a></li>
</ul>
<h4 id="MMU（内存管理单元）"><a href="#MMU（内存管理单元）" class="headerlink" title="MMU（内存管理单元）"></a>MMU（内存管理单元）</h4><p>没有MMU，CPU执行单元发出的内存地址将直接传到芯片引脚上，被内存芯片接收，这称为物理地址（Physical Address）：</p>
<p>有MMU，CPU执行单元发出的内存地址将被MMU截获，从CPU到MMU的地址称为虚拟地址（Virtual Address），而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上，也就是将虚拟地址映射成物理地址：</p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1652319855851.png" srcset="/img/loading.gif" lazyload alt="1652319855851"></p>
<p>处理器一般有用户模式（User Mode）和特权模式（privileged Mode）之分。当CPU要访问一个VA（Virtual Address）时，MMU会检查CPU当前处于用户模式还是特权模式，访问内存的目的是读数据、写数据还是取指令执行，如果与操作系统设定的权限相符，则允许访问，把VA转换成PA，否则不允许执行，产生异常（Exception）。</p>
<p><strong>参考资料</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/137061978">关于MMU那些事儿</a></li>
<li><a target="_blank" rel="noopener" href="https://www.eet-china.com/mp/a11350.html">用于MCU&#x2F;MPU的uCLinux与Linux有什么区别？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/alantu2018/p/9002309.html">arm-linux学习-（MMU内存管理单元）</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/354142930">MMU原理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/alantu2018/p/9002309.html">arm-linux学习-（MMU内存管理单元）</a></li>
</ul>
<h4 id="嵌入式软件"><a href="#嵌入式软件" class="headerlink" title="嵌入式软件"></a>嵌入式软件</h4><p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1652319626783.png" srcset="/img/loading.gif" lazyload alt="1652319626783"></p>
<p><strong>参考资料</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/53880054/answer/164501004">嵌入式linux 和 用stm32进行的嵌入式开发 这两者之间有什么关联性吗？</a></li>
</ul>
<h4 id="STM32是否可以跑linux"><a href="#STM32是否可以跑linux" class="headerlink" title="STM32是否可以跑linux"></a>STM32是否可以跑linux</h4><p>操作系统有两种 用MMU的 和 不用MMU的</p>
<ul>
<li>用MMU的是Windows MacOS Linux Android</li>
<li>不用MMU的是FreeRTOS VxWorks ucOS…</li>
</ul>
<p>CPU有两种 带MMU的 和 不带MMU的</p>
<ul>
<li>带MMU的有 Cortex-A系列 ARM9 ARM11系列</li>
<li>不带MMU的有 Cortex-M系列…</li>
</ul>
<p>STM32是M系列…不可能运行Linux…（ucLinux不算Linux的…）<br><strong>在开发环境、程序开发上也都有很大区别，基本算是两种开发模式</strong></p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/AI-Algorithms/p/3866586.html">STM32是否可以跑linux</a></li>
</ul>
<h3 id="什么是linux"><a href="#什么是linux" class="headerlink" title="什么是linux"></a>什么是linux</h3><p>区分linux内核和linux操作系统</p>
<ul>
<li>Linux严格来说是单指作业系统的内核。</li>
<li>如今Linux常用来指基于Linux的完整操作系统，内核则改以Linux内核称之。</li>
</ul>
<p>Linux内核由林纳斯·托瓦兹（Linus Torvalds）在1991年10月5日首次发布，在加上使用者空间的应用程序之后，成为Linux操作系统。除了一部分专家之外，大多数人都是直接使用Linux 发行版（Linux操作系统），而不是自己选择每一样组件或自行设置。</p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1652326905352.png" srcset="/img/loading.gif" lazyload alt="1652326905352"><br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1652320923467.png" srcset="/img/loading.gif" lazyload alt="1652320923467"></p>
<p><strong>参考资料：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-intro.html">Linux 简介</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/Linux">Linux-wiki</a></li>
</ul>
<h3 id="gcc编译"><a href="#gcc编译" class="headerlink" title="gcc编译"></a>gcc编译</h3><p>gcc编译器ubuntu自带，<code>gcc -v</code> 查看当前版本</p>
<p><code>gcc [选项] [文件名字]</code><br>选项如下：</p>
<ul>
<li>c： 只编译不链接为可执行文件，编译器将输入的.c 文件编译为.o 的目标文件。</li>
<li>o：编译成可执行文件，默认编译出来的可执行文件名字为 a.out。<br>+  &lt;输出文件名&gt;指定编译结束以后的输出文件名</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">gcc main.c –o main.out
./main.out
</code></pre>
<p>编译流程：</p>
<ol>
<li>预处理（Preprocessing）：.c 文件中的文件包含（include）、预处理语句（e.g. 宏定义 define 等）进行分析，并替换成为真正的内容。</li>
<li>编译（Compilation）：生成 .s 汇编文件。</li>
<li>汇编（Assembly）：.生成以 .o 的目标文件。</li>
<li>链接（Linking）：多个.o文件、库文件链接成一个文件，变成可执行文件。</li>
</ol>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1652338937644.png" srcset="/img/loading.gif" lazyload alt="1652338937644"></p>
<p>我们需要操作的步骤：.o 和可执行文件</p>
<h2 id="二、Ubuntu系统安装与使用"><a href="#二、Ubuntu系统安装与使用" class="headerlink" title="二、Ubuntu系统安装与使用"></a>二、Ubuntu系统安装与使用</h2><p>Ubuntu系统是基础linux内核的操作系统。就像开发电脑软件需要在win10系统上一样，我们之后的linux软件开发也需要在 Linux 系统上（即Ubuntu系统）<br><strong>本章内容：</strong><br>虚拟机安装 -&gt; 使用虚拟机安装ubuntu -&gt; ubuntu配置使用</p>
<h3 id="1-虚拟机安装"><a href="#1-虚拟机安装" class="headerlink" title="1. 虚拟机安装"></a>1. 虚拟机安装</h3><p>要想在windows系统安装 ubuntu ，就得借助虚拟机。这样就可以在电脑上同时存在两个操作系统，并且可以同时运行。</p>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>VirtualBox<a target="_blank" rel="noopener" href="http://download.virtualbox.org/virtualbox/">下载地址</a><br>选择你需要下载的版本 (32位系统请务必选择5.2)。这里我的是 64 位系统，选择最新版 （下图左半图红框）。单击进入文件选择界面（下图右半图）选择文件下载，其中一个是 VirtualBox 主体安装包，一个是 扩展包，扩展包必须和 VirtualBox 主体安装包版本保持一致（后缀140961也要一样）。</p>
<ul>
<li>扩展包提供了对USB 2.0、USB 3.0、远程桌面协议 VRDP（VirtualBox Remote Desktop Protocol）等实用功能的支持。但相关扩展包并非开源软件，而是在 VirtualBox Personal Use and Evaluation License (PUEL) 许可证限制下发布的软件，所以扩展包并未与 VirtulBox 安装文件集成在一起，而是需要单独下载和安装。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1654930130364.png" srcset="/img/loading.gif" lazyload alt="enter description here"></li>
</ul>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>上述两个文件下载完成后，先双击运行 <code>VirtualBox-6.1.16-140961-Win.exe</code> 安装VirtualBox。安装过程全程按照提示进行，点击下一步，遇到弹窗，点选 “是” 或 “安装” 即可。可以更改软件安装位置。<br>VirtualBox安装后。双击 <code>Oracle_VM_VirtualBox_Extension_Pack-6.1.16.vbox-extpack</code> 安装扩展包。（下图左半图）。安装完成后，运行 VirtualBox，在左上角 <code>管理</code> -&gt; <code>全局设定</code> -&gt; <code>扩展</code>，确认扩展包安装成功。</p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/VirtualBox_.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<h4 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h4><p>虚拟机，相当于一台虚拟的电脑，用于后面的 Ubuntu 操作系统安装。</p>
<ol>
<li><p>单击新建<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%B0%E5%BB%BA.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
</li>
<li><p>虚拟机配置<br><strong>名称：</strong> 随意<br><strong>文件夹：</strong> 存放虚拟机的配置文件，区别与存放Ubuntu操作系统的文件夹。随意。<br><strong>类型：</strong> Linux<br><strong>版本：</strong> Ubuntu（64-bit）<br><strong>内存大小：</strong> 一般是本机的一半，例如你电脑是16G内存，这里就选8G<br>勾选 <code>现在创建虚拟硬盘</code>，点击 <code>创建</code><br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%B0%E5%BB%BA1.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
</li>
<li><p>创建虚拟硬盘<br>建议单独创建一个电脑硬盘分区，且大小最好在100G以上，用来安装 LInux 操作系统，学习中可能会经常格式化。<br> <img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%8C%BA.png" srcset="/img/loading.gif" lazyload alt="enter description here"><br>虚拟硬盘文件类型：VDI<br>内存分配：固定大小。<br>文件位置和大小：文件位置就选择我们上面新建的分区，大小剩5-10G作用，用于存放我们的ubuntu映像文件（即.iso文件）<br>点击创建，配置完毕，等待软件自动创建完成。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%B0%E5%BB%BA2.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
</li>
<li><p>虚拟机创建完成的样子<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9B%E5%BB%BA%E5%AE%8C%E6%88%90.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
</li>
</ol>
<h3 id="2-Ubuntu安装"><a href="#2-Ubuntu安装" class="headerlink" title="2. Ubuntu安装"></a>2. Ubuntu安装</h3><ol start="0">
<li><p>修改启动顺序。设置 -&gt; 系统，将硬盘移到首位。不然会默认使用光驱启动，这会导致下面系统安装成功后会又进入系统安装界面。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%90%AF%E5%8A%A8%E9%A1%BA%E5%BA%8F.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
</li>
<li><p>下载 Ubuntu，进入<a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/ubuntu-releases/">Ubuntu 阿里云镜像下载</a>，下载 18.04.5 版。建议放在我们之前新建的磁盘分区中即E盘下，后面可能会涉及频繁重装系统，所以 iso 文件最好不要删。<br><strong>不推荐下载最新版，软件适配不足，bug较多。资料较少。还是下载老版本。–20201207<br>后面教程中版本都是 20.04.1（写教程时一开始使用的最新版，后面出现很多问题，亲身教训）。实际以 18.04.5 版本为准</strong><br> <img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ubuntu%E4%B8%8B%E8%BD%BD18.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
</li>
<li><p>点击<code>启动</code><br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9B%E5%BB%BA%E5%AE%8C%E6%88%90.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
</li>
<li><p>选择启动盘<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%89%E6%8B%A9iso.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
</li>
<li><p>点击注册，在弹出界面选择我们第一步下载好的 ISO 文件<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B3%A8%E5%86%8C.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
</li>
<li><p>点击选择<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%89%E6%8B%A9.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
</li>
<li><p>点击启动<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%90%AF%E5%8A%A8.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
</li>
<li><p>等待安装启动，语言选择 <code>English</code>（个人推荐，程序员应该拥抱英语），然后选择 <code>install Ubuntu</code></p>
<ul>
<li>选择英文，后面会涉及输入法无法写中文的问题，需要在系统中安装语言包。如果怕麻烦，这里可以选中文，安装时系统会自动安装。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%AD%E8%A8%80.png" srcset="/img/loading.gif" lazyload alt="enter description here"></li>
</ul>
</li>
<li><p>选择  <code>Nomal installation</code>，安装时更新（系统自带的软件更新）可以不勾选，安装时间会加长，建议勾选。点击继续。<br>安装类型选择 <code>擦除磁盘并安装</code>。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9B%B4%E6%96%B0.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
</li>
<li><p>写入磁盘。弹窗里点击继续。<br>时区正常选择中国时区就可以，继续<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%A7%E7%BB%AD.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
</li>
<li><p>设置用户名和密码。又图是其会出现的位置。最常用的是用户名和密码，这个在命令终端中操作会经常输入，所有尽量简单短小。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF2.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
</li>
<li><p>接下来就是漫长的安装过长，我这里大概用了2小时。出现下面弹窗表示安装完成，点击重新启动即可。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%83%8F_25.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
</li>
</ol>
<p><strong>参考资料</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://askubuntu.com/questions/1230102/drag-and-drop-not-working-for-ubuntu-20-04-virtualbox">Drag and Drop not working for Ubuntu 20.04 VirtualBox</a></li>
<li><a target="_blank" rel="noopener" href="https://www.linux.org/threads/virtualbox-ubuntu-20-04-lts-super-buggy.29161/">VirtualBox Ubuntu 20.04 LTS super buggy</a></li>
</ul>
<h3 id="3-Ubuntu配置"><a href="#3-Ubuntu配置" class="headerlink" title="3. Ubuntu配置"></a>3. Ubuntu配置</h3><h4 id="增强扩展功能"><a href="#增强扩展功能" class="headerlink" title="增强扩展功能"></a>增强扩展功能</h4><p>安装增强扩展功能。解决以下问题：</p>
<ul>
<li>更改屏幕分辨率，解决显示界面太小问题</li>
<li>本地电脑和虚拟机电脑文件共享</li>
<li>剪贴板共享等等等等</li>
</ul>
<ol>
<li>设备-&gt;安装增强功能<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A2%9E%E5%BC%BA%E8%AE%BE%E5%A4%87.png" srcset="/img/loading.gif" lazyload alt="增强设备"></li>
<li>弹窗点击 <code>Run</code>，输入密码。（数字小键盘关闭可能会无法输入。）<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85%E7%A1%AE%E8%AE%A4.png" srcset="/img/loading.gif" lazyload alt="安装确认"></li>
<li>不出意外的话，会出现下左图的安装失败。我们需要打开终端，并输入<br><code>sudo apt-get install build-essential gcc make perl dkms</code><br>等待系统自动安装，再重新安装增强功能。直到出现下右图表示安装成功。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wenti.png" srcset="/img/loading.gif" lazyload alt="enter description here"><br>安装失败后，桌面会多出一个 iso 文件，双击打开，点击运行，就可以直接安装增强功能，不用再从菜单栏选择了。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%90%E8%A1%8C.png" srcset="/img/loading.gif" lazyload alt="enter description here"></li>
<li>关闭虚拟机，在virtualbox主界面打开 <code>设置</code>：<br><code>常规</code>-&gt;<code>高级</code>：<strong>共享剪切板</strong> 和 <strong>拖拽</strong>都 选择 <strong>双向</strong><br><code>存储</code>-&gt;<code>控制器SATA</code>：勾选 <strong>使用主机输入输出(I&#x2F;O)缓存</strong><br><code>存储</code>-&gt;<code>控制器SATA</code>-&gt;<code>Ubuntu-Embeded.vdi</code>：勾选 <strong>固态驱动器</strong><br>启动虚拟机。此时就可以直接从 Windows 系统窗口拖动文件到 Linux 界面了。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E7%BD%AEcopy.png" srcset="/img/loading.gif" lazyload alt="enter description here"></li>
<li>更改分辨率。在设置里找到系统设置，选择合适的屏幕分辨率即可。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E8%BE%A8%E7%8E%87.png" srcset="/img/loading.gif" lazyload alt="enter description here"></li>
</ol>
<p><strong>参考链接</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=V4tGpsZiOdw">Install guest additions on a VirtualBox</a></li>
<li><h4 id="软件和更新源"><a href="#软件和更新源" class="headerlink" title="软件和更新源"></a>软件和更新源</h4></li>
</ul>
<p>Ubuntu 使用 apt 进行软件包安装管理，默认情况下其使用国外的软件源进行软件包的下载&#x2F;安装&#x2F;更新等操作。而由于不可抗力，这些下载操作可能会很慢。此时可以采用国内的镜像软件源替换 Ubuntu 的默认软件源，提高软件更新下载速度。</p>
<ol>
<li>打开 Software&amp;Updates -&gt; Ubuntu Software,其界面有个 Download from 项，找到 China 项，会有很多源，选择其中一个即可。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%8B%E8%BD%BD%E6%BA%90.png" srcset="/img/loading.gif" lazyload alt="enter description here"></li>
</ol>
<p><strong>参考资料</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yhjoker/p/12813423.html">Ubuntu18.04 设置国内镜像软件源进行软件下载&#x2F;更新</a></li>
</ul>
<h4 id="U盘支持"><a href="#U盘支持" class="headerlink" title="U盘支持"></a>U盘支持</h4><p>我们也希望能在 LInux 系统中读取电脑上的 usb 设备。此时就发挥我们之前安装的扩展包作用了。</p>
<ul>
<li>这里实测，不安装扩展包，也是可以使用 usb3.0 的hub识别usb2.0读卡器读写SD卡</li>
</ul>
<ol>
<li>关闭虚拟机，virtualbox主界面打开 <code>设置</code> -&gt; <code>USB设备</code>，勾选USB 3.0。并将USB设备添加进来（只有添加进这里的才能在虚拟机中被识别到）。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/USB.png" srcset="/img/loading.gif" lazyload alt="enter description here"></li>
<li>打开虚拟机，一般会自动加载设备（左下角两个设备图标），直接双击即可打开。如果没有：<code>设备</code>-&gt;<code>USB</code>，单击USB设备名字，将完成设备加载。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%89%93%E5%BC%80usb.png" srcset="/img/loading.gif" lazyload alt="enter description here"></li>
<li>移除设备，右键左下角设备图标，单击 <code>Eject</code> 弹出；或者虚拟机右下角，右键U盘图标，单击设备名弹出<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%B9%E5%87%BAusb.png" srcset="/img/loading.gif" lazyload alt="enter description here"></li>
</ol>
<p><strong>参考链接</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.tecmint.com/enable-usb-in-virtualbox/">How to Enable USB in VirtualBox</a></li>
</ul>
<h4 id="图标对齐"><a href="#图标对齐" class="headerlink" title="图标对齐"></a>图标对齐</h4><p>虽然LInux基本都是命令行操作，但桌面有时也会偶尔存放东西。默认拖动到桌面的文件图标会堆叠在一起，不像 Windows 或自动整理、对齐。其实这里需要我们自己选择。在桌面右键：</p>
<ul>
<li>keep aligned：保持对齐</li>
<li>Organize Desktop by Name：按名称排序桌面<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/keep_aligned.png" srcset="/img/loading.gif" lazyload alt="enter description here"></li>
</ul>
<h4 id="锁屏"><a href="#锁屏" class="headerlink" title="锁屏"></a>锁屏</h4><p>Ubuntu默认5分钟自动锁屏，我们希望永不锁屏，打开设置界面，找到<code>Power</code>,设置自己的时间即可。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%81%E5%B1%8F.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://zsxwz.com/2020/01/27/virtualbox%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">virtualbox虚拟机使用教程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.xckjsys.com/2019/08/20/154/">Oracle VM VirtualBox 使用教程(Windows操作系统下)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ubuntukylin.com/news/1513-cn.html">优麒麟使用教程第二期：VirtualBox 虚拟机安装</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/111567471">win10虚拟机Oracle VM VirtualBox安装和使用教程</a></li>
<li><a target="_blank" rel="noopener" href="http://learn.openwaterfoundation.org/owf-learn-virtualbox/install-host/win/file-locations/">虚拟框 &#x2F; Windows 10 主机 &#x2F; 文件位置</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43350051/article/details/104874088">一张图搞懂Ubuntu安装时姓名、计算机名、用户名</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35619204">https://zhuanlan.zhihu.com/p/35619204</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/796866e933e1">https://www.jianshu.com/p/796866e933e1</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022468063">https://segmentfault.com/a/1190000022468063</a></li>
<li><a target="_blank" rel="noopener" href="https://www.codeleading.com/article/61115145053/">https://www.codeleading.com/article/61115145053/</a></li>
</ul>
<h2 id="三、Ubuntu系统入门"><a href="#三、Ubuntu系统入门" class="headerlink" title="三、Ubuntu系统入门"></a>三、Ubuntu系统入门</h2><h3 id="shell命令"><a href="#shell命令" class="headerlink" title="shell命令"></a>shell命令</h3><ul>
<li><p>命令区分大小写</p>
</li>
<li><p>查询一个命令：man xx 或者 xx –help</p>
</li>
<li><p><code>q</code> 键退出当前操作</p>
</li>
<li><p>* 为通配符</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.linuxcool.com/">Linux命令大全(手册)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全</a></p>
</li>
</ul>
<h4 id="重复执行上条命令的-4-种方法："><a href="#重复执行上条命令的-4-种方法：" class="headerlink" title="重复执行上条命令的 4 种方法："></a>重复执行上条命令的 4 种方法：</h4><ul>
<li>使用上方向键，并回车执行。（推荐）</li>
<li>按 Ctrl+P 并回车执行。（备选，有的命令上下键会没有，这个绝对会有）</li>
<li>按 !! 并回车执行。</li>
<li>输入 !-1 并回车执行。</li>
<li>!$ 使用上一个命令的参数</li>
</ul>
<p><strong>参考链接</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nenew.net/linux-shell-rerun-command.html">Linux系统下Shell重复执行上条命令的几种方法</a></li>
</ul>
<h4 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd 切换目录"></a>cd 切换目录</h4><p><code>changeDirectorym</code>，这是一个非常基本、经常需要使用的命令，它用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径。如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /root/Docements <span class="hljs-comment"># 切换到目录/root/Docements</span><br><span class="hljs-built_in">cd</span> ./path          <span class="hljs-comment"># 切换到当前目录下的path目录中，可省略 &quot;./&quot; </span><br><span class="hljs-built_in">cd</span> ../path         <span class="hljs-comment"># 切换到上层目录中的path目录中，</span><br><span class="hljs-built_in">cd</span> ~             <span class="hljs-comment"># 进入用户目录，打开终端时默认路径，=  cd/home/用户名，home 为各个用户存放位置</span><br><span class="hljs-built_in">cd</span> -     <span class="hljs-comment">#进入上一次工作路径</span><br><span class="hljs-built_in">cd</span> /    <span class="hljs-comment"># 进入根目录,只紧跟cd时 &quot;/&quot;表示根目录下，其他目录时表示当前目录下</span><br><span class="hljs-built_in">pwd</span>    <span class="hljs-comment"># 查看位置的绝对路径，可以用这个对比`cd ~`和`cd / `的区别</span><br></code></pre></td></tr></table></figure>
<ul>
<li>“.” 表示当前目录 ，其实就是使用 “.” 代替了当前目录的目录名</li>
<li>“..” 表示上一层目录</li>
<li>“&#x2F;“ 在首位表示根目录，其它位置后面表示其目录下<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">lonly<span class="hljs-symbol">@lonly</span>-VirtualBox:~$ cd ~<br>lonly<span class="hljs-symbol">@lonly</span>-VirtualBox:~$ cd /  <span class="hljs-meta"># 默认用户目录 <span class="hljs-string">&#x27;$&#x27;</span> 为 <span class="hljs-string">&#x27;~&#x27;</span> 符号</span><br>lonly<span class="hljs-symbol">@lonly</span>-VirtualBox:/$   <span class="hljs-meta"># 根目录 <span class="hljs-string">&#x27;$&#x27;</span> 为 <span class="hljs-string">&#x27;/&#x27;</span> 符号</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="ls-查看文件与目录"><a href="#ls-查看文件与目录" class="headerlink" title="ls 查看文件与目录"></a>ls 查看文件与目录</h4><p><code>list</code> ，查看文件与目录的命令，它的参数非常多，下面就列出一些我常用的参数吧，如下：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-a：列出目录所有文件，包含以.开始的隐藏文件</span><br><span class="hljs-deletion">-A：列出除.及..的其它文件</span><br><span class="hljs-deletion">-l：除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</span><br><span class="hljs-deletion">-d：仅列出目录本身，而不是列出目录的文件数据</span><br><span class="hljs-deletion">-r：反序排列</span><br><span class="hljs-deletion">-t：以文件修改时间排序</span><br><span class="hljs-deletion">-S：以文件大小排序</span><br><span class="hljs-deletion">-h：将文件容量以较易读的方式（GB，kB等）列出来</span><br><span class="hljs-deletion">-R：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来</span><br></code></pre></td></tr></table></figure>
<h4 id="uname-显示系统相关信息"><a href="#uname-显示系统相关信息" class="headerlink" title="uname 显示系统相关信息"></a>uname 显示系统相关信息</h4><p><code>Unix name</code>，用于显示系统相关信息，比如主机名、内核版本号、硬件架构等。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-a：显示系统所有相关信息</span><br><span class="hljs-deletion">-m：显示计算机硬件架构</span><br><span class="hljs-deletion">-n：显示主机名称</span><br><span class="hljs-deletion">-r：显示内核发行版本号</span><br><span class="hljs-deletion">-s：显示内核名称</span><br><span class="hljs-deletion">-v：显示内核版本</span><br><span class="hljs-deletion">-p：显示主机处理器类型</span><br><span class="hljs-deletion">-o：显示操作系统名称</span><br><span class="hljs-deletion">-i：显示硬件平台</span><br></code></pre></td></tr></table></figure>
<h4 id="clear-清除屏幕"><a href="#clear-清除屏幕" class="headerlink" title="clear 清除屏幕"></a>clear 清除屏幕</h4><p>clear命令用于清除屏幕。这个命令将会刷新屏幕，本质上只是让终端显示页向后翻了一页，如果向上滚动屏幕还可以看到之前的操作信息。</p>
<h4 id="cat-查看文本"><a href="#cat-查看文本" class="headerlink" title="cat 查看文本"></a>cat 查看文本</h4><p>该命令用于查看文本文件的内容，后接要查看的文件名<br><code>cat [参数] [文件]</code></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-n：显示行数（空行也编号）</span><br><span class="hljs-deletion">-s：显示行数（多个空行算一个编号）</span><br><span class="hljs-deletion">-b：显示行数（空行不编号）</span><br><span class="hljs-deletion">-E：每行结束处显示$符号</span><br></code></pre></td></tr></table></figure>

<h4 id="sudo-超级用户"><a href="#sudo-超级用户" class="headerlink" title="sudo 超级用户"></a>sudo 超级用户</h4><p>允许一个已授权用户以超级用户或者其它用户的角色运行一个命令。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-l 列出目前的权限</span><br><br></code></pre></td></tr></table></figure>
<p><strong>举例：</strong><br><code>sudo xxx指令 # 以超级用户（管理员）执行该指令，临时切换当前身份  </code><br><code>sudo su # 切换身份为超级用户（永久），不建议这么做，可能会误删除一些系统核心文件，导致系统崩溃</code></p>
<h4 id="cp-复制文件"><a href="#cp-复制文件" class="headerlink" title="cp 复制文件"></a>cp 复制文件</h4><p><code>copy</code>，该命令用于复制文件，它还可以把多个文件一次性地复制到一个目录下， 常用参数如下：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。</span><br><span class="hljs-deletion">-f：覆盖已经存在的目标文件而不给出提示。</span><br><span class="hljs-deletion">-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答&quot;y&quot;时目标文件将被覆盖。默认方式</span><br><span class="hljs-deletion">-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</span><br><span class="hljs-deletion">-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</span><br><span class="hljs-deletion">-l：不复制文件，只是生成链接文件。</span><br><span class="hljs-deletion">-u：目标文件与源文件有差异时才会复制</span><br><span class="hljs-deletion">-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于上面dpr参数组合。</span><br><br></code></pre></td></tr></table></figure>
<p><strong>举例：</strong><br><code>cp -a file1 file2 #连同文件的所有特性把文件file1复制成文件file2</code><br><code>cp file1 file2 file3 dir #把文件file1、file2、file3复制到目录dir中，以默认 &quot;-i&quot; 方式</code></p>
<h4 id="touch-创建新的空文件"><a href="#touch-创建新的空文件" class="headerlink" title="touch 创建新的空文件"></a>touch 创建新的空文件</h4><p>touch命令有两个功能：一是创建新的空文件，二是改变已有文件的时间戳属性。<br>touch命令会根据当前的系统时间更新指定文件的访问时间和修改时间。如果文件不存在，将会创建新的空文件，除非指定了”-c”或”-h”选项。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-a：改变档案的读取时间记录</span><br><span class="hljs-deletion">-m：改变档案的修改时间记录</span><br><span class="hljs-deletion">-r:	使用参考档的时间记录，与 --file 的效果一样</span><br><span class="hljs-deletion">-c:	不创建新文件</span><br><span class="hljs-deletion">-d:	设定时间与日期，可以使用各种不同的格式</span><br><span class="hljs-deletion">-t:	设定档案的时间记录，格式与 date 命令相同</span><br><span class="hljs-deletion">--no-create: 不创建新文件</span><br></code></pre></td></tr></table></figure>

<h4 id="rm-删除文件或目录"><a href="#rm-删除文件或目录" class="headerlink" title="rm 删除文件或目录"></a>rm 删除文件或目录</h4><p><code>remove</code>，该命令用于删除文件或目录，它的常用参数如下：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-f：就是force的意思，忽略不存在的文件，不会出现警告消息</span><br><span class="hljs-deletion">-i：互动模式，在删除前会询问用户是否操作</span><br><span class="hljs-deletion">-r：递归删除，最常用于目录删除，它是一个非常危险的参数</span><br></code></pre></td></tr></table></figure>
<p><strong>举例：</strong><br><code>rm -i file # 删除文件file，在删除之前会询问是否进行该操作</code><br><code>rm -fr dir # 强制删除目录dir中的所有文件</code></p>
<h4 id="mkdir-创建目录"><a href="#mkdir-创建目录" class="headerlink" title="mkdir 创建目录"></a>mkdir 创建目录</h4><p><code>make directories</code>创建目录。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-p:	递归创建多级目录</span><br><span class="hljs-deletion">-m:	建立目录的同时设置目录的权限</span><br><span class="hljs-deletion">-z:	设置安全上下文</span><br><span class="hljs-deletion">-v:	显示目录的创建过程</span><br></code></pre></td></tr></table></figure>
<p><strong>实例</strong><br><code>mkdir test  # 创建名为 test 的目录</code><br><code>mkdir dir1 dir2 dir3 # 同时创建子目录dir1，dir2，dir3</code><br><code>mkdir -p linuxcool/dir # 同时创建目录linuxcool，并在linuxcool目录下创建子目录dir</code></p>
<h4 id="rmdir-删除空目录"><a href="#rmdir-删除空目录" class="headerlink" title="rmdir 删除空目录"></a>rmdir 删除空目录</h4><p><code>remove directory</code>，删除空的目录<br><strong>注意：</strong> rmdir命令只能删除空目录。当要删除非空目录时，就要使用带有 “-r” 选项的rm命令。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">-<span class="hljs-selector-tag">p</span>:	用递归的方式删除指定的目录路径中的所有父级目录，非空则报错<br></code></pre></td></tr></table></figure>


<h4 id="mv-移动文件"><a href="#mv-移动文件" class="headerlink" title="mv 移动文件"></a>mv 移动文件</h4><p><code>move</code>，用于移动文件、目录或更名，常用参数如下：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-f：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖</span><br><span class="hljs-deletion">-i：若目标文件已经存在，就会询问是否覆盖</span><br><span class="hljs-deletion">-u：若目标文件已经存在，且比目标文件新，才会更新</span><br></code></pre></td></tr></table></figure>

<p>注：该命令可以把一个文件或多个文件一次移动一个文件夹中，但是最后一个目标文件一定要是“目录”。</p>
<p><strong>实例：</strong><br><code>mv file1 file2 file3 dir # 把文件file1、file2、file3移动到目录dir中</code><br><code>mv file1 file2 # 把文件file1重命名为file2</code><br><code>mv test/ test1/ # 重命名文件夹</code><br><code>mv a.c test1/ # 将 a.c 移动到 test1 文件夹下</code></p>
<h4 id="ifconfig-网络配置"><a href="#ifconfig-网络配置" class="headerlink" title="ifconfig 网络配置"></a>ifconfig 网络配置</h4><p><code>network interfaces configuring</code>，配置和显示Linux内核中网络接口的网络参数。用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">ifconfig 查看网络配置<br><span class="hljs-meta">down</span>	关闭指定的网络设备<br><span class="hljs-meta">up</span>	启动指定的网络设备<br>reload 重启网络设备<br><span class="hljs-built_in">IP</span>地址	指定网络设备的<span class="hljs-built_in">IP</span>地址<br></code></pre></td></tr></table></figure>


<h4 id="reboot-重启"><a href="#reboot-重启" class="headerlink" title="reboot 重启"></a>reboot 重启</h4><p>用于用来重新启动计算机，和Windows系统中的restart一样。但是机器重启必须要root用户才有权限。</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">-<span class="hljs-built_in">n</span>	在重开机前不做将记忆体资料写回硬盘的动作 帮助<br>-w 	并不会真的重开机，只是把记录写到 /<span class="hljs-built_in">var</span>/<span class="hljs-built_in">log</span>/wtmp 档案里，模拟重开机<br>-d	不把记录写到 /<span class="hljs-built_in">var</span>/<span class="hljs-built_in">log</span>/wtmp 档案里（-<span class="hljs-built_in">n</span> 这个参数包含了 -d）<br>-f	强迫重开机，不呼叫 shutdown 这个指令<br>-i	在重开机之前先把所有网络相关的装置先停止<br></code></pre></td></tr></table></figure>

<h4 id="poweroff-断电"><a href="#poweroff-断电" class="headerlink" title="poweroff 断电"></a>poweroff 断电</h4><p>关闭计算机操作系统并且切断系统电源。如果确认系统中已经没有用户存在且所有数据都已保存，需要立即关闭系统，可以使用poweroff命令。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-n: 在关机前不做将记忆体资料写回硬盘的动作（部分数据可能会丢失）</span><br><span class="hljs-deletion">-w : 并不会真的关机，只是把记录写到 /var/log/wtmp 档案里</span><br><span class="hljs-deletion">-d : 不把记录写到 /var/log/wtmp 文件里</span><br><span class="hljs-deletion">-f	强制关闭操作系统</span><br><span class="hljs-deletion">-i : 在关机之前先把所有网络相关的装置先停止</span><br><span class="hljs-deletion">-h: 关闭操作系统之前将系统中所有的硬件设置为备用模式（standby节电模式）。</span><br></code></pre></td></tr></table></figure>

<h4 id="sync-数据同步"><a href="#sync-数据同步" class="headerlink" title="sync 数据同步"></a>sync 数据同步</h4><p> 在Linux&#x2F;Unix系统中，在文件或数据处理过程中一般先放到内存缓冲区中，等到适当的时候再写入磁盘，以提高系统的运行效率。<br>sync命令则可用来强制将内存缓冲区中的数据立即写入磁盘中。用户通常不需执行sync命令，系统会自动执行update或bdflush操作，将缓冲区的数据写 入磁盘。只有在update或bdflush无法执行或用户需要非正常关机时，才需手动执行sync命令。</p>
<h4 id="find-查找文件"><a href="#find-查找文件" class="headerlink" title="find 查找文件"></a>find 查找文件</h4><p>find是一个基于查找的功能非常强大的命令，相对而言，它的使用也相对较为复杂，参数也比较多，所以在这里将给把它们分类列出，它的基本语法如下：<br><code>find [PATH] [option] [action]</code></p>
<p><strong>与时间有关的参数：</strong></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">-mtime <span class="hljs-built_in">n</span> <span class="hljs-symbol">:</span> <span class="hljs-built_in">n</span>为数字，意思为在<span class="hljs-built_in">n</span>天之前的“一天内”被更改过的文件；<br>-mtime +<span class="hljs-built_in">n</span> <span class="hljs-symbol">:</span> 列出在<span class="hljs-built_in">n</span>天之前（不含<span class="hljs-built_in">n</span>天本身）被更改过的文件名；<br>-mtime -<span class="hljs-built_in">n</span> <span class="hljs-symbol">:</span> 列出在<span class="hljs-built_in">n</span>天之内（含<span class="hljs-built_in">n</span>天本身）被更改过的文件名；<br>-newer file <span class="hljs-symbol">:</span> 列出比file还要新的文件名<br></code></pre></td></tr></table></figure>
<p>例如：<br><code>find ./ -mtime 0 # 在当前目录下查找今天之内有改动的文件</code></p>
<p><strong>与用户或用户组名有关的参数：</strong></p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">-<span class="hljs-keyword">user</span> <span class="hljs-title">name</span> : 列出文件所有者为name的文件<br>-<span class="hljs-keyword">group</span> <span class="hljs-title">name</span> : 列出文件所属用户组为name的文件<br>-uid n : 列出文件所有者为用户ID为n的文件<br>-gid n : 列出文件所属用户组为用户组ID为n的文件<br></code></pre></td></tr></table></figure>
<p>例如：<br><code>find /home/lonly -user lonly # 在目录/home/ljianhui中找出所有者为ljianhui的文件</code></p>
<p><strong>与文件权限及名称有关的参数：</strong></p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dos">-name filename ：找出文件名为filename的文件<br>-size [+-]SIZE ：找出比SIZE还要大（+）或小（-）的文件<br>-tpye <span class="hljs-built_in">TYPE</span> ：查找文件的类型为<span class="hljs-built_in">TYPE</span>的文件，<span class="hljs-built_in">TYPE</span>的值主要有：一般文件（f)、设备文件（b、c）、<br>             目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）；<br>-perm <span class="hljs-built_in">mode</span> ：查找文件权限刚好等于<span class="hljs-built_in">mode</span>的文件，<span class="hljs-built_in">mode</span>用数字表示，如<span class="hljs-number">0755</span>；<br>-perm -<span class="hljs-built_in">mode</span> ：查找文件权限必须要全部包括<span class="hljs-built_in">mode</span>权限的文件，<span class="hljs-built_in">mode</span>用数字表示<br>-perm +<span class="hljs-built_in">mode</span> ：查找文件权限包含任一<span class="hljs-built_in">mode</span>的权限的文件，<span class="hljs-built_in">mode</span>用数字表示<br></code></pre></td></tr></table></figure>
<p>例如：<br><code>find / -name passwd # 查找文件名为passwd的文件</code><br><code>find ./ -name &#39;*.log&#39; # 在当前目录查找 以 .log 结尾的文件。 . 代表当前目录</code><br><code>find . -perm 0755 # 查找当前目录中文件权限的0755的文件</code><br><code>find . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte</code></p>
<h4 id="grep查找内容"><a href="#grep查找内容" class="headerlink" title="grep查找内容"></a>grep查找内容</h4><p><code>global search regular expression and print out the line</code>，用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。</p>
<p>grep命令的选项用于对搜索过程的补充，而其命令的模式十分灵活，可以是变量、字符串、正则表达式。需要注意的是：当模式中包含了空格，务必要用双引号将其引起来。<br><code>grep [参数][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...]</code></p>
<p>它的常用参数如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">-<span class="hljs-selector-tag">b</span> 或 <span class="hljs-attr">--byte-offset</span> : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。<br>-e&lt;范本样式&gt; 或 <span class="hljs-attr">--regexp</span>=&lt;范本样式&gt; : 指定字符串做为查找文件内容的样式。<br>-f&lt;规则文件&gt; 或 <span class="hljs-attr">--file</span>=&lt;规则文件&gt; : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。<br>-h 或 <span class="hljs-attr">--no-filename</span> : 在显示符合样式的那一行之前，不标示该行所属的文件名称。<br>-<span class="hljs-selector-tag">i</span> 或 <span class="hljs-attr">--ignore-case</span> : 忽略字符大小写的差别。<br>-l 或 <span class="hljs-attr">--file-with-matches</span> : 列出文件内容符合指定的样式的文件名称。<br>-n 或 <span class="hljs-attr">--line-number</span> : 在显示符合样式的那一行之前，标示出该行的列数编号。<br>-r 或 <span class="hljs-attr">--recursive</span> : 定要查找的是目录而非文件<br>-v 或 <span class="hljs-attr">--invert-match</span> : 显示不包含匹配文本的所有行。<br>-w 或 <span class="hljs-attr">--word-regexp</span> : 匹配整词<br>-x <span class="hljs-attr">--line-regexp</span> : 	匹配整行<br></code></pre></td></tr></table></figure>
<p><strong>实例</strong>  </p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ grep test test* <span class="hljs-meta"># 在当前目录中,查找文件名前缀有“test”的文件中含“test”字符串所在行信息</span><br><span class="hljs-symbol">testfile1:</span>This a Linux testfile! <span class="hljs-meta"># 列出testfile1 文件中包含test字符的行  </span><br><span class="hljs-symbol">testfile_2:</span>This is a linux testfile! <span class="hljs-meta"># 列出testfile_2 文件中包含test字符的行  </span><br><span class="hljs-symbol">testfile_2:</span>Linux test <span class="hljs-meta"># 列出testfile_2 文件中包含test字符的行 </span><br></code></pre></td></tr></table></figure>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ grep -r update <span class="hljs-regexp">/etc/</span>acpi <span class="hljs-comment"># 查找指定目录/etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串&quot;update&quot;的文件，并打印出该字符串所在行的内容</span><br><span class="hljs-regexp">/etc/</span>acpi<span class="hljs-regexp">/ac.d/</span><span class="hljs-number">85</span>-anacron.sh:<span class="hljs-comment"># (Things like the slocate updatedb cause a lot of IO.)  </span><br>Rather than  <br><span class="hljs-regexp">/etc/</span>acpi<span class="hljs-regexp">/resume.d/</span><span class="hljs-number">85</span>-anacron.sh:<span class="hljs-comment"># (Things like the slocate updatedb cause a lot of  </span><br>IO.) Rather than  <br><span class="hljs-regexp">/etc/</span>acpi<span class="hljs-regexp">/events/</span>thinkpad-cmos:action=<span class="hljs-regexp">/usr/</span>sbin/thinkpad-keys--update <br></code></pre></td></tr></table></figure>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ grep-v test* <span class="hljs-meta">#查找文件名中包含test 的文件中不包含test 的行  </span><br><span class="hljs-symbol">testfile1:</span>helLinux!  <br><span class="hljs-symbol">testfile1:</span>Linis a free Unix-type operating system.  <br><span class="hljs-symbol">testfile1:</span>Lin  <br><span class="hljs-symbol">testfile_1:</span>HELLO LINUX!  <br>...<br></code></pre></td></tr></table></figure>
<h4 id="du-查看文件大小"><a href="#du-查看文件大小" class="headerlink" title="du 查看文件大小"></a>du 查看文件大小</h4><p><code>Disk Usage</code>，即用于查看磁盘占用空间的意思。但是与df命令不同的是du命令是对文件和目录磁盘使用的空间的查看，而不是某个分区。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-a	显示目录中所有文件大小</span><br><span class="hljs-deletion">-k	以KB为单位显示文件大小</span><br><span class="hljs-deletion">-m	以MB为单位显示文件大小</span><br><span class="hljs-deletion">-g	以GB为单位显示文件大小</span><br><span class="hljs-deletion">-h	以易读方式显示文件大小，根据磁盘容量自动变换合适的单位</span><br><span class="hljs-deletion">-s	仅显示总计</span><br></code></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">du</span> log2012.log  <span class="hljs-comment"># 显示指定文件所占空间 ：</span><br><span class="hljs-built_in">du</span> -h scf/  <span class="hljs-comment"># 以易读方式显示文件夹内及子文件夹大小 ：</span><br></code></pre></td></tr></table></figure>

<h4 id="df-可使用的磁盘空间"><a href="#df-可使用的磁盘空间" class="headerlink" title="df 可使用的磁盘空间"></a>df 可使用的磁盘空间</h4><p><code>Disk Free</code>，用于显示系统上可使用的磁盘空间。默认显示单位为KB，建议使用“df -h”的参数组合，根据磁盘容量自动变换合适的单位，更利于阅读。<br>日常普遍用该命令可以查看磁盘被占用了多少空间、还剩多少空间等信息。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-a	显示所有系统文件</span><br><span class="hljs-deletion">-h	以容易阅读的方式显示</span><br><span class="hljs-deletion">-i	显示索引字节信息</span><br><span class="hljs-deletion">-k	指定块大小为1KB</span><br><span class="hljs-deletion">-m  以 MBytes 的容量显示各文件系统；</span><br></code></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[root@linuxcool ~]# df <span class="hljs-regexp">/etc/</span>dhcp  # 显示指定文件所在分区的磁盘使用情况<br>文件系统                             <span class="hljs-number">1</span>K-块    已用     可用   已用% 挂载点<br><span class="hljs-regexp">/dev/m</span>apper<span class="hljs-regexp">/fedora_linuxcool-root 15718400 2040836 13677564   13% /</span><br></code></pre></td></tr></table></figure>

<h4 id="gedit-官方文本编辑器"><a href="#gedit-官方文本编辑器" class="headerlink" title="gedit 官方文本编辑器"></a>gedit 官方文本编辑器</h4><p>gedit命令是GNOME桌面环境的官方文本编辑器，尽管gedit旨在简化和易用，但它是功能强大的通用文本编辑器；它可以用来创建和编辑各种文本文件。和 notepad 类似。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">--list-encodings	显示可使用的编码选项列表</span><br><span class="hljs-deletion">--encoding=编码	设置打开命令行中列出的文件时使用的字符编码</span><br><span class="hljs-deletion">-w	以独占方式打开文件直到文件关闭</span><br><span class="hljs-deletion">-s	以独立模式运行gedit</span><br></code></pre></td></tr></table></figure>

<h4 id="ps-显示当前系统的进程状态"><a href="#ps-显示当前系统的进程状态" class="headerlink" title="ps 显示当前系统的进程状态"></a>ps 显示当前系统的进程状态</h4><p><code>process status</code>，显示当前系统的进程状态。可以搭配 <code>kill</code> 指令随时中断、删除不必要的程序。</p>
<p>ps命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-A ：所有的进程均显示出来</span><br><span class="hljs-deletion">-a ：不与terminal有关的所有进程</span><br><span class="hljs-deletion">-u ：有效用户的相关进程</span><br><span class="hljs-deletion">-x ：一般与a参数一起使用，可列出较完整的信息</span><br><span class="hljs-deletion">-l ：较长，较详细地将PID的信息列出</span><br></code></pre></td></tr></table></figure>
<p>其实我们只要记住ps一般使用的命令参数搭配即可，它们并不多，如下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">ps</span> aux <span class="hljs-comment"># 查看系统所有的进程数据</span><br><span class="hljs-built_in">ps</span> ax <span class="hljs-comment"># 查看不与terminal有关的所有进程</span><br><span class="hljs-built_in">ps</span> <span class="hljs-literal">-lA</span> <span class="hljs-comment"># 查看系统所有的进程数据</span><br><span class="hljs-built_in">ps</span> axjf <span class="hljs-comment"># 查看连同一部分进程树状态</span><br></code></pre></td></tr></table></figure>


<h4 id="kill-删除执行中的程序或工作"><a href="#kill-删除执行中的程序或工作" class="headerlink" title="kill 删除执行中的程序或工作"></a>kill 删除执行中的程序或工作</h4><p>linux系统中kill命令用来删除执行中的程序或工作。<br>kill命令可将指定的信号发送给相应的进程或工作。 kill命令默认使用信号为15，用于结束进程或工作。如果进程或工作忽略此信号，则可以使用信号9，强制杀死进程或作业。<br>语法格式：<code>kill [参数] [进程号]</code></p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs llvm">注：最前面的数字为信号的代号，使用时可以用代号代替相应的信号。<br><span class="hljs-number">1</span>：SIGHUP，启动被终止的进程<br><span class="hljs-number">2</span>：SIGINT，相当于输入ctrl+<span class="hljs-keyword">c</span>，中断一个程序的进行<br><span class="hljs-number">9</span>：SIGKILL，强制中断一个进程的进行<br><span class="hljs-number">15</span>：SIGTERM，以正常的结束进程方式来终止进程<br><span class="hljs-number">17</span>：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行<br></code></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">以正常的结束进程方式来终于第一个后台工作，可用jobs命令查看后台中的第一个工作进程<br><span class="hljs-keyword">kill</span> -SIGTERM %1 <br> 重新改动进程ID为PID的进程，PID可用ps命令通过管道命令加上<span class="hljs-keyword">grep</span>命令进行筛选获得<br><span class="hljs-keyword">kill</span> -SIGHUP PID<br></code></pre></td></tr></table></figure>

<h4 id="file-识别文件类型"><a href="#file-识别文件类型" class="headerlink" title="file 识别文件类型"></a>file 识别文件类型</h4><p>file命令用来识别文件类型，也可用来辨别一些文件的编码格式。因为在Linux下文件的类型并不是以后缀为分的，所以这个命令对我们来说就很有用了，它的用法非常简单，基本语法如下：<br><code>file filename</code></p>
<h4 id="top-显示系统中各个进程的资源占用状况"><a href="#top-显示系统中各个进程的资源占用状况" class="headerlink" title="top 显示系统中各个进程的资源占用状况"></a>top 显示系统中各个进程的资源占用状况</h4><p>Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，常用于服务端性能分析。</p>
<p>在 <code>top</code> 命令中按 <code>f</code>按可以查看显示的列信息，按对应字母来开启&#x2F;关闭列，大写字母表示开启，小写字母表示关闭。带*号的是默认列。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-d	改变显示的更新速度，或是在交谈式指令列( interactive command)按 s</span><br><span class="hljs-deletion">-q	没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行</span><br><span class="hljs-deletion">-c 	切换显示模式</span><br><span class="hljs-deletion">-s	安全模式，将交谈式指令取消, 避免潜在的危机</span><br><span class="hljs-deletion">-i	不显示任何闲置 (idle) 或无用 (zombie) 的行程</span><br><span class="hljs-deletion">-n	更新的次数，完成后将会退出 top</span><br></code></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@linuxcool</span> ~]<span class="hljs-meta"># top -n 2  # 设置信息更新次数</span><br></code></pre></td></tr></table></figure>

<h4 id="gcc命令"><a href="#gcc命令" class="headerlink" title="gcc命令"></a>gcc命令</h4><p>gcc命令使用GNU推出的基于C&#x2F;C++的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。现在很多程序员都应用gcc，目前gcc可以用来编译C&#x2F;C++、FORTRAN、JAVA、OBJC、ADA等语言的程序，可根据需要选择安装支持的语言。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-o ：output之意，用于指定生成一个可执行文件的文件名</span><br><span class="hljs-deletion">-c ：用于把源文件生成目标文件（.o)，并阻止编译器创建一个完整的程序</span><br><span class="hljs-deletion">-I ：增加编译时搜索头文件的路径</span><br><span class="hljs-deletion">-L ：增加编译时搜索静态连接库的路径</span><br><span class="hljs-deletion">-S ：把源文件生成汇编代码文件</span><br><span class="hljs-deletion">-lm：表示标准库的目录中名为libm.a的函数库</span><br><span class="hljs-deletion">-lpthread ：连接NPTL实现的线程库</span><br><span class="hljs-deletion">-std= ：用于指定使用的C语言的版本</span><br></code></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">gcc -o <span class="hljs-keyword">test</span> <span class="hljs-keyword">test</span><span class="hljs-number">.</span>c -lm -<span class="hljs-keyword">std</span>=c99  # 把源文件<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c按照c99标准编译成可执行程序<span class="hljs-keyword">test</span><br>gcc -S <span class="hljs-keyword">test</span><span class="hljs-number">.</span>c  # 把源文件<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c转换为相应的汇编程序源文件<span class="hljs-keyword">test</span><span class="hljs-number">.</span>s<br></code></pre></td></tr></table></figure>

<h3 id="Ubuntu-软件安装"><a href="#Ubuntu-软件安装" class="headerlink" title="Ubuntu 软件安装"></a>Ubuntu 软件安装</h3><h4 id="1、软件商店安装"><a href="#1、软件商店安装" class="headerlink" title="1、软件商店安装"></a>1、软件商店安装</h4><p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/software.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<h4 id="2、-sudo-apt-get"><a href="#2、-sudo-apt-get" class="headerlink" title="2、 sudo apt-get"></a>2、 sudo apt-get</h4><p>直接使用该命令在线下载并自动安装软件。<br><code>sudo apt-get install git  # 安装 get 工具 </code></p>
<h4 id="3-deb-软件包"><a href="#3-deb-软件包" class="headerlink" title="3. deb 软件包"></a>3. deb 软件包</h4><p>类似windows下的 <code>.exe</code> 安装包。要先去官网下载软件的 .deb 安装包。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo dpkg -i|netease.xxx.deb  <span class="hljs-comment"># 安装网易云，得先进入到 .deb 所在文件夹</span><br>安装好的图标文件再 <span class="hljs-regexp">/usr/</span>share/applications 下<br></code></pre></td></tr></table></figure>

<h4 id="4、源码编译"><a href="#4、源码编译" class="headerlink" title="4、源码编译"></a>4、源码编译</h4><p>一般下下载好软件的源码并解压，进入到源码根目录下，执行 </p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span><br>...<br><span class="hljs-built_in">make</span> install<br></code></pre></td></tr></table></figure>
<blockquote>
<p> 安装命令各软件不尽相同，这里仅举一般例子说明</p>
</blockquote>
<h3 id="Ubuntu-文件系统结构"><a href="#Ubuntu-文件系统结构" class="headerlink" title="Ubuntu 文件系统结构"></a>Ubuntu 文件系统结构</h3><p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<h4 id="x2F-bin："><a href="#x2F-bin：" class="headerlink" title="&#x2F;bin："></a>&#x2F;bin：</h4><p>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。存放着最常用的程序和指令</p>
<h4 id="x2F-sbin："><a href="#x2F-sbin：" class="headerlink" title="&#x2F;sbin："></a>&#x2F;sbin：</h4><p>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的程序和指令。</p>
<h4 id="x2F-boot："><a href="#x2F-boot：" class="headerlink" title="&#x2F;boot："></a>&#x2F;boot：</h4><p>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p>
<h4 id="x2F-dev-："><a href="#x2F-dev-：" class="headerlink" title="&#x2F;dev ："></a>&#x2F;dev ：</h4><p>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p>
<h4 id="x2F-etc："><a href="#x2F-etc：" class="headerlink" title="&#x2F;etc："></a>&#x2F;etc：</h4><p>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。更改目录下的文件可能会导致系统不能启动。</p>
<h4 id="x2F-home："><a href="#x2F-home：" class="headerlink" title="&#x2F;home："></a>&#x2F;home：</h4><p>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p>
<h4 id="x2F-lib："><a href="#x2F-lib：" class="headerlink" title="&#x2F;lib："></a>&#x2F;lib：</h4><p>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p>
<h4 id="x2F-media："><a href="#x2F-media：" class="headerlink" title="&#x2F;media："></a>&#x2F;media：</h4><p>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p>
<h4 id="x2F-mnt："><a href="#x2F-mnt：" class="headerlink" title="&#x2F;mnt："></a>&#x2F;mnt：</h4><p>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。</p>
<h4 id="x2F-opt："><a href="#x2F-opt：" class="headerlink" title="&#x2F;opt："></a>&#x2F;opt：</h4><p>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p>
<h4 id="x2F-proc："><a href="#x2F-proc：" class="headerlink" title="&#x2F;proc："></a>&#x2F;proc：</h4><p>管理内存空间！proc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：<br><code>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</code></p>
<h4 id="x2F-root："><a href="#x2F-root：" class="headerlink" title="&#x2F;root："></a>&#x2F;root：</h4><p>该目录为系统管理员，也称作超级权限者的用户主目录。</p>
<h4 id="x2F-srv："><a href="#x2F-srv：" class="headerlink" title="&#x2F;srv："></a>&#x2F;srv：</h4><p> 该目录存放一些服务启动之后需要提取的数据。（不用服务器就是空）</p>
<h4 id="x2F-sys："><a href="#x2F-sys：" class="headerlink" title="&#x2F;sys："></a>&#x2F;sys：</h4><p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</p>
<p>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</p>
<p>该文件系统是内核设备树的一个直观反映。</p>
<p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p>
<h4 id="x2F-tmp："><a href="#x2F-tmp：" class="headerlink" title="&#x2F;tmp："></a>&#x2F;tmp：</h4><p>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p>
<h4 id="x2F-usr："><a href="#x2F-usr：" class="headerlink" title="&#x2F;usr："></a>&#x2F;usr：</h4><p> usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p>
<h4 id="x2F-usr-x2F-bin："><a href="#x2F-usr-x2F-bin：" class="headerlink" title="&#x2F;usr&#x2F;bin："></a>&#x2F;usr&#x2F;bin：</h4><p>系统用户使用的应用程序。</p>
<h4 id="x2F-usr-x2F-sbin："><a href="#x2F-usr-x2F-sbin：" class="headerlink" title="&#x2F;usr&#x2F;sbin："></a>&#x2F;usr&#x2F;sbin：</h4><p>超级用户使用的比较高级的管理程序和系统守护程序。</p>
<h4 id="x2F-usr-x2F-src："><a href="#x2F-usr-x2F-src：" class="headerlink" title="&#x2F;usr&#x2F;src："></a>&#x2F;usr&#x2F;src：</h4><p>内核源代码默认的放置目录。</p>
<h4 id="x2F-var："><a href="#x2F-var：" class="headerlink" title="&#x2F;var："></a>&#x2F;var：</h4><p>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>
<blockquote>
<p>这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 &#x2F;var&#x2F;log 目录下，另外 mail 的预设放置也是在这里。</p>
</blockquote>
<h4 id="x2F-run："><a href="#x2F-run：" class="headerlink" title="&#x2F;run："></a>&#x2F;run：</h4><p>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 &#x2F;var&#x2F;run 目录，应该让它指向 run。</p>
<h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><p>Linux下，不像Windows可以有C,D,E,多个目录，Linux只有一个根目录&#x2F;。在装系统时，我们分配给linux的所有区都在&#x2F;下的某个位置，比如&#x2F;home等等。</p>
<h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>该命令上文有说说明，这里更多以实例讲解回顾。<br>检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。<br><strong>语法：</strong><code>df [-ahikHTm] [目录或文件名]</code></p>
<p><strong>实例</strong><br>将系统内所有的文件系统列出来！默认会将系统内所有的 (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@www ~]<span class="hljs-comment"># df</span><br>Filesystem      1K-blocks      Used Available Use% Mounted on<br>/dev/hdc2        <span class="hljs-number"> 9920624 </span> <span class="hljs-number"> 3823112 </span> <span class="hljs-number"> 5585444 </span> 41% /<br>/dev/hdc3        <span class="hljs-number"> 4956316 </span>  <span class="hljs-number"> 141376 </span> <span class="hljs-number"> 4559108 </span>  4% /home<br>/dev/hdc1         <span class="hljs-number"> 101086 </span>   <span class="hljs-number"> 11126 </span>   <span class="hljs-number"> 84741 </span> 12% /boot<br>tmpfs             <span class="hljs-number"> 371332 </span>       <span class="hljs-number"> 0 </span>  <span class="hljs-number"> 371332 </span>  0% /dev/shm<br></code></pre></td></tr></table></figure>
<p>将容量结果以易读的容量格式显示出来</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">[root@www ~]<span class="hljs-comment"># df -h</span><br>Filesystem            Size  Used Avail Use% Mounted on<br><span class="hljs-regexp">/dev/</span>hdc2             <span class="hljs-number">9.5</span>G  <span class="hljs-number">3.7</span>G  <span class="hljs-number">5.4</span>G  <span class="hljs-number">41</span>% /<br><span class="hljs-regexp">/dev/</span>hdc3             <span class="hljs-number">4.8</span>G  <span class="hljs-number">139</span>M  <span class="hljs-number">4.4</span>G   <span class="hljs-number">4</span>% /home<br><span class="hljs-regexp">/dev/</span>hdc1              <span class="hljs-number">99</span>M   <span class="hljs-number">11</span>M   <span class="hljs-number">83</span>M  <span class="hljs-number">12</span>% /boot<br>tmpfs                 <span class="hljs-number">363</span>M     <span class="hljs-number">0</span>  <span class="hljs-number">363</span>M   <span class="hljs-number">0</span>% <span class="hljs-regexp">/dev/</span>shm<br></code></pre></td></tr></table></figure>
<p>将 &#x2F;etc 底下的可用的磁盘容量以易读的容量格式显示</p>
<figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nsis">[root@www ~]<span class="hljs-comment"># df -h /etc</span><br><span class="hljs-keyword">File</span><span class="hljs-params">system</span>            Size  Used Avail Use% Mounted <span class="hljs-literal">on</span><br>/dev/hdc2             <span class="hljs-number">9.5</span>G  <span class="hljs-number">3.7</span>G  <span class="hljs-number">5.4</span>G  <span class="hljs-number">41</span>% /<br></code></pre></td></tr></table></figure>

<h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><p>该命令上文有说说明，这里更多以实例讲解回顾。<br>du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令。  </p>
<blockquote>
<p>df不光考虑文件占用空间，还统计被命令和程序占用的空间（又是文件被删除时，只有等其没有被占用时才会真正删除，但磁盘中已经不存在了，属于程序暂用空间）<br>du命令只计算文件或目录占用的空间<br>所以，df统计的会大于du统计的。</p>
</blockquote>
<p>语法：<code>du [-ahskm] 文件或目录名称</code>  </p>
<p><strong>实例</strong></p>
<p>只列出当前目录下的所有文件夹容量（包括隐藏文件夹），直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">[root@www ~]<span class="hljs-comment"># du</span><br>8       <span class="hljs-string">./test4</span>     &lt;==每个目录都会列出来<br>8       <span class="hljs-string">./test2</span><br><span class="hljs-string">....</span>中间省略<span class="hljs-string">....</span><br>12      <span class="hljs-string">./.gconfd</span>   &lt;==包括隐藏文件的目录<br>220     .           &lt;==这个目录<span class="hljs-params">(.)</span>所占用的总量<br></code></pre></td></tr></table></figure>
<p>将文件的容量也列出来</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">[root@www ~]<span class="hljs-comment"># du -a</span><br>12      <span class="hljs-string">./install.log.syslog</span>   &lt;==有文件的列表了<br>8       <span class="hljs-string">./.bash_logout</span><br>8       <span class="hljs-string">./test4</span><br>8       <span class="hljs-string">./test2</span><br><span class="hljs-string">....</span>中间省略<span class="hljs-string">....</span><br>12      <span class="hljs-string">./.gconfd</span><br>220    <br></code></pre></td></tr></table></figure>
<p>检查根目录底下每个目录所占用的容量</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">[root@www ~]<span class="hljs-comment"># du -sm /*</span><br>7       <span class="hljs-string">/bin</span><br>6       <span class="hljs-string">/boot</span><br><span class="hljs-string">.....</span>中间省略<span class="hljs-string">....</span><br>0       <span class="hljs-string">/proc</span><br><span class="hljs-string">.....</span>中间省略<span class="hljs-string">....</span><br>1       <span class="hljs-string">/tmp</span><br>3859    <span class="hljs-string">/usr</span>     &lt;==系统初期最大就是他了啦！<br>77      <span class="hljs-string">/var</span><br></code></pre></td></tr></table></figure>

<h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p><code>Partition table manipulator for Linux</code>，Linux 的磁盘分区表操作工具。  进行硬盘分区从实质上说就是对硬盘的一种格式化， 用一个形象的比喻，分区就好比在一张白纸上画一个大方框，而格式化好比在方框里打上格子。<br><strong>语法：</strong> <code>fdisk [-l] 装置名称</code></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-b	指定每个分区的大小</span><br><span class="hljs-deletion">-l	列出指定的外围设备的分区表状况</span><br><span class="hljs-deletion">-s	将指定的分区大小输出到标准输出上，单位为区块</span><br></code></pre></td></tr></table></figure>
<p><strong>菜单操作指令</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">m ：显示菜单和帮助信息<br><span class="hljs-selector-tag">a</span> ：活动分区标记/引导分区<br>d ：删除分区<br>l ：显示分区类型<br>n ：新建分区<br><span class="hljs-selector-tag">p</span> ：显示分区信息<br><span class="hljs-selector-tag">q</span> ：退出不保存<br>t ：设置分区号<br>v ：进行分区检查<br>w ：保存修改<br>x ：扩展应用，高级功能<br></code></pre></td></tr></table></figure>

<p><strong>实例</strong>   </p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk">[root@AY120919111755c246621 tmp]<span class="hljs-comment"># fdisk -l</span><br><br>Disk <span class="hljs-regexp">/dev/</span>xvda: <span class="hljs-number">21.5</span> GB, <span class="hljs-number">21474836480</span> bytes<br><span class="hljs-number">255</span> heads, <span class="hljs-number">63</span> sectors/track, <span class="hljs-number">2610</span> cylinders<br>Units = cylinders of <span class="hljs-number">16065</span> * <span class="hljs-number">512</span> = <span class="hljs-number">8225280</span> bytes<br>Sector size (logical<span class="hljs-regexp">/physical): 512 bytes /</span> <span class="hljs-number">512</span> bytes<br>I<span class="hljs-regexp">/O size (minimum/</span>optimal): <span class="hljs-number">512</span> bytes / <span class="hljs-number">512</span> bytes<br>Disk identifier: <span class="hljs-number">0</span>x00000000<br><br>    Device Boot      Start         End      Blocks   Id  System<br>tmpfs           <span class="hljs-number">797</span>M   <span class="hljs-number">28</span>K  <span class="hljs-number">797</span>M   <span class="hljs-number">1</span>% <span class="hljs-regexp">/run/u</span>ser/<span class="hljs-number">121</span><br>tmpfs           <span class="hljs-number">797</span>M   <span class="hljs-number">32</span>K  <span class="hljs-number">797</span>M   <span class="hljs-number">1</span>% <span class="hljs-regexp">/run/u</span>ser/<span class="hljs-number">1000</span><br><span class="hljs-regexp">/dev/</span>sdb2       <span class="hljs-number">494</span>K  <span class="hljs-number">464</span>K   <span class="hljs-number">30</span>K  <span class="hljs-number">94</span>% <span class="hljs-regexp">/media/</span>lonly/UEFI_NTFS<br><span class="hljs-regexp">/dev/</span>sdb1        <span class="hljs-number">29</span>G  <span class="hljs-number">5.1</span>G   <span class="hljs-number">24</span>G  <span class="hljs-number">18</span>% <span class="hljs-regexp">/media/</span>lonly/CPBA_X64FRE_ZH-CN_DV9<br><span class="hljs-regexp">/dev/</span>sdc1          <span class="hljs-number">2048</span>  <span class="hljs-number">6291456</span>  <span class="hljs-number">6289409</span>    <span class="hljs-number">3</span>G <span class="hljs-number">83</span> Linux<br><span class="hljs-regexp">/dev/</span>sdc2       <span class="hljs-number">6293504</span> <span class="hljs-number">30564351</span> <span class="hljs-number">24270848</span> <span class="hljs-number">11.6</span>G <span class="hljs-number">83</span> Linux<br></code></pre></td></tr></table></figure>
<p>进入磁盘sdc，注意这里命令后面不带数字。xvda1&#x2F;2 其实都是svda这个磁盘的一个分区。好比一个 U 盘的两个分区。那么分区操作肯定时相对于 U 盘 （svda）来说。要进行分区磁盘操作，必须先进入该磁盘目录下。fdisk 硬盘设备名 例如：fdisk &#x2F;dev&#x2F;sdb</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">lonly@lonly-VirtualBox:$ sudo fdisk /dev/sdc  &lt;==仔细看，不要加上数字喔！我这里加了sudo否则无法进入，网上大多教程都不需要<br>[sudo] password <span class="hljs-keyword">for</span> lonly: <br><br>Welcome <span class="hljs-keyword">to</span> fdisk (util-linux <span class="hljs-number">2.31</span>.<span class="hljs-number">1</span>).<br>Changes will remain in memory <span class="hljs-keyword">only</span>, until you decide <span class="hljs-keyword">to</span> <span class="hljs-keyword">write</span> them.<br>Be careful before using the <span class="hljs-keyword">write</span> <span class="hljs-keyword">command</span>.<br><br>Command (<span class="hljs-keyword">m</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">help</span>): <span class="hljs-keyword">p</span>  &lt;==等待你的输入！这里就进入了菜单操作了，需要用到上面的菜单操作指令。<br></code></pre></td></tr></table></figure>
<p>先输入 p 查看磁盘目前分区情况。</p>
<ul>
<li>一个扇区sectors &#x3D; 512 bytes</li>
<li>1GB &#x3D; 1024MB &#x3D; 1024 * 1024 KB &#x3D; 1024 * 1024* 1024 &#x3D; 1073741824 byte &#x3D; 1073741824&#x2F;512 sectors</li>
<li>这里的 sectors 在后面新建分区时输入分区大小时会需要</li>
<li>下面的英文一定要每个都能看懂并理解<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tap">Disk /dev/sdc: 14.6 GiB,<span class="hljs-number"> 15648948224 </span>bytes,<span class="hljs-number"> 30564352 </span>sectors<br>Units: sectors of<span class="hljs-number"> 1 </span>*<span class="hljs-number"> 512 </span>=<span class="hljs-number"> 512 </span>bytes<br>Sector size (logical/physical):<span class="hljs-number"> 512 </span>bytes /<span class="hljs-number"> 512 </span>bytes<br>I/O size (minimum/optimal):<span class="hljs-number"> 512 </span>bytes /<span class="hljs-number"> 512 </span>bytes<br>Disklabel type: dos<br>Disk identifier: 0xf6057dc9<br><br><span class="hljs-comment">## 笔者注释</span><br><span class="hljs-comment">## 分区        开始扇区位置 结束位置 扇区大小 字节大小</span><br>Device     Boot   Start      End  Sectors  Size Id Type<br>/dev/sdc1         <span class="hljs-number"> 2048 </span><span class="hljs-number"> 6291456 </span><span class="hljs-number"> 6289409 </span>   3G<span class="hljs-number"> 83 </span>Linux<br>/dev/sdc2      <span class="hljs-number"> 6293504 </span>30564351<span class="hljs-number"> 24270848 </span>11.6G<span class="hljs-number"> 83 </span>Linux<br></code></pre></td></tr></table></figure>
输入 d 然后选择分区，删除现有分区：<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Command</span> (m for help): d    <br><span class="hljs-attribute">Partition</span> number (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>, default <span class="hljs-number">2</span>): <span class="hljs-number">1</span><br><br><span class="hljs-attribute">Partition</span> <span class="hljs-number">1</span> has been deleted.<br><br><span class="hljs-attribute">Command</span> (m for help): d  # 当仅有一个分区时，输入 d 直接删除分区，请小心。<br><span class="hljs-attribute">Selected</span> partition <span class="hljs-number">2</span><br><span class="hljs-attribute">Partition</span> <span class="hljs-number">2</span> has been deleted.<br><br></code></pre></td></tr></table></figure>
查看分区情况，确认已删除。<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Command</span> (m for help): p<br><span class="hljs-attribute">Disk</span> /dev/sdc: <span class="hljs-number">14</span>.<span class="hljs-number">6</span> GiB, <span class="hljs-number">15648948224</span> bytes, <span class="hljs-number">30564352</span> sectors<br><span class="hljs-attribute">Units</span>: sectors of <span class="hljs-number">1</span> * <span class="hljs-number">512</span> = <span class="hljs-number">512</span> bytes<br><span class="hljs-attribute">Sector</span> size (logical/physical): <span class="hljs-number">512</span> bytes / <span class="hljs-number">512</span> bytes<br><span class="hljs-attribute">I</span>/O size (minimum/optimal): <span class="hljs-number">512</span> bytes / <span class="hljs-number">512</span> bytes<br><span class="hljs-attribute">Disklabel</span> type: dos<br><span class="hljs-attribute">Disk</span> identifier: <span class="hljs-number">0</span>xf6057dc9<br></code></pre></td></tr></table></figure>
输入n建立新的磁盘分区，建立两个主磁盘分区：<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs tap">Command (m for help): n<br>Partition type<br>   p   primary (0 primary,<span class="hljs-number"> 0 </span>extended,<span class="hljs-number"> 4 </span>free)  <span class="hljs-comment"># 主分区</span><br>   e   extended (container for logical partitions)  <span class="hljs-comment"># 扩展分区。关于两者区别请看下文</span><br><br>Select (default p): p    <span class="hljs-comment"># 建立主分区</span><br>Partition number (1-4, default 1):<span class="hljs-number"> 1 </span> <span class="hljs-comment"># 分区号</span><br>First sector (2048-30564351, default 2048):   <span class="hljs-comment"># 回车，默认分区起始位置</span><br>Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (2048-30564351, default 30564351): +3G  <span class="hljs-comment"># 分区结束位置，单位为G，注意看本句前面提示</span><br><br>Created a new partition<span class="hljs-number"> 1 </span>of type &#x27;Linux&#x27; and of size<span class="hljs-number"> 3 </span>GiB.<br><br><span class="hljs-comment">## 剩余空间再建立一个分区</span><br>Command (m for help): n<br>Partition type<br>   p   primary (1 primary,<span class="hljs-number"> 0 </span>extended,<span class="hljs-number"> 3 </span>free)<br>   e   extended (container for logical partitions)<br>Select (default p): p<br>Partition number (2-4, default 2): 2<br>First sector (6293504-30564351, default 6293504):    <span class="hljs-comment"># 回车，默认</span><br>Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (6293504-30564351, default 30564351):   <span class="hljs-comment"># 回车，默认</span><br><br>Created a new partition<span class="hljs-number"> 2 </span>of type &#x27;Linux&#x27; and of size 11.6 GiB.<br><br><span class="hljs-comment">## 查看分区情况，确认</span><br>Command (m for help): p <br>Disk /dev/sdc: 14.6 GiB,<span class="hljs-number"> 15648948224 </span>bytes,<span class="hljs-number"> 30564352 </span>sectors<br>Units: sectors of<span class="hljs-number"> 1 </span>*<span class="hljs-number"> 512 </span>=<span class="hljs-number"> 512 </span>bytes<br>Sector size (logical/physical):<span class="hljs-number"> 512 </span>bytes /<span class="hljs-number"> 512 </span>bytes<br>I/O size (minimum/optimal):<span class="hljs-number"> 512 </span>bytes /<span class="hljs-number"> 512 </span>bytes<br>Disklabel type: dos<br>Disk identifier: 0xf6057dc9<br><br>Device     Boot   Start      End  Sectors  Size Id Type<br>/dev/sdc1         <span class="hljs-number"> 2048 </span><span class="hljs-number"> 6293503 </span><span class="hljs-number"> 6291456 </span>   3G<span class="hljs-number"> 83 </span>Linux<br>/dev/sdc2      <span class="hljs-number"> 6293504 </span>30564351<span class="hljs-number"> 24270848 </span>11.6G<span class="hljs-number"> 83 </span>Linux<br><br></code></pre></td></tr></table></figure>
至此两个分区已经建立完成，输入 w 保存</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">Command (m for help): w<br>The partition table has been altered.<br>Syncing disks.<br></code></pre></td></tr></table></figure>
<p>建立好分区之后我们还需要对分区进行格式化才能在系统中使用磁盘。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lonly</span>@lonly-VirtualBox:$ mkfs.vfat /dev/sdc1<br><span class="hljs-attribute">mkfs</span>.fat <span class="hljs-number">4</span>.<span class="hljs-number">1</span> (<span class="hljs-number">2017</span>-<span class="hljs-number">01</span>-<span class="hljs-number">24</span>)<br><span class="hljs-attribute">lonly</span>@lonly-VirtualBox:$ sudo mkfs.vfat /dev/sdc2<br><span class="hljs-attribute">mkfs</span>.fat <span class="hljs-number">4</span>.<span class="hljs-number">1</span> (<span class="hljs-number">2017</span>-<span class="hljs-number">01</span>-<span class="hljs-number">24</span>)<br><br></code></pre></td></tr></table></figure>

<p>建立两个目录，将新建好的两个分区挂载到系统</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">lonly@lonly-VirtualBox:$ sudo mkdir <span class="hljs-regexp">/media/</span>lonly/sdc1<br>lonly@lonly-VirtualBox:$ sudo mount <span class="hljs-regexp">/dev/</span>sdc1 <span class="hljs-regexp">/media/</span>lonly/sdc1<br>lonly@lonly-VirtualBox:$ sudo mkdir <span class="hljs-regexp">/media/</span>lonly/sdc2<br>lonly@lonly-VirtualBox:$ sudo mount <span class="hljs-regexp">/dev/</span>sdc2 <span class="hljs-regexp">/media/</span>lonly/sdc2<br></code></pre></td></tr></table></figure>
<p>查看分区挂载情况：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">lonly@lonly-VirtualBox:/$ df -h<br>tmpfs           <span class="hljs-number">797</span>M   <span class="hljs-number">28</span>K  <span class="hljs-number">797</span>M   <span class="hljs-number">1</span>% <span class="hljs-regexp">/run/u</span>ser/<span class="hljs-number">121</span><br>tmpfs           <span class="hljs-number">797</span>M   <span class="hljs-number">32</span>K  <span class="hljs-number">797</span>M   <span class="hljs-number">1</span>% <span class="hljs-regexp">/run/u</span>ser/<span class="hljs-number">1000</span><br><span class="hljs-regexp">/dev/</span>sdb2       <span class="hljs-number">494</span>K  <span class="hljs-number">464</span>K   <span class="hljs-number">30</span>K  <span class="hljs-number">94</span>% <span class="hljs-regexp">/media/</span>lonly/UEFI_NTFS<br><span class="hljs-regexp">/dev/</span>sdb1        <span class="hljs-number">29</span>G  <span class="hljs-number">5.1</span>G   <span class="hljs-number">24</span>G  <span class="hljs-number">18</span>% <span class="hljs-regexp">/media/</span>lonly/CPBA_X64FRE_ZH-CN_DV9<br><span class="hljs-regexp">/dev/</span>sdc1        <span class="hljs-number">15</span>G  <span class="hljs-number">3.8</span>G   <span class="hljs-number">11</span>G  <span class="hljs-number">27</span>% <span class="hljs-regexp">/media/</span>lonly/sdc1<br><span class="hljs-regexp">/dev/</span>sdc2        <span class="hljs-number">12</span>G  <span class="hljs-number">8.0</span>K   <span class="hljs-number">12</span>G   <span class="hljs-number">1</span>% <span class="hljs-regexp">/media/</span>lonly/sdc2<br></code></pre></td></tr></table></figure>
<h4 id="主分区、扩展分区和逻辑分区"><a href="#主分区、扩展分区和逻辑分区" class="headerlink" title="主分区、扩展分区和逻辑分区"></a>主分区、扩展分区和逻辑分区</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>硬盘分区有三种，主磁盘分区、扩展磁盘分区、逻辑分区。这三个术语是针对操作系统而言，主要是从<strong>功能上</strong>划分的概念。</p>
<p><strong>主分区：</strong></p>
<p>也叫引导分区，一个硬盘主分区至少有1个，最多4个，当创建四个主分区时候，就无法再创建扩展分区了，当然也就没有逻辑分区了。<br>在windows下激活的主分区是硬盘的启动分区，他是独立的，也是硬盘的第一个分区，正常分的话就是C区。</p>
<p><strong>扩展分区：</strong></p>
<p>分出主分区后，其余的部分可以分成扩展分区，一般是剩下的部分全部分成扩展分区，扩展分区可以没有，最多1个。 且主分区+扩展分区总共不能超过4个。严格地讲它不是一个实际意义的分区，它仅仅是一个指向下一个分区的指针，这种指针结构将形成一个单向链表。这样在主引导扇区中除了主分区外，仅需要存储一个被称为扩展分区的分区数据，通过这个扩展分区的数据可以找到下一个分区<code>(实际上也就是下一个逻辑磁盘)的起始位置，以此起始位置类推可以找到所有的分区。无论系统中建立多少个逻辑磁盘，在主引导扇区中通过一个扩展分区的参数就可以逐个找到每一个逻辑磁盘。</code></p>
<p><strong>逻辑分区：</strong></p>
<p>但扩展分区是不能直接用的，他是以逻辑分区的方式来使用的，所以说扩展分区可分成若干逻辑分区。 他们的关系是包含的关系，所有的逻辑分区都是扩展分区的一部分。逻辑分区相当于一块存储截止，和操作系统还有别的逻辑分区、主分区没有什么关系，是“独立的”。</p>
<h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><p>给新硬盘上建立分区时都要遵循以下的顺序：<code>建立主分区→建立扩展分区→建立逻辑分区→激活主分区→格式化所有分区。</code></p>
<p>主分区+扩展分区总共不能超过4个，（扩展分区也可以看成是主分区）其个数是由硬盘的主引导记录MBR(Master Boot Recorder)决定的，MBR存放启动管理程序(如GRUB)和分区表记录。扩展分区下又可以包含多个逻辑分区.</p>
<p>在linux中第一块硬盘分区为hda分区(或者是sda分区)，主分区编号为hda1-4，逻辑分区从5开始。<br>（hd0，0）表示第一块硬盘第一个主分区，(hd1,4)表示第2块硬盘第一个逻辑分区。</p>
<p>硬盘的容量&#x3D;主分区的容量+扩展分区的容量 扩展分区的容量&#x3D;各个逻辑分区的容量之和</p>
<p>主分区也可成为“引导分区”，会被操作系统和主板认定为这个硬盘的第一个分区。 所以C盘永远都是排在所有磁盘分区的第一的位置上。</p>
<p>MBR（主引导记录）的分区表（主分区表）只能存放4个分区，如果要分更多的分区的话就要 一个扩展分区表（EBR），扩展分区表放在一个系统ID为0x05的主分区上，这个主分区就是扩展分区， 扩展分区能可以分若干个分区，每个分区都是个逻辑分区</p>
<h5 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h5><ul>
<li><a target="_blank" rel="noopener" href="https://gtcsq.readthedocs.io/en/latest/linux_tools/disk_note.html">Linux 磁盘和分区</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/buzaikoulan/article/details/44405915">主分区、扩展分区和逻辑分区的区别，系统分区、引导分区和启动分区的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiechn/p/4494958.html">磁盘分区——主分区、扩展分区、逻辑分区</a></li>
</ul>
<h4 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h4><p>磁盘分割完毕后自然就是要进行文件系统的格式化，格式化的命令非常的简单，使用 mkfs（make filesystem） 命令。</p>
<p><strong>语法：</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">mkfs <span class="hljs-selector-attr">[-t 文件系统格式]</span> 装置文件名<br>mkfs         mkfs<span class="hljs-selector-class">.cramfs</span>  mkfs<span class="hljs-selector-class">.ext2</span>    mkfs<span class="hljs-selector-class">.ext3</span>    mkfs<span class="hljs-selector-class">.msdos</span>   mkfs.vfat<br></code></pre></td></tr></table></figure>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">-t ：可以接文件系统格式，例如 <span class="hljs-keyword">ext3, </span><span class="hljs-keyword">ext2, </span>vfat 等(系统有支持才会生效)<br></code></pre></td></tr></table></figure>

<p><strong>实例 1</strong><br>查看 mkfs 支持的文件格式</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">[root@www ~]<span class="hljs-comment"># mkfs[tab][tab]  # 紧跟mkfs按下两个[tab]（tab键不会显示出来，这里仅示意），查看 mkfs 支持的文件格式如上所示。</span><br>mkfs         mkfs.cramfs  mkfs.<span class="hljs-keyword">ext3 </span>   mkfs.fat     mkfs.msdos   mkfs.vfat<br>mkfs.<span class="hljs-keyword">bfs </span>    mkfs.<span class="hljs-keyword">ext2 </span>   mkfs.<span class="hljs-keyword">ext4 </span>   mkfs.minix   mkfs.ntfs   <br></code></pre></td></tr></table></figure>
<p>将分区 &#x2F;dev&#x2F;sdc1 格式化为 vfat (fat32)文件系统：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lonly</span>@lonly-VirtualBox:$ mkfs.vfat /dev/sdc1<br><span class="hljs-attribute">mkfs</span>.fat <span class="hljs-number">4</span>.<span class="hljs-number">1</span> (<span class="hljs-number">2017</span>-<span class="hljs-number">01</span>-<span class="hljs-number">24</span>)<br></code></pre></td></tr></table></figure>

<h4 id="磁盘挂载与卸除"><a href="#磁盘挂载与卸除" class="headerlink" title="磁盘挂载与卸除"></a>磁盘挂载与卸除</h4><ol>
<li>提一句Windows下，mount挂载，就是给磁盘分区提供一个盘符（C,D,E,…）。比如插入U盘后系统自动分配给了它I:盘符其实就是挂载，退优盘的时候进行安全弹出，其实就是卸载unmount。</li>
<li>插入了新硬盘，分了新磁盘区sdb1。它现在还不属于&#x2F;。我们虽然可以在一些图形桌面系统里找到他的位置，浏览管理里面的文件，但在命令行却不知怎么访问它的目录，比如无法使用cd或者ls。也无法在编程时指定一个目录对它操作。</li>
<li>这时使用了 mount &#x2F;dev&#x2F;sdb1 <del>&#x2F;Share&#x2F; ，把新硬盘的区sdb1挂载到工作目录的</del>&#x2F;Share&#x2F;文件夹下，之后访问这个~&#x2F;Share&#x2F;文件夹就相当于访问这个硬盘2的sdb1分区了。对&#x2F;Share&#x2F;的任何操作，都相当于对sdb1里文件的操作。</li>
<li>所以Linux下，mount挂载的作用，就是将一个设备（通常是存储设备）挂接到一个已存在的目录上。访问这个目录就是访问该存储设备。</li>
<li>linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合成一个大的文件目录。我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。</li>
<li>我们不是有&#x2F;dev&#x2F;sdb1 吗，直接对它操作不就行了？这不是它的目录吗？</li>
<li>这不是它的目录。虽然&#x2F;dev是个目录，但&#x2F;dev&#x2F;sdb1不是目录。可以发现ls&#x2F;dev&#x2F;sdb1无法执行。&#x2F;dev&#x2F;sdb1，是一个类似指针的东西，指向这个分区的原始数据块。mount前，系统并不知道这个数据块哪部分数据代表文件，如何对它们操作。</li>
<li>挂载一个设备前，必须先建立一个挂在点</li>
</ol>
<p>Linux 的磁盘挂载使用 mount 命令，卸载使用 umount 命令。</p>
<p><strong>磁盘挂载语法：</strong><br><code>mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点</code></p>
<p><strong>磁盘卸载命令 umount 语法：</strong><br><code>umount [-fn] 装置文件名或挂载点</code></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；<br>-n ：不升级 <span class="hljs-regexp">/etc/m</span>tab 情况下卸除。<br></code></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<p>用默认的方式，将刚刚创建的 &#x2F;dev&#x2F;hdc6 挂载到 &#x2F;mnt&#x2F;hdc6 上面！</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[root@www ~]# mkdir <span class="hljs-regexp">/mnt/</span>hdc6  # 新建一个挂载点<br>[root@www ~]# mount <span class="hljs-regexp">/dev/</span>hdc6 <span class="hljs-regexp">/mnt/</span>hdc6  # 挂载设备<br>[root@www ~]# df<br>Filesystem           <span class="hljs-number">1</span>K-blocks      Used Available Use% Mounted on<br>.....<br><span class="hljs-regexp">/dev/</span>hdc6              <span class="hljs-number">1976312</span>     <span class="hljs-number">42072</span>   <span class="hljs-number">1833836</span>   <span class="hljs-number">3</span>% <span class="hljs-regexp">/mnt/</span>hdc6<br></code></pre></td></tr></table></figure>
<p>卸载&#x2F;dev&#x2F;hdc6</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># umount /dev/hdc6     </span><br></code></pre></td></tr></table></figure>

<h3 id="压缩与解压缩"><a href="#压缩与解压缩" class="headerlink" title="压缩与解压缩"></a>压缩与解压缩</h3><p>压缩格式：windows (zip、rar)    </p>
<p> linux  (gz ，bzip，zip)</p>
<h4 id="打包与压缩"><a href="#打包与压缩" class="headerlink" title="打包与压缩"></a>打包与压缩</h4><p> <strong>打包：</strong> 将多个文件打包成一个文件，没有层级目录之分。文件大小不变。类似多个购物袋放进一个袋子，方便好拿。<br><strong>压缩：</strong> 把打包后的那个文件压缩，文件大小减小。先将多个购物袋放进一个袋子，再抽真空压缩，减小尺寸。<br>先打包再压缩， 打包后可以拆包，压缩后可以解压	。一般压缩软件自带打包与压缩，所以看似是只有压缩一步。</p>
<h4 id="压缩软件"><a href="#压缩软件" class="headerlink" title="压缩软件"></a>压缩软件</h4><p>该压缩软件是要<strong>安装在 windows系统下</strong>，方便和 linux 文件传输，同意格式。<strong>LInux 不安装 。</strong><br>我经常使用的 360 压缩不支持 gzip、bzip2 压缩格式，所以不选择。另一个免费的 <a target="_blank" rel="noopener" href="https://www.7-zip.org/download.html">7-Zip</a> 支持这两种格式。</p>
<h4 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h4><p>该命令用于对文件进行打包，ta文件通常都是以 .tar 结尾。默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压。它的常用参数如下：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-c ：新建打包文件</span><br><span class="hljs-deletion">-t ：查看打包文件的内容含有哪些文件名</span><br><span class="hljs-deletion">-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中</span><br><span class="hljs-deletion">-j ：通过bzip2的支持进行压缩/解压缩</span><br><span class="hljs-deletion">-z ：通过gzip的支持进行压缩/解压缩</span><br><span class="hljs-deletion">-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来</span><br><span class="hljs-deletion">-f filename ：filename为要处理的文件</span><br><span class="hljs-deletion">-C dir ：指定压缩/解压缩的目录dir</span><br></code></pre></td></tr></table></figure>
<p>上面的解说可以已经让你晕过去了，但是通常我们只需要记住下面三条命令即可：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs autoit">打包：tar -vcf test.tar test  <span class="hljs-meta"># 打包 test 文件夹，并新建 .tar 文件</span><br>拆包：tar -vxf test.tar   <span class="hljs-meta"># 拆包</span><br><br><span class="hljs-meta">#压缩</span><br>[root<span class="hljs-symbol">@localhost</span> tmp]<span class="hljs-meta"># tar -zvcf buodo.tar.gz buodo</span><br>[root<span class="hljs-symbol">@localhost</span> tmp]<span class="hljs-meta"># tar -jvcf buodo.tar.bz2 buodo </span><br><br><span class="hljs-meta">#解压</span><br>[root<span class="hljs-symbol">@localhost</span> tmp]<span class="hljs-meta"># tar -zvxf buodo.tar.gz </span><br>[root<span class="hljs-symbol">@localhost</span> tmp]<span class="hljs-meta"># tar -jvxf buodo.tar.bz2</span><br></code></pre></td></tr></table></figure>

<h4 id="rar压缩格式"><a href="#rar压缩格式" class="headerlink" title="rar压缩格式"></a>rar压缩格式</h4><p>要在 linux 下处理 .rar 文件，需要安装 RAR for Linux。 安装方式：<br><code>sudo apt-get install rar</code></p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal">[root<span class="hljs-variable">@localhost</span> tmp]<span class="hljs-variable">$ </span>rar a test *.jpg  <span class="hljs-comment"># 将所有 .jpg 的文件压缩成 test.rar，该程序会将 .rar 扩展名自动附加到包名后。</span><br>[root<span class="hljs-variable">@localhost</span> tmp]<span class="hljs-variable">$ </span> unrar e test.rar  <span class="hljs-comment"># 将 test.rar 中的所有文件解压出来：</span><br><br></code></pre></td></tr></table></figure>

<h4 id="ZIP压缩格式"><a href="#ZIP压缩格式" class="headerlink" title="ZIP压缩格式"></a>ZIP压缩格式</h4><p>linux 下自带了 zip 和 unzip 程序，zip 是压缩程序，unzip 是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-q	不显示指令执行过程</span><br><span class="hljs-deletion">-r	递归处理，将指定目录下的所有文件和子目录一并处理</span><br><span class="hljs-deletion">-z	替压缩文件加上注释</span><br><span class="hljs-deletion">-v	显示指令执行过程或显示版本信息</span><br></code></pre></td></tr></table></figure>
<p>实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@localhost tmp]$ <span class="hljs-built_in">zip</span> <span class="hljs-built_in">all</span>.<span class="hljs-built_in">zip</span> *.jpg   <span class="hljs-comment"># 将所有 .jpg 的文件压缩成一个 zip 包:</span><br>[root@localhost tmp]$ <span class="hljs-built_in">zip</span> <span class="hljs-built_in">all</span>.<span class="hljs-built_in">zip</span> <span class="hljs-built_in">all</span>   <span class="hljs-comment"># 将test文件夹及其子目录的文件一并压缩成一个 zip 包:</span><br>[root@localhost tmp]$ unzip <span class="hljs-built_in">all</span>.<span class="hljs-built_in">zip</span>   <span class="hljs-comment"># 将 all.zip 中的所有文件解压出来。</span><br></code></pre></td></tr></table></figure>

<h3 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h3><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。<br>每个用户账号都拥有一个唯一的用户名（UID）和各自的口令。<br>实现用户账号的管理，要完成的工作主要有如下几个方面：</p>
<ul>
<li>用户账号的添加、删除与修改。</li>
<li>用户口令的管理。</li>
<li>用户组的管理。</li>
</ul>
<p>注意三个文件：</p>
<ul>
<li>&#x2F;etc&#x2F;passwd 存储用户的关键信息</li>
<li>&#x2F;etc&#x2F;group 存储用户组的关键信息</li>
<li>&#x2F;etc&#x2F;shadow 存储用户的密码信息</li>
</ul>
<h4 id="Linux用户"><a href="#Linux用户" class="headerlink" title="Linux用户"></a>Linux用户</h4><p>Linux是一个多用户操作系统，不同的用户拥有不同的权限。可以查看和操作不同的文件。 Ubuntu有三种用户：</p>
<ul>
<li>初次创建的用户</li>
<li>root用户</li>
<li>普通用户</li>
</ul>
<p>root 用户和初次创建的用户其实就是一个用户，是第一次安装这个 Linux 系统的那个用户。初次创建的用户权限其实就是 root 用户约束了一部分权力（防止误操作删除了系统文件，导致系统崩溃），但仍可以使用 sudo 命令获取临时的root权限或永久切换为 root 权限。普通用户无法创建用户，也无法获得 root 权限。</p>
<h4 id="Linux用户组"><a href="#Linux用户组" class="headerlink" title="Linux用户组"></a>Linux用户组</h4><p>为了方便管理，将用户进行分组。这样就可以设置非本组人员不能访问某些文件。每个用户可以属于多个不同的组。</p>
<p>用户：家里有你、弟弟、妹妹个人，每个人都有自己的房间，你们三个人都是用户，你们都不能随便的乱翻别人的房间。<br>用户组：你们三个都是一个家庭的，也就是属于同一个用户组，你们三个可以共用厨房，书房等空间。  </p>
<p><strong>因此：</strong><br>用户和用户组的存在就是为了控制文件的访问权限的。<br>每个用户组都有一个ID，叫做GID。</p>
<h4 id="创建用户和用户组"><a href="#创建用户和用户组" class="headerlink" title="创建用户和用户组"></a>创建用户和用户组</h4><h5 id="图形化界面创建"><a href="#图形化界面创建" class="headerlink" title="图形化界面创建"></a>图形化界面创建</h5><p>要使用图形化界面创建用户和用户组的话就需要安装gnome-system-tools这个工具：<br><code>sudo apt-get install gnome-system-tools</code></p>
<h5 id="命令创建用户和用户组"><a href="#命令创建用户和用户组" class="headerlink" title="命令创建用户和用户组"></a>命令创建用户和用户组</h5><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-c comment 指定一段注释性描述。</span><br><span class="hljs-deletion">-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</span><br><span class="hljs-deletion">-g 用户组 指定用户所属的用户组。</span><br><span class="hljs-deletion">-G 用户组，用户组 指定用户所属的附加组。</span><br><span class="hljs-deletion">-s Shell文件 指定用户的登录Shell。</span><br><span class="hljs-deletion">-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</span><br></code></pre></td></tr></table></figure>
<p><strong>实例：</strong></p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs crystal">[root<span class="hljs-variable">@localhost</span> tmp]<span class="hljs-variable">$ </span>useradd –d  /home/sam -m sam  <span class="hljs-comment"># 此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 /home/sam（/home为默认的用户主目录所在的父目录）。</span><br>[root<span class="hljs-variable">@localhost</span> tmp]<span class="hljs-variable">$ </span>useradd sam  <span class="hljs-comment"># 添加用户sam</span><br>[root<span class="hljs-variable">@localhost</span> tmp]<span class="hljs-variable">$ </span>finger 用户名 <span class="hljs-comment"># 用户查询</span><br>[root<span class="hljs-variable">@localhost</span> tmp]<span class="hljs-variable">$ </span>passwd 用户名 <span class="hljs-comment"># 修改用户密码</span><br>[root<span class="hljs-variable">@localhost</span> tmp]<span class="hljs-variable">$ </span>deluser 用户名  <span class="hljs-comment"># 删除用户</span><br><br>[root<span class="hljs-variable">@localhost</span> tmp]<span class="hljs-variable">$ </span>groupadd 用户组名  <span class="hljs-comment"># 添加用户组，</span><br>[root<span class="hljs-variable">@localhost</span> tmp]<span class="hljs-variable">$ </span>groups 用户组名  <span class="hljs-comment"># 显示组内用户名，</span><br>[root<span class="hljs-variable">@localhost</span> tmp]<span class="hljs-variable">$ </span>groupdel 用户组名  <span class="hljs-comment"># 删除用户组</span><br></code></pre></td></tr></table></figure>

<h5 id="参考链接-2"><a href="#参考链接-2" class="headerlink" title="参考链接"></a>参考链接</h5><ul>
<li>Linux 用户和用户组管理<a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-user-manage.html">enter description here</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.ibm.com/zh/technologies/linux/tutorials/l-lpic1-104-5/">管理文件权限和所有权</a><h3 id="文件基本属性"><a href="#文件基本属性" class="headerlink" title="文件基本属性"></a>文件基本属性</h3></li>
</ul>
<p>inux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。</p>
<p>为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。<br>在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：</p>
<ul>
<li>chown (change ownerp) ： 修改所属用户与组。</li>
<li>chmod (change mode) ： 修改用户的权限。</li>
</ul>
<p>在 Linux 中我们可以使用 <code>ll</code> 或者 <code>ls –l</code> 命令来显示一个文件的属性以及文件所属的用户和组，如：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@www /]<span class="hljs-comment"># ls -l</span><br>total 64<br>dr-xr-xr-x  <span class="hljs-number"> 2 </span>root root<span class="hljs-number"> 4096 </span>Dec<span class="hljs-number"> 14 </span><span class="hljs-number"> 2012 </span>bin<br>dr-xr-xr-x  <span class="hljs-number"> 4 </span>root root<span class="hljs-number"> 4096 </span>Apr<span class="hljs-number"> 19 </span><span class="hljs-number"> 2012 </span>boot<br></code></pre></td></tr></table></figure>

<p>实例中，bin 文件的第一个属性用 d 表示。d 在 Linux 中代表该文件是一个目录文件。<br>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs erlang">d 目录<br>- 文件；<br>l 链接文档<span class="hljs-params">(link file)</span>；<br>b 装置文件里面的可供储存的接口设备<span class="hljs-params">(可随机存取装置)</span>；<br>c 装置文件里面的串行端口设备，例如键盘、鼠标<span class="hljs-params">(一次性读取装置)</span>。<br></code></pre></td></tr></table></figure>

<p>接下来的字符中，以三个为一组，且均为 r、w、x 三个参数的组合。其中， r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 - 而已。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1605200269941.png" srcset="/img/loading.gif" lazyload alt="enter description here"><br>每个文件的属性由左边第一部分的 10 个字符来确定（如下图）。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1605200284013.png" srcset="/img/loading.gif" lazyload alt="enter description here"><br>从左至右用 0-9 这些数字来表示。  </p>
<ul>
<li>第 0 位确定文件类型，第 1-3 位确定属主（该文件的所有者）拥有该文件的权限。</li>
<li>第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</li>
<li>其中，第 1、4、7 位表示读权限，如果用 r 字符表示，则有读权限，如果用 - 字符表示，则没有读权限；</li>
<li>第 2、5、8 位表示写权限，如果用 w 字符表示，则有写权限，如果用 - 字符表示没有写权限；</li>
<li>第 3、6、9 位表示可执行权限，如果用 x 字符表示，则有执行权限，如果用 - 字符表示，则没有执行权限。</li>
</ul>
<h4 id="Linux文件属主和属组"><a href="#Linux文件属主和属组" class="headerlink" title="Linux文件属主和属组"></a>Linux文件属主和属组</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@www /]<span class="hljs-comment"># ls -l</span><br>total 64<br>drwxr-xr-x<span class="hljs-number"> 2 </span>root  root <span class="hljs-number"> 4096 </span>Feb<span class="hljs-number"> 15 </span>14:46 cron<br>drwxr-xr-x<span class="hljs-number"> 3 </span>mysql mysql<span class="hljs-number"> 4096 </span>Apr<span class="hljs-number"> 21 </span><span class="hljs-number"> 2014 </span>mysql<br>……<br></code></pre></td></tr></table></figure>
<p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。<br>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。<br>在以上实例中，mysql 文件是一个目录文件，属主和属组都为 mysql，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限。<br>对于 root 用户来说，一般情况下，文件的权限对其不起作用。</p>
<h4 id="更改文件属性"><a href="#更改文件属性" class="headerlink" title="更改文件属性"></a>更改文件属性</h4><h5 id="1、chgrp：更改文件属组"><a href="#1、chgrp：更改文件属组" class="headerlink" title="1、chgrp：更改文件属组"></a>1、chgrp：更改文件属组</h5><p>语法：<code>chgrp [-R] 属组名 文件名</code></p>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tp">-<span class="hljs-keyword">R</span>：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-<span class="hljs-keyword">R</span>的参数，那么该目录下的所有文件的属组都会更改。<br></code></pre></td></tr></table></figure>
<h5 id="2、chown：更改文件属主，也可以同时更改文件属组"><a href="#2、chown：更改文件属主，也可以同时更改文件属组" class="headerlink" title="2、chown：更改文件属主，也可以同时更改文件属组"></a>2、chown：更改文件属主，也可以同时更改文件属组</h5><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> [–R] 属主名 文件名<br><span class="hljs-built_in">chown</span> [-R] 属主名：属组名 文件名<br></code></pre></td></tr></table></figure>
<h5 id="3、chmod：更改文件9个属性"><a href="#3、chmod：更改文件9个属性" class="headerlink" title="3、chmod：更改文件9个属性"></a>3、chmod：更改文件9个属性</h5><h6 id="数字格式"><a href="#数字格式" class="headerlink" title="数字格式"></a>数字格式</h6><p>文件的权限字符为： -rwxrwxrwx ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<p>owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7<br>group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7<br>others&#x3D; — &#x3D; 0+0+0 &#x3D; 0<br>所以等一下我们设定权限的变更时，该文件的权限数字就是 770。变更权限的指令 chmod 的语法是这样的：<br> <code>chmod [-R] xyz 文件或目录</code><br>选项与参数：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">xyz : 代表属主权限、属组权限、代表其他权限<br><br>-R : 进行递归(<span class="hljs-type">recursive</span>)的持续变更，亦即连同次目录下的所有文件都会变更<br></code></pre></td></tr></table></figure>
<h6 id="符号格式"><a href="#符号格式" class="headerlink" title="符号格式"></a>符号格式</h6><p>user：用户<br>group：组<br>others：其他</p>
<p>那么我们就可以使用 u, g, o 来代表三种身份的权限。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">chmod [-R] u=rwx,g=rwx,o-rwx 文件名<br><span class="hljs-regexp">//</span> -R 代表递归，即目录下所有文件都会更改属性<br><span class="hljs-regexp">//</span> u 代表属主<br><span class="hljs-regexp">//</span> g 代表属组<br><span class="hljs-regexp">//</span> o 代表其他<br></code></pre></td></tr></table></figure>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">## chmod u=rwx,g=rx,o=r  test1    <span class="hljs-comment">// 修改 test1 权限</span><br>##  chmod  a-x test1   <span class="hljs-comment">// a 则代表 all，即全部的身份。</span><br></code></pre></td></tr></table></figure>

<h3 id="连接文件"><a href="#连接文件" class="headerlink" title="连接文件"></a>连接文件</h3><p>文件都有文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。用户数据，即文件数据块 (data block)，是记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在 Linux 中，元数据中的 inode 号（索引节点号，inode 是元数据的一部分但并不包含文件名）才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序实际是通过 inode 号寻找正确的文件数据块。下图展示了程序通过文件名获取文件内容的过程。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1605795008761.png" srcset="/img/loading.gif" lazyload alt="通过文件名打开文件"></p>
<p>在 Linux 系统中查看 inode 号可使用命令 stat 或 ls -i。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">lonly<span class="hljs-keyword">@lonly-VirtualBox</span>:~$ stat file1.c <br>  <span class="hljs-attribute">File</span>: file1.c<br>  <span class="hljs-attribute">Size</span>: <span class="hljs-number">20</span>        	<span class="hljs-attribute">Blocks</span>: <span class="hljs-number">8</span>          IO <span class="hljs-attribute">Block</span>: <span class="hljs-number">4096</span>   regular file<br><span class="hljs-attribute">Device</span>: <span class="hljs-number">801</span>h/<span class="hljs-number">2049</span>d	<span class="hljs-attribute">Inode</span>: <span class="hljs-number">2884087</span>     <span class="hljs-attribute">Links</span>: <span class="hljs-number">1</span><br>...<br>...<br>lonly<span class="hljs-keyword">@lonly-VirtualBox</span>:~$ ls -i file1.c <br><span class="hljs-number">2884087</span> file2.c<br></code></pre></td></tr></table></figure>

<p>为解决文件的共享使用，Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）。链接为 Linux 系统解决了文件的共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。</p>
<h4 id="硬链接："><a href="#硬链接：" class="headerlink" title="硬链接："></a>硬链接：</h4><p>若一个 inode 号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名。由于硬链接是有着相同 inode 号仅文件名不同的文件，因此硬链接存在以下几点特性：</p>
<ul>
<li>文件有相同的 inode 及 data block；</li>
<li>只能对已存在的文件进行创建；</li>
<li>不能跨文件系统，因为不同的文件系统有不同的inode table； </li>
<li>不能对目录进行创建，只可对文件创建；</li>
<li>删除一个硬链接文件并不影响其他有相同 inode 号的文件。</li>
<li>所有硬链接文件修改时同步的。</li>
</ul>
<p>inode 是随着文件的存在而存在，因此只有当文件存在时才可创建硬链接，inode 号仅在各文件系统下是唯一的，当 Linux 挂载多个文件系统后将出现 inode 号重复的现象，因此硬链接创建时不可跨文件系统。</p>
<h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>软链接（也叫符号链接），类似于windows系统中的快捷方式。软链接就是一个普通文件，只是数据块内容有点特殊，存放的内容是另一文件的路径名的指向，通过这个方式可以快速定位到软连接所指向的源文件实体。软链接有着自己的 inode 号以及用户数据块。因此软链接的创建与使用没有类似硬链接的诸多限制：</p>
<ul>
<li>软链接有自己的文件属性及权限等；</li>
<li>可对不存在的文件或目录创建软链接；</li>
<li>软链接可交叉文件系统；</li>
<li>软链接可对文件或目录创建；</li>
<li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。</li>
</ul>
<p>软链接创建时原文件的路径指向使用绝对路径较好。使用相对路径创建的软链接被移动后该软链接文件将成为一个死链接，因为链接数据块中记录的亦是相对路径指向。</p>
<h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><p>硬链接实际上是为文件建一个别名，链接文件和原文件实际上是同一个文件。而软链接建立的是一个指向，即链接文件内的内容是指向原文件的指针，它们是两个文件。<br>不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1605796713610.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<h4 id="ln命令"><a href="#ln命令" class="headerlink" title="ln命令"></a>ln命令</h4><p>软链接和硬链接都是通过ln命令来创建，只是参数不同。命令格式如下：<br><code>ln 参数 源文件或目录 目标文件或目录</code>  </p>
<blockquote>
<p>注意：源目录和目标目录都必须是绝对路径！</p>
</blockquote>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-b 删除，覆盖以前建立的链接</span><br><span class="hljs-deletion">-d 允许超级用户制作目录的硬链接</span><br><span class="hljs-deletion">-f 强制执行</span><br><span class="hljs-deletion">-i 交互模式，文件存在则提示用户是否覆盖</span><br><span class="hljs-deletion">-n 把符号链接视为一般目录</span><br><span class="hljs-deletion">-s 软链接(符号链接)</span><br><span class="hljs-deletion">-v 显示详细的处理过程</span><br></code></pre></td></tr></table></figure>
<p>创建软链接 （符号链接）使用：<code>ln -s source target </code><br>创建硬链接 （实体链接）使用：<code>ln source target</code></p>
<h5 id="参考链接-3"><a href="#参考链接-3" class="headerlink" title="参考链接"></a>参考链接</h5><ul>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/">理解 Linux 的硬链接与软链接</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/LEON1741/article/details/100136449">浅谈linux中的硬链接和软链接文件以及ln的使用方法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-ln.html">Linux ln 命令</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/efad6d9702d042d1bc21fe750af606eb">在Linux系统，关于硬链接的描述正确的是（）</a></li>
</ul>
<h2 id="四、linux-编程"><a href="#四、linux-编程" class="headerlink" title="四、linux 编程"></a>四、linux 编程</h2><p>LInux下编程分为两步：</p>
<ol>
<li>编写</li>
<li>编译<br>而这两步是使用不同的软件实现的。</li>
</ol>
<p>更新本地数据库：sudo apt-get update</p>
<h3 id="vim编译器"><a href="#vim编译器" class="headerlink" title="vim编译器"></a>vim编译器</h3><p>Linux系统都会自带vi编辑器，但是vi编辑器太难用了！所以建议大家安装vim编辑器，安装命令：<br><code>sudo apt-get install vim</code></p>
<h4 id="vi-x2F-vim-的使用"><a href="#vi-x2F-vim-的使用" class="headerlink" title="vi&#x2F;vim 的使用"></a>vi&#x2F;vim 的使用</h4><p><code>vi xxx</code>	使用vi编辑器打开文件，没有则自动创建。<br>基本上 vi&#x2F;vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是：</p>
<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。<br>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。<br>以下是常用的几个命令：  </p>
<ul>
<li>“i、I、a、A、o、O、s、r”等任一个切换到输入模式，以输入字符。</li>
<li>x 删除当前光标所在处的字符。</li>
<li>: 切换到底线命令模式，以在最底一行输入命令。</li>
<li>dd，删除光标所在行，ndd，删除光标所在行及其下n行。</li>
<li>u，撤销，恢复上一步。</li>
<li>. ,重复前一个操作。</li>
<li>yy，复制光标所在行</li>
<li>nyy，复制光标所在向下n行，比如10yy就是复制光标下10行。</li>
<li>p和P，p为复制到光标下一行，P复制到光标上一行。</li>
</ul>
<p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令</p>
<h4 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h4><p>在命令模式下按下i就进入了输入模式。<br>在输入模式中，可以使用以下按键：</p>
<ul>
<li>字符按键以及Shift组合，输入字符</li>
<li>ENTER，回车键，换行</li>
<li>BACK SPACE，退格键，删除光标前一个字符</li>
<li>DEL，删除键，删除光标后一个字符</li>
<li>方向键，在文本中移动光标</li>
<li>HOME&#x2F;END，移动光标到行首&#x2F;行尾</li>
<li>Page Up&#x2F;Page Down，上&#x2F;下翻页</li>
<li>Insert，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</li>
<li>ESC，退出输入模式，切换到命令模式</li>
</ul>
<h4 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h4><p>在命令模式下按下<code>:</code>（英文冒号）就进入了底线命令模式。<br>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。<br>在底线命令模式中，基本的命令有（已经省略了冒号）<code>：</code></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">q</span> 退出程序<br>w 保存文件<br>wq 保存退出<br><span class="hljs-selector-tag">q</span>! 不保存退出<br>/xxx，表示在文件中查找xxx<br></code></pre></td></tr></table></figure>
<p>按ESC键可随时退出底线命令模式。<br>简单的说，我们可以将这三个模式想成底下的图标来表示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1605799065000.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<h4 id="编写第一个程序"><a href="#编写第一个程序" class="headerlink" title="编写第一个程序"></a>编写第一个程序</h4><p>使用前，还需要简单配置一下</p>
<ol>
<li><code>vim /etc/vim/vimrc</code> 打开文件（如果保存时提示错误，加 sudo）</li>
<li><code>set ts = 4</code> 按下 <code>i</code> 进入编辑模式，找到文件最后面，输入该代码，设置TAB键为空4格</li>
<li><code>set nu</code> 再 输入，打开行号显示。<code>esc</code> 退出编辑模式，<code>:wq</code> 保存</li>
</ol>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">57</span> <span class="hljs-comment">&quot; Source a global configuration file if available</span><br><span class="hljs-number">58</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">filereadable</span>(<span class="hljs-string">&quot;/etc/vim/vimrc.local&quot;</span>)<br><span class="hljs-number">59</span>   <span class="hljs-keyword">source</span> /etc/<span class="hljs-keyword">vim</span>/vimrc.local<br><span class="hljs-number">60</span> <span class="hljs-keyword">endif</span><br><span class="hljs-number">61</span> <br><span class="hljs-number">62</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">ts</span>=<span class="hljs-number">4</span><br><span class="hljs-number">63</span> <br><span class="hljs-number">64</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">nu</span><br><span class="hljs-number">65</span> <br></code></pre></td></tr></table></figure>

<p><code>vi main.c</code> 创建一个源文件。输入如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p> <strong>参考链接</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-vim.html">Linux vi&#x2F;vim</a></li>
<li><a target="_blank" rel="noopener" href="https://dasunhegoda.com/tutorial-in-vim-editor-introduction-vim/510/">VIM 编辑器简介 ： VIM 编辑器教程</a></li>
</ul>
<h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><p>gcc命令使用GNU推出的基于C&#x2F;C++的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。</p>
<p>现在很多程序员都应用gcc，目前gcc可以用来编译C&#x2F;C++、FORTRAN、JAVA、OBJC、ADA等语言的程序，可根据需要选择安装支持的语言。</p>
 <figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-c	只编译并生成目标文件。</span><br><span class="hljs-deletion">-E	只运行 C 预编译器。</span><br><span class="hljs-deletion">-g	生成调试信息。GNU 调试器可利用该信息。</span><br><span class="hljs-deletion">-o  生成指定的输出文件。用在生成可执行文件时。</span><br><span class="hljs-deletion">-O0	不进行优化处理。</span><br><span class="hljs-deletion">-O 或 -O1	优化生成代码。</span><br><span class="hljs-deletion">-O2	进一步优化。</span><br><span class="hljs-deletion">-O3	比 -O2 更进一步优化，包括 inline 函数。</span><br><span class="hljs-deletion">-w	不生成任何警告信息。</span><br><span class="hljs-deletion">-Wall	生成所有警告信息。</span><br></code></pre></td></tr></table></figure>

<p><strong>实例：</strong><br>无选项编译文件，默认编译并生成 a.out  可执行文件</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ gcc <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>$ ls<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.out</span> <span class="hljs-selector-tag">main</span>.c<br></code></pre></td></tr></table></figure>
<p>自定义输出文件文件名</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ gcc -o <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.out</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span>  <span class="hljs-comment">// 或者 gcc main.c -o main.out</span><br>$ ls<br><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.out</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br><br></code></pre></td></tr></table></figure>
<p>运行可执行文件</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>./main.<span class="hljs-keyword">out</span><br>Hello World!<br><br></code></pre></td></tr></table></figure>

<h4 id="程序编译流程"><a href="#程序编译流程" class="headerlink" title="程序编译流程"></a>程序编译流程</h4><ol>
<li>预处理：生成 .i 的文件[预处理器cpp]<br>展开所有的头文件、替换程序中的宏、解析条件编译并添加到文件中</li>
<li>编译：生成文件 .s [编译器egcs]<br>将经过预编译处理的代码编译成汇编代码，也就是我们常说的程序编译</li>
<li>汇编：生成 .o 的文件[汇编器as]<br> 将汇编语言文件编译成二进制目标文件（机器代码）</li>
<li>链接：生成可执行程序 [链接器ld]<br> 将汇编出来的多个二进制目标文件链接在一起，形成最终的可执行文件，链接的时候还会涉及到静态库和动态库等问题。</li>
</ol>
<p>上面演示的例程都只有一个文件，因此可以直接使用gcc命令生成可执行文件 main.out，并没有先将c文件编译成.o文件，然后再链接在一起。</p>
<p><strong>参考链接</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/gcc-parameter-detail.html">GCC 参数详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.linuxcool.com/gcc">gcc命令 – GUN C&#x2F;C++编译器</a></li>
</ul>
<h2 id="Makefile编写"><a href="#Makefile编写" class="headerlink" title="Makefile编写"></a>Makefile编写</h2><h3 id="make工具"><a href="#make工具" class="headerlink" title="make工具"></a>make工具</h3><p>利用make工具可以自动完成编译工作。这些工作包括：</p>
<ul>
<li>如果仅仅修改了某几个源文件，则只重新编译这几个源文件；</li>
<li>如果某个头文件被修改，则重新编译所有包含该头文件的源文件。</li>
</ul>
<p>利用这种自动编译可大大简化开发工作，避免不必要的重新编译。</p>
<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p>make工具通过一个称为Makefile的文件来完成并自动维护编译工作。Makefile文件描述了整个工程的编译、链接等规则。</p>
<h3 id="Makefile一般规则"><a href="#Makefile一般规则" class="headerlink" title="Makefile一般规则"></a>Makefile一般规则</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">## 注释   注释开头使用 <span class="hljs-string">&#x27;#&#x27;</span>,不能使用 <span class="hljs-string">&#x27;//&#x27;</span>、<span class="hljs-string">&#x27;/* */&#x27;</span><br>目标...:  依赖文件集合...<br>		命令<span class="hljs-number">1</span><br>		命令<span class="hljs-number">2</span><br>		...<br>		<br></code></pre></td></tr></table></figure>
<ul>
<li>目标（TARGET）：程序产生的文件，如可执行文件和目标文件；目标也可以是要执行的动作，如clean，也称伪目标。</li>
<li>依赖（DEPENDENCIES）是用来产生目标的输入文件列表，一个目标通常依赖于多个文件。有的目标可以没有依赖文件。</li>
<li>命令（COMMAND）：是make执行的动作（命令是shell命令或者是可在shell下执行的程序）。注意：每个命令行的起始字符必须为TAB字符，命令可以不止一条。</li>
<li>如果依赖文件中有一个或多个文件更新的话，命令就要执行，这就是Makefile最核心的内容。</li>
</ul>
<p>以上由目标，命令组成的就叫做一条规则语句，Makefile 会包含很多规则语句，但每条规则都遵循上面的规则</p>
<p>接下来就根据这个Makefile基本规则来编写一个最基本的Makefile文件</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.PHONY</span>:clean<br><span class="hljs-selector-tag">main</span>:<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> sub<span class="hljs-selector-class">.o</span> add<span class="hljs-selector-class">.o</span> print<span class="hljs-selector-class">.o</span><br>    gcc -o <span class="hljs-selector-tag">main</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> add<span class="hljs-selector-class">.o</span> sub<span class="hljs-selector-class">.o</span> print<span class="hljs-selector-class">.o</span> <br><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>:<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> <br>    gcc -o <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> <br>add<span class="hljs-selector-class">.o</span>:add<span class="hljs-selector-class">.c</span> add<span class="hljs-selector-class">.h</span><br>    gcc -o add<span class="hljs-selector-class">.o</span> add<span class="hljs-selector-class">.c</span> <br>sub<span class="hljs-selector-class">.o</span>:sub<span class="hljs-selector-class">.c</span> sub<span class="hljs-selector-class">.h</span><br>    gcc -o sub<span class="hljs-selector-class">.o</span> sub<span class="hljs-selector-class">.c</span> <br>print<span class="hljs-selector-class">.o</span>:print<span class="hljs-selector-class">.c</span> print<span class="hljs-selector-class">.h</span><br>    gcc -o print<span class="hljs-selector-class">.o</span> print<span class="hljs-selector-class">.c</span> <br>clean:<br>    rm *<span class="hljs-selector-class">.o</span> <br>	rm main<br></code></pre></td></tr></table></figure>

<p>我们可以看到，我们使用了 <strong>6 条规则</strong>，<code>main</code>是我们最终想要生成的目标文件，它依赖<code>main.o</code> <code>sub.o</code> <code>add.o</code> <code>print.o</code>这四个 <code>.o</code>文件。因此要执行 <code>gcc -o main main.o add.o sub.o print.o</code>命令来生成目标文件 <code>main</code>，但是当前没有这些 <code>.o</code>文件( 一开始只有编写为 .c和.h文件)，因此就要先生成这些 <code>.o</code>文件。我们写了四条<code>xxx.o:xxx.c</code>然后执行<code>gcc -Wall -g -c xxx.c -o xxx.o</code>，这些语句就会生成目标文件的依赖项。</p>
<p><code>clean</code> 是一个伪目标文件，因为它没有依赖项。我们只是想通过 <code>make clean</code> 来将 <code>.o</code> 文件删除，但是我们通常要指定 <code>.PHONY:clean</code> 这条语句，用来显式的指定 <code>clean</code> 是伪目标，来防止当前目录下有一个同名的 <code>clean</code> 文件。这样，一个简单呢的Makefile文件就写好了。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>我们完成这样一个小工程，通过键盘输入两个整形数字，然后计算他们的和并将结果显示在屏幕上，在这个工程中我们有main.c、input.c和calcu.c这三个C文件和input.h、calcu.h这两个头文件。其中main.c是主体，input.c负责接收从键盘输入的数值，calcu.h进行任意两个数相加。  </p>
<p>其中main.c文件内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;input.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;calcu.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> a,b,num;<br>	<br>	<span class="hljs-built_in">input_int</span>(&amp;a,&amp;b);<br>	num = <span class="hljs-built_in">calcu</span>(a,b);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d + %d = %d\r\n&quot;</span>,a,b,num);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>input.c文件内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;input.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">input_int</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> *b)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;input two num:&quot;</span>);<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,a,b);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>calcu.c文件内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;calcu.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calcu</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span>(a + b);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>文件input.h内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _INPUT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _INPUT_H</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">input_int</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> *b)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p>文件calcu.h内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _CALCU_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CALCU_H</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calcu</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p>1</p>
<h5 id="gcc方法"><a href="#gcc方法" class="headerlink" title="gcc方法"></a>gcc方法</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">lonly@lonly-VirtualBox:~/Desktop/program_test$ gcc <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.c</span> calcu<span class="hljs-selector-class">.c</span> -o <span class="hljs-selector-tag">main</span><br>lonly@lonly-VirtualBox:~/Desktop/program_test$ ls<br>calcu<span class="hljs-selector-class">.c</span>  calcu<span class="hljs-selector-class">.h</span>  <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.c</span>  <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.h</span>  <span class="hljs-selector-tag">main</span>  <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>lonly@lonly-VirtualBox:~/Desktop/program_test$ ./<span class="hljs-selector-tag">main</span><br><span class="hljs-selector-tag">input</span> two num:<span class="hljs-number">2</span> <span class="hljs-number">6</span><br><br><span class="hljs-number">2</span> + <span class="hljs-number">6</span> = <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure>

<p>gcc方法特点：</p>
<ul>
<li>有多少个文件每次就得写多少个文件名，几千个文件的话就不太现实了</li>
<li>每次编译都是所有文件都编译，不论有没有修改过，太花时间</li>
</ul>
<p>因此我们需要：</p>
<ol>
<li>如果工程没有编译过，那么工程中的所有.c文件都要被编译并且链接成可执行程序。</li>
<li>如果工程中只有个别C文件被修改了，那么只编译这些被修改的C文件即可。</li>
<li>如果工程的头文件被修改了，那么我们需要编译所有引用这个头文件的C文件，并且链接成可执行文件。</li>
</ol>
<p>能够完成这个功能的就是Makefile了。</p>
<h5 id="make方法"><a href="#make方法" class="headerlink" title="make方法"></a>make方法</h5><p>在工程目录下创建名为“Makefile”的文件，文件名一定要叫做“Makefile”！！！  Makefile和C文件是处于同一个目录的。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">lonly@lonly-VirtualBox:~/Desktop/program_test$ ls<br>calcu<span class="hljs-selector-class">.c</span>  calcu<span class="hljs-selector-class">.h</span>  <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.c</span>  <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.h</span>  <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>lonly@lonly-VirtualBox:~/Desktop/program_test$ vi Makefile<br>lonly@lonly-VirtualBox:~/Desktop/program_test$ ls<br>calcu<span class="hljs-selector-class">.c</span>  calcu<span class="hljs-selector-class">.h</span>  <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.c</span>  <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.h</span>  <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span>  Makefile<br></code></pre></td></tr></table></figure>
<p>在Makefile文件中输入如下代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">main</span>: <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.o</span> calcu<span class="hljs-selector-class">.o</span><br>      gcc -o <span class="hljs-selector-tag">main</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.o</span> calcu<span class="hljs-selector-class">.o</span><br> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>: <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>      gcc -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br> <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.o</span>: <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.c</span><br>      gcc -c <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.c</span><br> calcu<span class="hljs-selector-class">.o</span>: calcu<span class="hljs-selector-class">.c</span><br>      gcc -c calcu<span class="hljs-selector-class">.c</span><br>  <br>clean:<br>     rm *<span class="hljs-selector-class">.o</span><br>     rm <span class="hljs-selector-tag">main</span><br><br></code></pre></td></tr></table></figure>
<p>Makefile编写好以后我们就可以使用make命令来编译我们的工程了，直接在命令行中输入“make”即可，make命令会在当前目录下查找是否存在“Makefile”这个文件，如果存在的话就会按照Makefile里面定义的编译方式进行编译，如下所示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">lonly@lonly-VirtualBox:~/Desktop/program_test$ make<br>gcc -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>gcc -c <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.c</span><br>gcc -c calcu<span class="hljs-selector-class">.c</span><br>gcc -o <span class="hljs-selector-tag">main</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.o</span> calcu<span class="hljs-selector-class">.o</span><br>lonly@lonly-VirtualBox:~/Desktop/program_test$ ls<br>calcu<span class="hljs-selector-class">.c</span>  calcu<span class="hljs-selector-class">.o</span>  <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.h</span>  <span class="hljs-selector-tag">main</span>    <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span><br>calcu<span class="hljs-selector-class">.h</span>  <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.c</span>  <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.o</span>  <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span>  Makefile<br>lonly@lonly-VirtualBox:~/Desktop/program_test$ ./<span class="hljs-selector-tag">main</span><br><span class="hljs-selector-tag">input</span> two num:<span class="hljs-number">2</span> <span class="hljs-number">5</span><br><br><span class="hljs-number">2</span> + <span class="hljs-number">5</span> = <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>

<h3 id="Makefile变量"><a href="#Makefile变量" class="headerlink" title="Makefile变量"></a>Makefile变量</h3><p>Makefile中变量的引用方法是：<br><code>$(变量名)</code>  </p>
<p>跟C语言一样Makefile也支持变量的，先观察一下前面的例子：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">main</span>: <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.o</span> calcu<span class="hljs-selector-class">.o</span><br>      gcc -o <span class="hljs-selector-tag">main</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.o</span> calcu.o<br></code></pre></td></tr></table></figure>
<p>这里<code>main.o input.o calcu.o</code> 书写了两边，重复书写，为了解决这个问题，Makefile加入了变量支持。不像C语言中的变量有int、char等各种类型，<strong>Makefile中的变量都是字符串，且无需声明</strong>！<strong>类似C语言中的宏</strong>。使用变量将上面的代码修改，修改以后如下所示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">OBJ = <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.o</span> calcu<span class="hljs-selector-class">.o</span><br> <span class="hljs-selector-tag">main</span>: $(OBJ)<br>       gcc -o <span class="hljs-selector-tag">main</span> $(OBJ)<br><br></code></pre></td></tr></table></figure>
<p>我们定义了一个变量叫OBJ，他是我们的依赖项列表。然后使用变量来代替对应的文件，这样就可以避免重复书写  <code>main.o sub.o add.o print.o</code>。后面使用<code>$(objects)</code> 调用变量objects。</p>
<p>我们再观察：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>: <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>     gcc -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.o</span>: <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.c</span><br>     gcc -c <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.c</span><br>calcu<span class="hljs-selector-class">.o</span>: calcu<span class="hljs-selector-class">.c</span><br>     gcc -c calcu.c<br></code></pre></td></tr></table></figure>
<p>似乎有一些规律，都是</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">xxx.o:xxx.<span class="hljs-keyword">c</span> <br>	gcc -<span class="hljs-keyword">c</span> xxx.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure>
<p>那么能不能够用一两句来替代上述语句呢，答案是有的。此时我们需要引入 Makefile 模式规则和自动化变量。</p>
<h3 id="Makefile模式规则"><a href="#Makefile模式规则" class="headerlink" title="Makefile模式规则"></a>Makefile模式规则</h3><p>模式规则中，至少在规则的目标定义中要包含 “%”，否则，就是一般的规则（上述内容就是一般规则）。  格式如下：</p>
<p><code> %.o : %.c ;</code>  </p>
<p>目标中的 “%” 定义表示对文件名的匹配，”%” 表示长度任意的非空字符串。例如：”%.c” 表示以 “.c” 结尾的文件名（文件名的长度至少为3），而 “s.%.c” 则表示以 “s.” 开头，”.c” 结尾的文件名（文件名的长度至少为5）。</p>
<p>如果 “%” 定义在目标中，那么，目标中的 “%” 的值决定了依赖目标中的 “%” 的值，也就是说，目标中的模式的” %” 决定了依赖目标中 “%” 的样子。  </p>
<p>例如 <code>%.o</code>表示要生成的目标是<code>main.o</code>，那么依赖中 <code>%c</code> 就会自动表示为 <code>main.c</code>。如果有多个目标文件，<code>%.o : %.c </code> 就会轮询这些文件。</p>
<p>如此我们便可以简写之前的 一般规则，实例如下：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">%<span class="hljs-string">.o</span>: %<span class="hljs-string">.c</span>  <span class="hljs-comment"># 代替了每一个 xxx.o:xxx.c</span><br>     &lt;<span class="hljs-keyword">command</span> <span class="hljs-string">......</span>&gt;<br></code></pre></td></tr></table></figure>

<h3 id="Makefile自动化变量"><a href="#Makefile自动化变量" class="headerlink" title="Makefile自动化变量"></a>Makefile自动化变量</h3><p>在上述的模式规则中，目标和依赖文件都是一系例的文件，但在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。命令 <code> gcc -c xxx.c</code> 中的 <code>xxx.c</code> 也就会不一样， 那么我们如何代替 <code>xxx.c</code>呢，答案是自动化变量。</p>
<p>所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量<strong>只应出现在规则的命令中</strong>。</p>
<p>下面是一部分自动化变量及其说明：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">选项名	作用<br><span class="hljs-variable">$@</span>		规则的目标文件名。在模式规则中，如果有多个目标，那么，<span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>就是匹配于目标中模式定义的集合。<br><span class="hljs-variable">$&lt;</span>		规则的第一个依赖文件名，如果依赖目标是以模式（即<span class="hljs-string">&quot;%&quot;</span>）定义的，那么<span class="hljs-string">&quot;<span class="hljs-variable">$&lt;</span>&quot;</span>将是符合模式的一系列的文件集。注意，其是一个一个取出来的。<br><span class="hljs-variable">$^</span>		规则的所有依赖文件列表，如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。<br></code></pre></td></tr></table></figure>
<p>如此我们便可以简写之前的 一般规则，实例如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">OBJ = <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.o</span> calcu<span class="hljs-selector-class">.o</span><br><span class="hljs-selector-tag">main</span>: $(OBJ)<br>    gcc -o $@ $^<br><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>: <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>    gcc -c $&lt;<br><span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.o</span>: <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.c</span><br>    gcc -c $&lt;<br>calcu<span class="hljs-selector-class">.o</span>: calcu<span class="hljs-selector-class">.c</span><br>    gcc -c $&lt; <br>print<span class="hljs-selector-class">.o</span>:print<span class="hljs-selector-class">.c</span> print<span class="hljs-selector-class">.h</span><br>    gcc -c $&lt;  <br></code></pre></td></tr></table></figure>
<p>这里我们用 <code>$^</code> 代替了 <code>xxx.c</code>，这样其实每一条命令书写方式就是一样的了。再结合上述的模式规则，我们的Makefile 代码最终像是如下：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-number"> 1 </span>OBJ = main.o input.o calcu.o<br><span class="hljs-number"> 2 </span><br><span class="hljs-number"> 3 </span>main: $(OBJ)<br><span class="hljs-number"> 4 </span>    gcc -o $@ $^<br><span class="hljs-number"> 5 </span>%.o: %.c<br><span class="hljs-number"> 6 </span>    gcc -c $^<br><span class="hljs-number"> 7 </span><br><span class="hljs-number"> 8 </span>clean:<br><span class="hljs-number"> 9 </span>    rm *.o<br>10     rm main<br></code></pre></td></tr></table></figure>
<p>可以看出相比原来的代码要精简了很多，1、3 行使用了变量，4、6 行使用了自动化变量，5 行使用了模式规则</p>
<h3 id="Makefile-条件判断"><a href="#Makefile-条件判断" class="headerlink" title="Makefile 条件判断"></a>Makefile 条件判断</h3><p>在C语言中我们通过条件判断语句来根据不同的情况来执行不同的分支，Makefile也支持条件判断，语法有两种如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;条件关键字&gt;</span><br>	<span class="hljs-section">&lt;条件为真时执行的语句&gt;</span><br><span class="hljs-attribute">endif</span><br></code></pre></td></tr></table></figure>
<p>以及：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;条件关键字&gt;</span><br>	<span class="hljs-section">&lt;条件为真时执行的语句&gt;</span><br><span class="hljs-attribute">else</span><br>	<span class="hljs-section">&lt;条件为假时执行的语句&gt;</span><br><span class="hljs-attribute">endif</span><br></code></pre></td></tr></table></figure>
<p>其中条件关键字有4个：<code>ifeq、ifneq、ifdef和ifndef</code>，这四个关键字其实分为两对、ifeq与ifneq、ifdef与ifndef</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>ifeq</td>
<td>判断参数是否不相等，相等为 true，不相等为 false。</td>
</tr>
<tr>
<td>ifneq</td>
<td>判断参数是否不相等，不相等为 true，相等为 false。</td>
</tr>
<tr>
<td>ifdef</td>
<td>判断是否有值，有值为 true，没有值为 false。</td>
</tr>
<tr>
<td>ifndef</td>
<td>判断是否有值，没有值为 true，有值为 false。</td>
</tr>
</tbody></table>
<h4 id="ifeq-和-ifneq"><a href="#ifeq-和-ifneq" class="headerlink" title="ifeq 和 ifneq"></a>ifeq 和 ifneq</h4><p>条件判断的使用方式如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ifeq</span>(&lt;参数<span class="hljs-number">1</span>&gt;,    &lt;参数<span class="hljs-number">2</span>&gt;)<br><span class="hljs-attribute">ifeq</span> ‘&lt;参数<span class="hljs-number">1</span>&gt;’,‘&lt;参数<span class="hljs-number">2</span>&gt;’<br><span class="hljs-attribute">ifeq</span> “&lt;参数<span class="hljs-number">1</span>&gt;”, “&lt;参数<span class="hljs-number">2</span>&gt;”<br><span class="hljs-attribute">ifeq</span>“&lt;参数<span class="hljs-number">1</span>&gt;”, ‘&lt;参数<span class="hljs-number">2</span>&gt;’<br><span class="hljs-attribute">ifeq</span>‘&lt;参数<span class="hljs-number">1</span>&gt;’, “&lt;参数<span class="hljs-number">2</span>&gt;”<br></code></pre></td></tr></table></figure>
<p>上述用法中都是用来比较“参数1”和“参数2”是否相同，如果相同则为真，“参数1”和“参数2”可以为函数返回值。<br><strong>实例：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile">libs_for_gcc= -lgnu<br>normal_libs=<br><span class="hljs-section">foo:<span class="hljs-variable">$(objects)</span></span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(CC)</span>,gcc)<br>    <span class="hljs-variable">$(CC)</span> -o foo <span class="hljs-variable">$(objects)</span> <span class="hljs-variable">$(libs_for_gcc)</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-variable">$(CC)</span> -o foo <span class="hljs-variable">$(objects)</span> <span class="hljs-variable">$(noemal_libs)</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure>

<p>条件语句中使用到三个关键字“ifeq”、“else”、“endif”。其中：“ifeq”表示条件语句的开始，并指定一个比较条件（相等）。括号和关键字之间要使用空格分隔，两个参数之间要使用逗号分隔。参数中的变量引用在进行变量值比较的时候被展开。“ifeq”，后面的是条件满足的时候执行的，条件不满足忽略；“else”表示当条件不满足的时候执行的部分，可以没有；“endif”是判断语句结束标志，Makefile 中条件判断的结束都要有。</p>
<p>ifneq的用法类似，只不过ifneq是用来了比较“参数1”和“参数2”是否不相等，如果不相等的话就为真。</p>
<h4 id="ifdef和ifndef"><a href="#ifdef和ifndef" class="headerlink" title="ifdef和ifndef"></a>ifdef和ifndef</h4><p>的用法如下：</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">ifdef <span class="hljs-attribute">&lt;变量名&gt;</span><br></code></pre></td></tr></table></figure>
<p>如果“变量名”的值非空，那么表示表达式为真，否则表达式为假。“变量名”同样可以是一个函数的返回值。  </p>
<p><strong>实例 1：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile">bar =<br>foo = <span class="hljs-variable">$(bar)</span><br><span class="hljs-section">all:</span><br><span class="hljs-keyword">ifdef</span> foo<br>    @echo yes<br><span class="hljs-keyword">else</span><br>    @echo  no<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure>
<p><strong>实例 2：</strong></p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">foo=<br>all:<br>ifdef foo<br>    @echo <span class="hljs-literal">yes</span><br><span class="hljs-keyword">else</span><br>    @echo  <span class="hljs-literal">no</span><br>endif<br></code></pre></td></tr></table></figure>

<p>通过打印 “yes” 或 “no” 来演示执行的结果。我们执行 make 可以看到实例 1打印的结果是 “yes” ，实例 2打印的结果是 “no” 。其原因就是在实例 1 中，变量“foo”的定义是“foo &#x3D; $(bar)”。虽然变量“bar”的值为空，但是“ifdef”的判断结果为真，这种方式判断显然是不行的，因此当我们需要判断一个变量的值是否为空的时候需要使用“ifeq” 而不是“ifdef”。</p>
<p>ifndef用法类似，但是含义用户ifdef相反</p>
<blockquote>
<p>注意：在条件表达式中不能使用自动化变量，自动化变量在规则命令执行时才有效</p>
</blockquote>
<h3 id="Makefile-函数使用"><a href="#Makefile-函数使用" class="headerlink" title="Makefile 函数使用"></a>Makefile 函数使用</h3><p>Makefile支持函数，类似C语言一样，Makefile中的函数是已经定义好的，我们直接使用，<strong>不支持我们自定义函数</strong>。make所支持的函数不多，但是绝对够我们使用了，函数的用法如下：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$(</span>函数名 参数集合)  <span class="hljs-comment"># 小括号</span><br></code></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$&#123;函数名 参数集合&#125;</span>  <span class="hljs-comment"># 大括号</span><br></code></pre></td></tr></table></figure>
<p>可以看出，调用函数和调用普通变量一样，使用符号“$”来标识。参数集合是函数的多个参数，参数之间以逗号“,”隔开，函数名和参数之间以“空格”分隔开，函数的调用以“$”开头。接下来我们介绍几个常用的函数。</p>
<h4 id="1、subst"><a href="#1、subst" class="headerlink" title="1、subst"></a>1、subst</h4><p>函数subst用来完成字符串替换，调用形式如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">subst</span> &lt;<span class="hljs-params">from</span>&gt;,&lt;<span class="hljs-params">to</span>&gt;,&lt;<span class="hljs-params">text</span>&gt;)</span><br></code></pre></td></tr></table></figure>
<p>此函数的功能是将字符串 <code>&lt;text&gt; 中的</code>&lt;from&gt;<code>内容替换为</code>&lt;to&gt;&#96;，函数返回被替换以后的字符串，比如如下示例：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">subst</span>  <span class="hljs-params">zzk</span>,ZZK,<span class="hljs-params">my</span> <span class="hljs-params">name</span> <span class="hljs-params">is</span> <span class="hljs-params">zzk</span>)</span><br></code></pre></td></tr></table></figure>
<p>把字符串 “myname is zzk” 中的 “zzk” 替换为“ZZK”，替换完成以后的字符串为“my name is ZZK”。</p>
<h4 id="2、patsubst"><a href="#2、patsubst" class="headerlink" title="2、patsubst"></a>2、patsubst</h4><p>函数patsubst用来完成模式字符串替换，使用方法如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">patsubst</span> &lt;<span class="hljs-params">pattern</span>&gt;,&lt;<span class="hljs-params">replacement</span>&gt;,&lt;<span class="hljs-params">text</span>&gt;)</span><br></code></pre></td></tr></table></figure>
<p>此函数查找字符串 <code>\&lt;text&gt;</code>中的单词是否符合模式<code>\&lt;pattern&gt;</code>，如果匹配就用 <code>\&lt;replacement&gt;</code> 来替换掉，<code>\&lt;pattern&gt;</code>可以使用包括通配符“%”，表示任意长度的字符串，函数返回值就是替换后的字符串。如果 <code>\&lt;replacement&gt;</code> 中也包涵“%”，那么 <code>\&lt;replacement&gt;</code> 中的“%”将是<code>\&lt;pattern&gt;</code> 中的那个“%”所代表的字符串，比如：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">patsubst</span> %.<span class="hljs-params">c</span>,%.<span class="hljs-params">o</span>,<span class="hljs-params">a</span>.<span class="hljs-params">c</span> <span class="hljs-params">b</span>.<span class="hljs-params">c</span> <span class="hljs-params">c</span>.<span class="hljs-params">c</span>)</span><br></code></pre></td></tr></table></figure>
<p>将字符串“a.c b.c c.c”中的所有符合“%.c”的字符串，替换为“%.o”，替换完成以后的字符串为“a.o b.o c.o”。</p>
<h4 id="3、dir"><a href="#3、dir" class="headerlink" title="3、dir"></a>3、dir</h4><p>函数dir用来获取目录，使用方法如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">dir</span>&lt;<span class="hljs-params">names</span><span class="hljs-operator">...</span>&gt;)</span><br></code></pre></td></tr></table></figure>
<p>此函数用来从文件名序列 <code> &lt;names&gt;</code> 中提取出目录名，返回值是文件名序列 <code>&lt;names&gt;</code>的目录部分，比如：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">dir</span> &lt;<span class="hljs-operator">/</span><span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">a</span>.<span class="hljs-params">c</span>&gt;)</span><br></code></pre></td></tr></table></figure>
<p>提取文件“&#x2F;src&#x2F;a.c”的目录部分，也就是“&#x2F;src”。</p>
<h4 id="4、notdir"><a href="#4、notdir" class="headerlink" title="4、notdir"></a>4、notdir</h4><p>去除文件中的目录部分，也就是提取文件名，用法如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">notdir</span> &lt;<span class="hljs-params">names</span><span class="hljs-operator">...</span>&gt;)</span><br></code></pre></td></tr></table></figure>
<p>此函数用与从文件名序列&lt;names&gt;中提取出文件名非目录部分，比如：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">notdir</span> &lt;<span class="hljs-operator">/</span><span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">a</span>.<span class="hljs-params">c</span>&gt;)</span><br></code></pre></td></tr></table></figure>
<p>提取文件“&#x2F;src&#x2F;a.c”中的非目录部分，也就是文件名“a.c”。</p>
<h4 id="5、foreach"><a href="#5、foreach" class="headerlink" title="5、foreach"></a>5、foreach</h4><p>foreach函数用来完成循环，用法如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">foreach</span> &lt;<span class="hljs-params">var</span>&gt;, &lt;<span class="hljs-params">list</span>&gt;,&lt;<span class="hljs-params">text</span>&gt;)</span><br></code></pre></td></tr></table></figure>
<p>此函数的意思就是把参数 <code>&lt;list&gt;</code> 中的单词逐一取出来放到参数 <code>&lt;var&gt;</code> 中，然后再执行 <code>&lt;text&gt;</code>所包含的表达式。每次 <code>&lt;text&gt;</code> 都会返回一个字符串，循环的过程中，<code>&lt;text&gt;</code>中所包含的每个字符串会以空格隔开，最后当整个循环结束时，<code>&lt;text&gt;</code>所返回的每个字符串所组成的整个字符串将会是函数foreach函数的返回值。比如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">name:=a b c d<br>files:=<span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> n,<span class="hljs-variable">$(names)</span>,<span class="hljs-variable">$(n)</span>.o)</span><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(files)</span><br></code></pre></td></tr></table></figure>
<p>执行 make 命令，我们得到的值是“a.o b.o c.o d.o”。</p>
<h4 id="6、wildcard"><a href="#6、wildcard" class="headerlink" title="6、wildcard"></a>6、wildcard</h4><p>通配符“%”只能用在规则中，只有在规则中它才会展开，如果在变量定义和函数使用时，通配符不会自动展开，这个时候就要用到函数wildcard，使用方法如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> PATTERN...)</span><br></code></pre></td></tr></table></figure>
<p>函数的功能是列出当前目录下所有符合模式 PATTERN 格式的文件名。返回值为空格分隔并且存在当前目录下的所有符合模式 PATTERN 的文件名。比如：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">wildcard</span> <span class="hljs-operator">*</span>.<span class="hljs-params">c</span>)</span><br></code></pre></td></tr></table></figure>
<p>上面的代码是用来获取当前目录下所有的 .c文件，类似“%”。这个函数通常跟的通配符 “*“ 连用，使用在依赖规则的描述的时候被展开</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a target="_blank" rel="noopener" href="https://www.google.com.hk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&ved=2ahUKEwjOovyO4pXtAhWCGaYKHfQjBuQQjBAwAXoECAYQAQ&url=https://seisman.github.io/how-to-write-makefile/Makefile.pdf&usg=AOvVaw3n6s_cIN9yn7MR2DstZbhd">跟我一起写Makefile</a><br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/02/make.html">Make 命令教程</a><br><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/make.html">GNU make</a><br><a target="_blank" rel="noopener" href="https://opensource.com/article/18/8/what-how-makefile">What is a Makefile and how does it work?</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7091.html">Makefile的工作流程</a><br><a target="_blank" rel="noopener" href="https://www.linuxidc.com/Linux/2018-01/150580.htm">Makefile编写入门教程</a></p>
<h3 id="shell-脚本"><a href="#shell-脚本" class="headerlink" title="shell 脚本"></a>shell 脚本</h3><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。<br>Shell 脚本（shell script），是一种为 shell 编写的脚本程序。类似windows的批处理文件，shell脚本就是将连续执行的命令写成一个文件。<br>shell脚本提供数组、循环、条件判断的等功能。shell脚本一般是Linux运维或者系统管理员要掌握的，作为嵌入式开发人员，只需要掌握shell脚本最基础的部分即可。</p>
<p>Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p>
<p>Linux 的 Shell 种类众多，常见的有：</p>
<ul>
<li>Bourne Shell（&#x2F;usr&#x2F;bin&#x2F;sh或&#x2F;bin&#x2F;sh）</li>
<li>Bourne Again Shell（&#x2F;bin&#x2F;bash）</li>
<li>C Shell（&#x2F;usr&#x2F;bin&#x2F;csh）</li>
<li>K Shell（&#x2F;usr&#x2F;bin&#x2F;ksh）</li>
<li>Shell for Root（&#x2F;sbin&#x2F;sh）</li>
</ul>
<p>本教程关注的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。</p>
<p>在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 <code>#!/bin/sh</code>，它同样也可以改为 <code>#!/bin/bash</code>。</p>
<p><code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。</p>
<blockquote>
<p>所以脚本其实就是短小的、用来让计算机自动化完成一系列工作的程序，这类程序可以用文本编辑器修改，不需要编译，通常是解释运行的。</p>
</blockquote>
<h4 id="第一个shell脚本"><a href="#第一个shell脚本" class="headerlink" title="第一个shell脚本"></a>第一个shell脚本</h4><p>shell脚本是个纯文本文件，命令从上而下，一行一行的开始执行。<br>使用 vim 新建一个文件 test.sh，<strong>扩展名并不影响脚本执行</strong>，见名知意就好。文本内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello World !&quot;</span><br></code></pre></td></tr></table></figure>
<p><code>#!</code> 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。<br><code>echo</code> 命令用于向窗口输出文本。<br>写完保存，我们还不能直接运行。<br><strong>运行 Shell 脚本有两种方法：</strong></p>
<ol>
<li><p>作为可执行程序<br>将上面的代码保存为 test.sh，在该文件目录下输出命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x ./test.sh  <span class="hljs-comment">#使脚本具有执行权限</span><br>./test.sh  <span class="hljs-comment">#执行脚本</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>作为解释器参数<br>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/bin/</span>sh test.sh<br><span class="hljs-regexp">/bin/</span>php test.php<br></code></pre></td></tr></table></figure>
<p>这种方式运行的脚本，不需要在程序第一行指定解释器信息（<code>#!/bin/bash</code>），写了也没用。</p>
</li>
</ol>
<h4 id="Shell-注释"><a href="#Shell-注释" class="headerlink" title="Shell 注释"></a>Shell 注释</h4><p>以 # 开头的行就是注释，会被解释器忽略。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment">## 这是一个注释</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello World !&quot;</span><br></code></pre></td></tr></table></figure>
<h5 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h5><p>多行注释可以使用以下格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">:&lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">注释内容...</span><br><span class="hljs-string">注释内容...</span><br><span class="hljs-string">注释内容...</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure>
<p>EOF 也可以使用其他符号:</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs erlang">:&lt;&lt;&#x27;<br>注释内容...<br>注释内容...<br>注释内容...<br>&#x27;<br>:&lt;&lt;!<br>注释内容...<br>注释内容...<br>注释内容...<br>!<br></code></pre></td></tr></table></figure>
<h4 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h4><p>定义变量时，变量名不加美元符号（$，PHP语言中变量需要），如：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">your_name</span>=<span class="hljs-string">&quot;runoob.com&quot;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p>
</blockquote>
<ul>
<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li>
<li>中间不能有空格，可以使用下划线（_）。</li>
<li>不能使用标点符号。</li>
<li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li>
</ul>
<h5 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h5><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，和 Makefile 类似：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">your_name=<span class="hljs-string">&quot;qinjx&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;your_name&#125;</span><br></code></pre></td></tr></table></figure>
<p>变量名外面的花括号是可选的，加不加都行，推荐给所有变量加上花括号。</p>
<h5 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h5><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>
<p>下面的例子尝试更改只读变量，结果报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>myUrl=<span class="hljs-string">&quot;https://www.google.com&quot;</span><br><span class="hljs-built_in">readonly</span> myUrl<br>myUrl=<span class="hljs-string">&quot;https://www.runoob.com&quot;</span><br></code></pre></td></tr></table></figure>
<p>运行脚本，结果如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/bin/</span>sh: NAME: <span class="hljs-keyword">This</span> variable is <span class="hljs-keyword">read</span> only.<br></code></pre></td></tr></table></figure>
<h5 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h5><p>使用 unset 命令可以删除变量。语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">unset</span> variable_name<br></code></pre></td></tr></table></figure>
<p>变量被删除后不能再次使用。unset 命令不能删除只读变量。</p>
<p>实例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>myUrl=<span class="hljs-string">&quot;https://www.runoob.com&quot;</span><br><span class="hljs-built_in">unset</span> myUrl<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$myUrl</span><br></code></pre></td></tr></table></figure>
<p>以上实例执行将没有任何输出。</p>
<h5 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h5><p>运行shell时，会同时存在三种变量：</p>
<ol>
<li>局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li>
<li>环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li>
<li>shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li>
</ol>
<h4 id="Shell-字符串"><a href="#Shell-字符串" class="headerlink" title="Shell 字符串"></a>Shell 字符串</h4><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。</p>
<h5 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h5><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">str</span>=<span class="hljs-string">&#x27;this is a string&#x27;</span><br></code></pre></td></tr></table></figure>
<p>单引号字符串的限制：</p>
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>
<li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li>
</ul>
<h5 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">your_name</span>=<span class="hljs-string">&#x27;runoob&#x27;</span><br><span class="hljs-attribute">str</span>=<span class="hljs-string">&quot;Hello, I know you are \&quot;<span class="hljs-variable">$your_name</span>\&quot;! \n&quot;</span><br>echo -e <span class="hljs-variable">$str</span><br></code></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">Hello,</span> I know you are <span class="hljs-string">&quot;runoob&quot;</span>! <br></code></pre></td></tr></table></figure>
<p>双引号的优点：</p>
<ul>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
<h5 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">your_name</span>=<span class="hljs-string">&quot;runoob&quot;</span><br><span class="hljs-comment">## 使用双引号拼接</span><br><span class="hljs-attribute">greeting</span>=<span class="hljs-string">&quot;hello, &quot;</span><span class="hljs-variable">$your_name</span><span class="hljs-string">&quot; !&quot;</span><br><span class="hljs-attribute">greeting_1</span>=<span class="hljs-string">&quot;hello, <span class="hljs-variable">$&#123;your_name&#125;</span> !&quot;</span><br>echo <span class="hljs-variable">$greeting</span>  <span class="hljs-variable">$greeting_1</span><br><span class="hljs-comment">## 使用单引号拼接</span><br><span class="hljs-attribute">greeting_2</span>=<span class="hljs-string">&#x27;hello, &#x27;</span><span class="hljs-variable">$your_name</span><span class="hljs-string">&#x27; !&#x27;</span><br><span class="hljs-attribute">greeting_3</span>=<span class="hljs-string">&#x27;hello, $&#123;your_name&#125; !&#x27;</span>  # 不能使用变量，会原样输出<br>echo <span class="hljs-variable">$greeting_2</span>  <span class="hljs-variable">$greeting_3</span><br></code></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">hello, runoob ! hello, runoob !<br>hello, runoob ! hello, $&#123;your_name&#125; !<br></code></pre></td></tr></table></figure>
<h5 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">string=<span class="hljs-string">&quot;abcd&quot;</span><br>echo $&#123;<span class="hljs-meta">#string&#125; #输出 4</span><br></code></pre></td></tr></table></figure>

<h5 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h5><p>以下实例从字符串第 2 个字符开始截取 4 个字符：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">string</span>=<span class="hljs-string">&quot;runoob is a great site&quot;</span><br><span class="hljs-keyword">echo</span> $&#123;<span class="hljs-keyword">string</span>:<span class="hljs-number">1</span>:<span class="hljs-number">4</span>&#125; <span class="hljs-comment"># 输出 unoo</span><br></code></pre></td></tr></table></figure>
<p>注意：第一个字符的索引值为 0。</p>
<h5 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h5><p>查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">string=<span class="hljs-string">&quot;runoob is a great site&quot;</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> index <span class="hljs-string">&quot;<span class="hljs-variable">$string</span>&quot;</span> io`  <span class="hljs-comment"># 输出 4</span><br></code></pre></td></tr></table></figure>

<p>注意： 以上脚本中  `  是反引号(键盘数字 1 左边按键)，而不是单引号 <code>&#39;</code>，不要看错了哦。</p>
<h4 id="Shell-数组"><a href="#Shell-数组" class="headerlink" title="Shell 数组"></a>Shell 数组</h4><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。<br>类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。  </p>
<h5 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h5><p>在 Shell 中，用括号来表示数组，数组元素用 “空格” 符号分割开。定义数组的一般形式为：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">数组名<span class="hljs-operator">=</span>(值<span class="hljs-number">1</span> 值<span class="hljs-number">2</span> ... 值n)<br></code></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">array_name</span>=(value0 value1 value2 value3)<br></code></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">array_name<span class="hljs-operator">=</span>(<br>value0<br>value1<br>value2<br>value3<br>)<br></code></pre></td></tr></table></figure>
<p>还可以单独定义数组的各个分量：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">array_name[<span class="hljs-number">0</span>]<span class="hljs-operator">=</span>value0<br>array_name[<span class="hljs-number">1</span>]<span class="hljs-operator">=</span>value1<br>array_name[n]<span class="hljs-operator">=</span>valuen<br></code></pre></td></tr></table></figure>
<p>可以不使用连续的下标，而且下标的范围没有限制。</p>
<h5 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h5><p>读取数组元素值的一般格式是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">$&#123;数组名[下标]&#125;<br></code></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">valuen=$&#123;array_name[n]&#125;<br></code></pre></td></tr></table></figure>
<p>使用 @ 符号可以获取数组中的所有元素，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">echo $&#123;array_name[@]&#125;<br></code></pre></td></tr></table></figure>
<p>会依次打印出数组中的所有元素。</p>
<h5 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h5><p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">## 取得数组元素的个数<br>length=$&#123;#array_name[@]&#125;<br>## 或者<br>length=$&#123;#array_name[*]&#125;<br>## 取得数组单个元素的长度<br>lengthn=$&#123;#array_name[n]&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Shell-传递参数"><a href="#Shell-传递参数" class="headerlink" title="Shell 传递参数"></a>Shell 传递参数</h4><p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……。</p>
<blockquote>
<p>0 为执行的文件名（包含文件路径）：</p>
</blockquote>
<p><strong>实例</strong><br>以下实例我们向脚本传递三个参数，并分别输出，其中 $0 为执行的文件名（包含文件路径）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Shell 传递参数实例！&quot;</span>;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;执行的文件名：<span class="hljs-variable">$0</span>&quot;</span>;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第一个参数为：<span class="hljs-variable">$1</span>&quot;</span>;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第二个参数为：<span class="hljs-variable">$2</span>&quot;</span>;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第三个参数为：<span class="hljs-variable">$3</span>&quot;</span>;<br></code></pre></td></tr></table></figure>
<p>为脚本设置可执行权限，并执行脚本，输出结果如下所示：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ chmod +x <span class="hljs-keyword">test</span>.<span class="hljs-keyword">sh</span> <br>$ ./<span class="hljs-keyword">test</span>.<span class="hljs-keyword">sh</span> 1 2 3<br><span class="hljs-keyword">Shell</span> 传递参数实例！<br>执行的文件名：./<span class="hljs-keyword">test</span>.<span class="hljs-keyword">sh</span><br>第一个参数为：1<br>第二个参数为：2<br>第三个参数为：3<br></code></pre></td></tr></table></figure>
<p>另外，还有几个特殊字符用来处理参数：</p>
<table>
<thead>
<tr>
<th>参数处理</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$#</td>
<td>传递到脚本的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>以一个单字符串显示所有向脚本传递的参数。如”$*“用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</td>
</tr>
<tr>
<td>$$</td>
<td>脚本运行的当前进程ID号</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td>$@</td>
<td>与$*相同，但是使用时加引号，并在引号中返回每个参数。 如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</td>
</tr>
<tr>
<td>$-</td>
<td>显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr>
<td>$?</td>
<td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Shell 传递参数实例！&quot;</span>;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第一个参数为：<span class="hljs-variable">$1</span>&quot;</span>;<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;参数个数为：<span class="hljs-variable">$#</span>&quot;</span>;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;传递的参数作为一个字符串显示：$*&quot;</span>;<br></code></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ chmod +x <span class="hljs-keyword">test</span>.<span class="hljs-keyword">sh</span> <br>$ ./<span class="hljs-keyword">test</span>.<span class="hljs-keyword">sh</span> 1 2 3<br><span class="hljs-keyword">Shell</span> 传递参数实例！<br>第一个参数为：1<br>参数个数为：3<br>传递的参数作为一个字符串显示：1 2 3<br></code></pre></td></tr></table></figure>
<p><em><em>$</em> 与 $@ 区别：</em>*</p>
<ul>
<li>相同点：都是引用所有参数。</li>
<li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-- \$* 演示1 ---&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;$*&quot;</span>; <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-- \$@ 演示2 ---&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>; <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">$ chmod</span> <span class="hljs-literal">+</span><span class="hljs-comment">x test</span><span class="hljs-string">.</span><span class="hljs-comment">sh</span> <br><span class="hljs-comment">$</span> <span class="hljs-string">.</span><span class="hljs-comment">/test</span><span class="hljs-string">.</span><span class="hljs-comment">sh 1 2 3</span><br><span class="hljs-literal">--</span> <span class="hljs-comment">$* 演示1</span> <span class="hljs-literal">---</span><br><span class="hljs-comment">1 2 3</span><br><span class="hljs-literal">--</span> <span class="hljs-comment">$@ 演示2</span> <span class="hljs-literal">---</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">3</span><br></code></pre></td></tr></table></figure>
<p>echo  执行默认回车，演示1 这里实际只执行了一次，演示2 执行了两次。 这里涉及 for 语句，后续将会讲解。</p>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>Shell 和其他编程语言一样，支持多种运算符，包括：</p>
<ul>
<li>算数运算符</li>
<li>关系运算符</li>
<li>布尔运算符</li>
<li>字符串运算符</li>
<li>文件测试运算符</li>
</ul>
<p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p>
<p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p>
<p>例如，两个数相加(注意<strong>使用的是反引号 ` 而不是单引号 ‘</strong>)：</p>
<p><strong>实例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>val=`<span class="hljs-built_in">expr</span> 2 + 2`  <span class="hljs-comment"># 推荐使用 val=$(expr 2 + 2)</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;两数之和为 : <span class="hljs-variable">$val</span>&quot;</span><br></code></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">两数之和为 : 4<br></code></pre></td></tr></table></figure>
<p>两点注意：</p>
<ul>
<li>表达式和运算符之间要有空格，例如 <code>2+2</code> 是不对的，必须写成 <code>2 + 2</code>，这与我们熟悉的大多数编程语言不一样。</li>
<li>完整的表达式要被 <code> </code> 反引号包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li>
</ul>
<h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><p>下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法</td>
<td><code>expr $a + $b</code> 结果为 30</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td><code>expr $a - $b</code> 结果为 -10。</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td><code>expr $a \* $b</code> 结果为  200。</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>除法</td>
<td><code>expr $b / $a</code> 结果为 2。</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td><code>expr $b % $a</code> 结果为 0。</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>赋值</td>
<td>a&#x3D;$b 将把变量 b 的值赋给 a。</td>
</tr>
<tr>
<td>&#x3D;&#x3D;</td>
<td>相等</td>
<td>用于比较两个数字，相同则返回 true。[ $a &#x3D;&#x3D; $b ] 返回 false</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不相等</td>
<td>用于比较两个数字，不相同则返回 true。	[ $a !&#x3D; $b ] 返回 true。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 条件表达式要放在方括号之间，并且要有空格，例如: [$a&#x3D;&#x3D;$b] 是错误的，必须写成 [ $a &#x3D;&#x3D; $b ]。</p>
<p><strong>实例</strong><br>算术运算符实例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>a=10<br>b=20<br><br>val=`<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> + <span class="hljs-variable">$b</span>`<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a + b : <span class="hljs-variable">$val</span>&quot;</span><br><br>val=`<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> - <span class="hljs-variable">$b</span>`<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a - b : <span class="hljs-variable">$val</span>&quot;</span><br><br>val=`<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> \* <span class="hljs-variable">$b</span>`<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a * b : <span class="hljs-variable">$val</span>&quot;</span><br><br>val=`<span class="hljs-built_in">expr</span> <span class="hljs-variable">$b</span> / <span class="hljs-variable">$a</span>`<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;b / a : <span class="hljs-variable">$val</span>&quot;</span><br><br>val=`<span class="hljs-built_in">expr</span> <span class="hljs-variable">$b</span> % <span class="hljs-variable">$a</span>`<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;b % a : <span class="hljs-variable">$val</span>&quot;</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> == <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a 等于 b&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a 不等于 b&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span> : <span class="hljs-number">30</span><br><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">b</span> : <span class="hljs-selector-tag">-10</span><br><span class="hljs-selector-tag">a</span> * <span class="hljs-selector-tag">b</span> : <span class="hljs-number">200</span><br><span class="hljs-selector-tag">b</span> / <span class="hljs-selector-tag">a</span> : <span class="hljs-number">2</span><br><span class="hljs-selector-tag">b</span> % <span class="hljs-selector-tag">a</span> : <span class="hljs-number">0</span><br><span class="hljs-selector-tag">a</span> 不等于 <span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ul>
<li>乘号(*)前边必须加反斜杠()才能实现乘法运算；</li>
<li>if…then…fi 是条件语句，后续将会讲解。</li>
<li>在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 “*“ 不需要转义符号 “&quot; 。</li>
</ul>
</blockquote>
<h5 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h5><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>检测两个数是否相等，相等返回 true。</td>
<td>[ $a -eq $b ] 返回 false。</td>
</tr>
<tr>
<td>-ne</td>
<td>检测两个数是否不相等，不相等返回 true。</td>
<td>[ $a -ne $b ] 返回 true。</td>
</tr>
<tr>
<td>-gt</td>
<td>检测左边的数是否大于右边的，如果是，则返回 true。</td>
<td>[ $a -gt $b ] 返回 false。</td>
</tr>
<tr>
<td>-lt</td>
<td>检测左边的数是否小于右边的，如果是，则返回 true。</td>
<td>[ $a -lt $b ] 返回 true。</td>
</tr>
<tr>
<td>-ge</td>
<td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td>
<td>[ $a -ge $b ] 返回 false。</td>
</tr>
<tr>
<td>-le</td>
<td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
<td>[ $a -le $b ] 返回 true。</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>a=10<br>b=20<br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -eq <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -eq <span class="hljs-variable">$b</span> : a 等于 b&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -eq <span class="hljs-variable">$b</span>: a 不等于 b&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -ne <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -ne <span class="hljs-variable">$b</span>: a 不等于 b&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -ne <span class="hljs-variable">$b</span> : a 等于 b&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -gt <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -gt <span class="hljs-variable">$b</span>: a 大于 b&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -gt <span class="hljs-variable">$b</span>: a 不大于 b&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -lt <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -lt <span class="hljs-variable">$b</span>: a 小于 b&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -lt <span class="hljs-variable">$b</span>: a 不小于 b&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -ge <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -ge <span class="hljs-variable">$b</span>: a 大于或等于 b&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -ge <span class="hljs-variable">$b</span>: a 小于 b&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -le <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -le <span class="hljs-variable">$b</span>: a 小于或等于 b&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -le <span class="hljs-variable">$b</span>: a 大于 b&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span>-eq <span class="hljs-number">20</span>: a 不等于 b<br><span class="hljs-symbol">10 </span>-ne <span class="hljs-number">20</span>: a 不等于 b<br><span class="hljs-symbol">10 </span>-gt <span class="hljs-number">20</span>: a 不大于 b<br><span class="hljs-symbol">10 </span>-lt <span class="hljs-number">20</span>: a 小于 b<br><span class="hljs-symbol">10 </span>-ge <span class="hljs-number">20</span>: a 小于 b<br><span class="hljs-symbol">10 </span>-le <span class="hljs-number">20</span>: a 小于或等于 b<br></code></pre></td></tr></table></figure>

<h5 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h5><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>!</td>
<td>非运算，表达式为 true 则返回 false，否则返回 true。</td>
<td>[ ! false ] 返回 true。</td>
</tr>
<tr>
<td>-o</td>
<td>或运算，有一个表达式为 true 则返回 true。</td>
<td>[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td>
</tr>
<tr>
<td>-a</td>
<td>与运算，两个表达式都为 true 才返回 true。</td>
<td>[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>a=10<br>b=20<br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span> : a 不等于 b&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> == <span class="hljs-variable">$b</span>: a 等于 b&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -lt 100 -a <span class="hljs-variable">$b</span> -gt 15 ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> 小于 100 且 <span class="hljs-variable">$b</span> 大于 15 : 返回 true&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> 小于 100 且 <span class="hljs-variable">$b</span> 大于 15 : 返回 false&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -lt 100 -o <span class="hljs-variable">$b</span> -gt 100 ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> 小于 100 或 <span class="hljs-variable">$b</span> 大于 100 : 返回 true&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> 小于 100 或 <span class="hljs-variable">$b</span> 大于 100 : 返回 false&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -lt 5 -o <span class="hljs-variable">$b</span> -gt 100 ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> 小于 5 或 <span class="hljs-variable">$b</span> 大于 100 : 返回 true&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> 小于 5 或 <span class="hljs-variable">$b</span> 大于 100 : 返回 false&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span>!= <span class="hljs-number">20</span> : a 不等于 b<br><span class="hljs-symbol">10 </span>小于 <span class="hljs-number">100</span> 且 <span class="hljs-number">20</span> 大于 <span class="hljs-number">15</span> : 返回 true<br><span class="hljs-symbol">10 </span>小于 <span class="hljs-number">100</span> 或 <span class="hljs-number">20</span> 大于 <span class="hljs-number">100</span> : 返回 true<br><span class="hljs-symbol">10 </span>小于 <span class="hljs-number">5</span> 或 <span class="hljs-number">20</span> 大于 <span class="hljs-number">100</span> : 返回 false<br></code></pre></td></tr></table></figure>

<h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p>以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>逻辑的 AND</td>
<td>[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td>
</tr>
<tr>
<td>||</td>
<td>逻辑的 OR</td>
<td>[[ $a -lt 100</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>a=10<br>b=20<br><br><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$a</span> -lt 100 &amp;&amp; <span class="hljs-variable">$b</span> -gt 100 ]]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;返回 true&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;返回 false&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$a</span> -lt 100 || <span class="hljs-variable">$b</span> -gt 100 ]]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;返回 true&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;返回 false&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">返回 <span class="hljs-literal">false</span><br>返回 <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<h5 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h5><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>检测两个字符串是否相等，相等返回 true。</td>
<td>[ $a &#x3D; $b ] 返回 false。</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>检测两个字符串是否相等，不相等返回 true。</td>
<td>[ $a !&#x3D; $b ] 返回 true。</td>
</tr>
<tr>
<td>-z</td>
<td>检测字符串长度是否为0，为0返回 true。</td>
<td>[ -z $a ] 返回 false。</td>
</tr>
<tr>
<td>-n</td>
<td>检测字符串长度是否不为 0，不为 0 返回 true。</td>
<td>[ -n “$a” ] 返回 true。</td>
</tr>
<tr>
<td>$</td>
<td>检测字符串是否为空，不为空返回 true。</td>
<td>[ $a ] 返回 true。</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>a=<span class="hljs-string">&quot;abc&quot;</span><br>b=<span class="hljs-string">&quot;efg&quot;</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> = <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> = <span class="hljs-variable">$b</span> : a 等于 b&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> = <span class="hljs-variable">$b</span>: a 不等于 b&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span> : a 不等于 b&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span>: a 等于 b&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ -z <span class="hljs-variable">$a</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-z <span class="hljs-variable">$a</span> : 字符串长度为 0&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-z <span class="hljs-variable">$a</span> : 字符串长度不为 0&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$a</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-n <span class="hljs-variable">$a</span> : 字符串长度不为 0&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-n <span class="hljs-variable">$a</span> : 字符串长度为 0&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> : 字符串不为空&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> : 字符串为空&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">abc</span> <span class="hljs-string">=</span> <span class="hljs-attr">efg:</span> <span class="hljs-string">a</span> <span class="hljs-string">不等于</span> <span class="hljs-string">b</span><br><span class="hljs-string">abc</span> <span class="hljs-type">!=</span> <span class="hljs-attr">efg :</span> <span class="hljs-string">a</span> <span class="hljs-string">不等于</span> <span class="hljs-string">b</span><br><span class="hljs-string">-z</span> <span class="hljs-attr">abc :</span> <span class="hljs-string">字符串长度不为</span> <span class="hljs-number">0</span><br><span class="hljs-string">-n</span> <span class="hljs-attr">abc :</span> <span class="hljs-string">字符串长度不为</span> <span class="hljs-number">0</span><br><span class="hljs-attr">abc :</span> <span class="hljs-string">字符串不为空</span><br></code></pre></td></tr></table></figure>


<h5 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h5><p>文件测试运算符用于检测 Unix 文件的各种属性。</p>
<p>属性检测描述如下：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>-b file</td>
<td>检测文件是否是块设备文件，如果是，则返回 true。</td>
<td>[ -b $file ] 返回 false。</td>
</tr>
<tr>
<td>-c file</td>
<td>检测文件是否是字符设备文件，如果是，则返回 true。</td>
<td>[ -c $file ] 返回 false。</td>
</tr>
<tr>
<td>-d file</td>
<td>检测文件是否是目录，如果是，则返回 true。</td>
<td>[ -d $file ] 返回 false。</td>
</tr>
<tr>
<td>-f file</td>
<td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>
<td>[ -f $file ] 返回 true。</td>
</tr>
<tr>
<td>-g file	v检测文件是否设置了 SGID 位，如果是，则返回 true。其他检查符：</td>
<td>[ -g $file ] 返回 false。</td>
<td></td>
</tr>
<tr>
<td>-k file</td>
<td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>
<td>[ -k $file ] 返回 false。</td>
</tr>
<tr>
<td>-p file</td>
<td>检测文件是否是有名管道，如果是，则返回 true。</td>
<td>[ -p $file ] 返回 false。</td>
</tr>
<tr>
<td>-u file</td>
<td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td>
<td>[ -u $file ] 返回 false。</td>
</tr>
<tr>
<td>-r file</td>
<td>检测文件是否可读，如果是，则返回 true。</td>
<td>[ -r $file ] 返回 true。</td>
</tr>
<tr>
<td>-w file</td>
<td>检测文件是否可写，如果是，则返回 true。</td>
<td>[ -w $file ] 返回 true。</td>
</tr>
<tr>
<td>-x file</td>
<td>检测文件是否可执行，如果是，则返回 true。</td>
<td>[ -x $file ] 返回 true。</td>
</tr>
<tr>
<td>-s file</td>
<td>检测文件是否为空（文件大小是否大于0），不为空返回 true。</td>
<td>[ -s $file ] 返回 true。</td>
</tr>
<tr>
<td>-e file</td>
<td>检测文件（包括目录）是否存在，如果是，则返回 true。</td>
<td>[ -e $file ] 返回 true。其他检查符：</td>
</tr>
</tbody></table>
<p>其他检查符：</p>
<ul>
<li>-S: 判断某文件是否 socket。</li>
<li>-L: 检测文件是否存在并且是一个符号链接。</li>
</ul>
<p><strong>实例</strong><br>变量 file 表示文件 &#x2F;var&#x2F;www&#x2F;runoob&#x2F;test.sh，它的大小为 100 字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>file=<span class="hljs-string">&quot;/var/www/runoob/test.sh&quot;</span><br><span class="hljs-keyword">if</span> [ -r <span class="hljs-variable">$file</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;文件可读&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;文件不可读&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ -w <span class="hljs-variable">$file</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;文件可写&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;文件不可写&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ -x <span class="hljs-variable">$file</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;文件可执行&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;文件不可执行&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ -f <span class="hljs-variable">$file</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;文件为普通文件&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;文件为特殊文件&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ -d <span class="hljs-variable">$file</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;文件是个目录&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;文件不是个目录&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ -s <span class="hljs-variable">$file</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;文件不为空&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;文件为空&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ -e <span class="hljs-variable">$file</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;文件存在&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;文件不存在&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">文件可读<br>文件可写<br>文件可执行<br>文件为普通文件<br>文件不是个目录<br>文件不为空<br>文件存在<br></code></pre></td></tr></table></figure>

<h4 id="Shell-printf-命令"><a href="#Shell-printf-命令" class="headerlink" title="Shell printf 命令"></a>Shell printf 命令</h4><p>printf 命令模仿 C 程序库（library）里的 printf() 程序。</p>
<p>printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。</p>
<p>printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n。</p>
<p>printf 命令的语法：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">printf  <span class="hljs-keyword">format</span>-<span class="hljs-keyword">string</span>  [arguments...]<br></code></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ul>
<li>format-string: 为格式控制字符串</li>
<li>arguments: 为参数列表。</li>
</ul>
<p>实例如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello, Shell&quot;</span></span><br>Hello, Shell<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;Hello, Shell\n&quot;</span></span><br>Hello, Shell<br><span class="hljs-meta prompt_">$</span><br></code></pre></td></tr></table></figure>
<p>接下来,我来用一个脚本来体现printf的强大功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%-10s %-8s %-4s\n&quot;</span> 姓名 性别 体重kg  <br><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 郭靖 男 66.1234 <br><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 杨过 男 48.6543 <br><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 郭芙 女 47.9876 <br></code></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">姓名     性别   体重kg<br>郭靖     男      66.12<br>杨过     男      48.65<br>郭芙     女      47.99<br></code></pre></td></tr></table></figure>
<p>%s %c %d %f都是格式替代符</p>
<p>%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</p>
<p>%-4.2f 指格式化为小数，其中.2指保留2位小数。</p>
<h4 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h4><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p>
<h5 id="数值测试"><a href="#数值测试" class="headerlink" title="数值测试"></a>数值测试</h5><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>等于则为真</td>
</tr>
<tr>
<td>-ne</td>
<td>不等于则为真</td>
</tr>
<tr>
<td>-gt</td>
<td>大于则为真</td>
</tr>
<tr>
<td>-ge</td>
<td>大于等于则为真</td>
</tr>
<tr>
<td>-lt</td>
<td>小于则为真</td>
</tr>
<tr>
<td>-le</td>
<td>小于等于则为真</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">num1=100<br>num2=100<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> $[num1] -eq $[num2]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;两个数相等！&#x27;</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;两个数不相等！&#x27;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">两个数相等！<br></code></pre></td></tr></table></figure>
<p>代码中的 [] 执行基本的算数运算，如：</p>
<p><strong>实例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>a=5<br>b=6<br><br>result=$[a+b] <span class="hljs-comment"># 注意等号两边不能有空格</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;result 为： <span class="hljs-variable">$result</span>&quot;</span><br></code></pre></td></tr></table></figure>
<p>结果为:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">result</span> 为： <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure>

<h5 id="字符串测试"><a href="#字符串测试" class="headerlink" title="字符串测试"></a>字符串测试</h5><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>等于则为真</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不相等则为真</td>
</tr>
<tr>
<td>-z 字符串</td>
<td>字符串的长度为零则为真</td>
</tr>
<tr>
<td>-n 字符串</td>
<td>字符串的长度不为零则为真</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">num1=<span class="hljs-string">&quot;ru1noob&quot;</span><br>num2=<span class="hljs-string">&quot;runoob&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> <span class="hljs-variable">$num1</span> = <span class="hljs-variable">$num2</span><br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;两个字符串相等!&#x27;</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;两个字符串不相等!&#x27;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">两个字符串不相等!<br></code></pre></td></tr></table></figure>
<h5 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h5><p>| 参数 |	说明 |<br>| -e 文件名	|如果文件存在则为真|<br>| -r 文件名	| 如果文件存在且可读则为真  |<br>| -w 文件名	| 如果文件存在且可写则为真  |<br>| -x 文件名	| 如果文件存在且可执行则为真|<br>|-s 文件名	| 如果文件存在且至少有一个字符则为真|<br>| -d 文件名	| 如果文件存在且为目录则为真 |<br>| -f 文件名	| 如果文件存在且为普通文件则为真  |<br>|  -c 文件名	| 如果文件存在且为字符型特殊文件则为真  |<br>| -b 文件名	| 如果文件存在且为块特殊文件则为真  |</p>
<p><strong>实例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /bin<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> -e ./bash<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;文件已存在!&#x27;</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;文件不存在!&#x27;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">文件已存在!<br></code></pre></td></tr></table></figure>
<p>另外，Shell 还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为： ! 最高， -a 次之， -o 最低。例如：</p>
<p><strong>实例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /bin<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> -e ./notFile -o -e ./bash<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;至少有一个文件存在!&#x27;</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;两个文件都不存在&#x27;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">至少有一个文件存在!<br></code></pre></td></tr></table></figure>
<h5 id="参考链接-4"><a href="#参考链接-4" class="headerlink" title="参考链接"></a>参考链接</h5><ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-shell-test.html">Shell test 命令</a></li>
</ul>
<p>test命令用于查看文件是否存在、权限等信息，可以进行数值，字符，文件三方面的测试。</p>
<h4 id="Shell-流程控制"><a href="#Shell-流程控制" class="headerlink" title="Shell 流程控制"></a>Shell 流程控制</h4><h5 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h5><p><strong>if 语句语法格式：</strong></p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">if</span> condition<br>then<br>    <span class="hljs-keyword">command</span>1 <br>    <span class="hljs-keyword">command</span>2<br>    <span class="hljs-string">...</span><br>    <span class="hljs-keyword">command</span>N <br>fi<br></code></pre></td></tr></table></figure>
<p>写成一行（适用于终端命令提示符）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ $(ps -ef | grep -c <span class="hljs-string">&quot;ssh&quot;</span>) -gt 1 ]; <span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;true&quot;</span>; <span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<p>末尾的fi就是if倒过来拼写，后面还会遇到类似的。</p>
<p><strong>if else 语法格式：</strong></p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">if</span> condition<br>then<br>    <span class="hljs-keyword">command</span>1 <br>    <span class="hljs-keyword">command</span>2<br>    <span class="hljs-string">...</span><br>    <span class="hljs-keyword">command</span>N<br>else<br>    <span class="hljs-keyword">command</span><br>fi<br></code></pre></td></tr></table></figure>

<p><strong>if else-if else 语法格式：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> condition1<br><span class="hljs-keyword">then</span><br>    command1<br><span class="hljs-keyword">elif</span> condition2 <br><span class="hljs-keyword">then</span> <br>    command2<br><span class="hljs-keyword">else</span><br>    commandN<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<p>以下实例判断两个变量是否相等：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">a=10<br>b=20<br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> == <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a 等于 b&quot;</span><br><span class="hljs-keyword">elif</span> [ <span class="hljs-variable">$a</span> -gt <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a 大于 b&quot;</span><br><span class="hljs-keyword">elif</span> [ <span class="hljs-variable">$a</span> -lt <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a 小于 b&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;没有符合的条件&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> 小于 <span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure>
<p>if else语句经常与test命令结合使用，如下所示：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gams">num1=<span class="hljs-symbol">$</span>[<span class="hljs-number">2</span>*<span class="hljs-number">3</span>]<br>num2=<span class="hljs-symbol">$</span>[<span class="hljs-number">1</span>+<span class="hljs-number">5</span>]<br><span class="hljs-keyword">if</span> test <span class="hljs-symbol">$</span>[num1] -<span class="hljs-keyword">eq</span> <span class="hljs-symbol">$</span>[num2]<br><span class="hljs-keyword">then</span><br>    echo <span class="hljs-string">&#x27;两个数字相等!&#x27;</span><br><span class="hljs-keyword">else</span><br>    echo <span class="hljs-string">&#x27;两个数字不相等!&#x27;</span><br>fi<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">两个数字相等!<br></code></pre></td></tr></table></figure>
<h5 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h5><p>for循环一般格式为：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">for var in item1 item2 <span class="hljs-string">...</span> itemN<br>do<br>    <span class="hljs-keyword">command</span>1<br>    <span class="hljs-keyword">command</span>2<br>    <span class="hljs-string">...</span><br>    <span class="hljs-keyword">command</span>N<br>done<br></code></pre></td></tr></table></figure>
<p>写成一行：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">for var in item1 item2 <span class="hljs-string">...</span> itemN; do <span class="hljs-keyword">command</span>1; <span class="hljs-keyword">command</span>2… done;<br></code></pre></td></tr></table></figure>
<p>上面格式对于习惯其他语言 for 循环的朋友来说可能有点别扭。下面格式的 for 循环与 C 中的相似，但并不完全相同。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for((assignment<span class="hljs-comment">;condition:next));do</span><br>    command_1<span class="hljs-comment">;</span><br>    command_2<span class="hljs-comment">;</span><br>    commond_..<span class="hljs-comment">;</span><br>done<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<p>通常情况下 shell 变量调用需要加 $,但是 for 的 (()) 中不需要,下面来看一个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">for</span>((i=1;i&lt;=5;i++));<span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;这是第 <span class="hljs-variable">$i</span> 次调用&quot;</span>;<br><span class="hljs-keyword">done</span>;<br></code></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">这是第1次调用<br>这是第2次调用<br>这是第3次调用<br>这是第4次调用<br>这是第5次调用<br></code></pre></td></tr></table></figure>

<p>当变量值在列表里，for循环即执行一次所有命令，<strong>使用变量名获取列表中的当前取值</strong>(注意这里的区别，这里的变量变成了列表中的值)。命令可为任何有效的shell命令和语句。in列表可以包含替换、字符串和文件名。<br>in列表是可选的，如果不用它，for循环使用命令行的位置参数。</p>
<p>例如，顺序输出当前列表中的数字：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span> loop in <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">do</span><br>    <span class="hljs-attribute">echo</span> <span class="hljs-string">&quot;The value is: $loop&quot;</span><br><span class="hljs-attribute">done</span>\<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">The value <span class="hljs-keyword">is</span>: <span class="hljs-number">1</span><br>The value <span class="hljs-keyword">is</span>: <span class="hljs-number">2</span><br>The value <span class="hljs-keyword">is</span>: <span class="hljs-number">4</span><br>The value <span class="hljs-keyword">is</span>: <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
<p>顺序输出字符串中的字符：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> str <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;This is a string&#x27;</span><br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$str</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">This <span class="hljs-keyword">is</span> a <span class="hljs-built_in">string</span><br></code></pre></td></tr></table></figure>
<h5 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h5><p>while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> condition<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<p>以下是一个基本的while循环，测试条件是：如果int小于等于5，那么条件返回真。int从0开始，每次循环处理时，int加1。运行上述脚本，返回数字1到5，然后终止。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>int=1<br><span class="hljs-keyword">while</span>(( <span class="hljs-variable">$int</span>&lt;=5 ))<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$int</span><br>    <span class="hljs-built_in">let</span> <span class="hljs-string">&quot;int++&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<p>运行脚本，输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br>3<br>4<br>5<br></code></pre></td></tr></table></figure>
<p>以上实例使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量，具体可查阅：Bash let 命令。</p>
<h5 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h5><p>无限循环语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> :<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for (( <span class="hljs-comment">; ; ))</span><br></code></pre></td></tr></table></figure>
<h5 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h5><p>until 循环执行一系列命令直至条件为 true 时停止。<br>until 循环与 while 循环在处理方式上刚好相反。<br>一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。  </p>
<p>until 语法格式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">until condition<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<p>condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。</p>
<p>以下实例我们使用 until 命令来输出 0 ~ 9 的数字：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>a=0<br><br>until [ ! <span class="hljs-variable">$a</span> -lt 10 ]<br><span class="hljs-keyword">do</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span><br>   a=`<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> + 1`<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs">输出结果为：<br><br>0<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br></code></pre></td></tr></table></figure>
<h5 id="case"><a href="#case" class="headerlink" title="case"></a>case</h5><p>case … esac 与其他语言中的 switch … case 语句类似，是一种多分枝选择结构，每个 case 分支用右圆括号开始，用两个分号 ;; 表示 break，即执行结束，跳出整个 case … esac 语句，esac（就是 case 反过来）作为结束标记。case语句格式如下：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">case 值 in<br>模式1)<br>    <span class="hljs-keyword">command</span>1<br>    <span class="hljs-keyword">command</span>2<br>    ;;<br>模式2）<br>    <span class="hljs-keyword">command</span>1<br>    <span class="hljs-keyword">command</span>2<br>    ;;<br> *)   <span class="hljs-comment"># 类似 default</span><br>    <span class="hljs-keyword">command</span>1<br>    <span class="hljs-keyword">command</span>2<br>    ;;<br>esac<br></code></pre></td></tr></table></figure>
<p>case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。<br>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</p>
<p>下面的脚本提示输入1到4，与每一种模式进行匹配：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;输入 1 到 4 之间的数字:&#x27;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;你输入的数字为:&#x27;</span><br><span class="hljs-built_in">read</span> aNum<br><span class="hljs-keyword">case</span> <span class="hljs-variable">$aNum</span> <span class="hljs-keyword">in</span><br>    1)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;你选择了 1&#x27;</span><br>    ;;<br>    2)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;你选择了 2&#x27;</span><br>    ;;<br>    3)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;你选择了 3&#x27;</span><br>    ;;<br>    4)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;你选择了 4&#x27;</span><br>    ;;<br>    *)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;你没有输入 1 到 4 之间的数字&#x27;</span><br>    ;;<br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure>
<p>输入不同的内容，会有不同的结果，例如：</p>
<figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">输入 1 到 4 之间的数字</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">你输入的数字为</span><span class="hljs-punctuation">:</span><br>3<br>你选择了 3<br></code></pre></td></tr></table></figure>
<h5 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h5><p>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。</p>
<p><strong>break命令</strong></p>
<p>break命令允许跳出所有循环（终止执行后面的所有循环）。</p>
<p>下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">while</span> :<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;输入 1 到 5 之间的数字:&quot;</span><br>    <span class="hljs-built_in">read</span> aNum<br>    <span class="hljs-keyword">case</span> <span class="hljs-variable">$aNum</span> <span class="hljs-keyword">in</span><br>        1|2|3|4|5) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;你输入的数字为 <span class="hljs-variable">$aNum</span>!&quot;</span><br>        ;;<br>        *) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;</span><br>            <span class="hljs-built_in">break</span><br>        ;;<br>    <span class="hljs-keyword">esac</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入<span class="hljs-number"> 1 </span>到<span class="hljs-number"> 5 </span>之间的数字:3<br>你输入的数字为 3!<br>输入<span class="hljs-number"> 1 </span>到<span class="hljs-number"> 5 </span>之间的数字:7<br>你输入的数字不是<span class="hljs-number"> 1 </span>到<span class="hljs-number"> 5 </span>之间的! 游戏结束<br></code></pre></td></tr></table></figure>
<h5 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h5><p>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p>
<p>对上面的例子进行修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">while</span> :<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;输入 1 到 5 之间的数字: &quot;</span><br>    <span class="hljs-built_in">read</span> aNum<br>    <span class="hljs-keyword">case</span> <span class="hljs-variable">$aNum</span> <span class="hljs-keyword">in</span><br>        1|2|3|4|5) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;你输入的数字为 <span class="hljs-variable">$aNum</span>!&quot;</span><br>        ;;<br>        *) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;你输入的数字不是 1 到 5 之间的!&quot;</span><br>            <span class="hljs-built_in">continue</span><br>            <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;游戏结束&quot;</span><br>        ;;<br>    <span class="hljs-keyword">esac</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<p>运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 echo “游戏结束” 永远不会被执行。</p>
<h4 id="Shell函数"><a href="#Shell函数" class="headerlink" title="Shell函数"></a>Shell函数</h4><p>linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。</p>
<p>shell中函数的定义格式如下：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ada">[ <span class="hljs-keyword">function</span> <span class="hljs-title">]</span> funname [()]<br><br>&#123;<br><br>    action;<br><br>    [<span class="hljs-keyword">return</span> <span class="hljs-type">int</span>;]<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li>
<li>2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255</li>
</ul>
<p>下面的例子定义了一个函数并进行调用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-function"><span class="hljs-title">demoFun</span></span>()&#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;这是我的第一个 shell 函数!&quot;</span><br>&#125;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-----函数开始执行-----&quot;</span><br>demoFun<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-----函数执行完毕-----&quot;</span><br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">-----</span><span class="hljs-comment">函数开始执行</span><span class="hljs-literal">-----</span><br><span class="hljs-comment">这是我的第一个 shell 函数!</span><br><span class="hljs-literal">-----</span><span class="hljs-comment">函数执行完毕</span><br></code></pre></td></tr></table></figure>
<p>下面定义一个带有return语句的函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-function"><span class="hljs-title">funWithReturn</span></span>()&#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;这个函数会对输入的两个数字进行相加运算...&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;输入第一个数字: &quot;</span><br>    <span class="hljs-built_in">read</span> aNum<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;输入第二个数字: &quot;</span><br>    <span class="hljs-built_in">read</span> anotherNum<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;两个数字分别为 <span class="hljs-variable">$aNum</span> 和 <span class="hljs-variable">$anotherNum</span> !&quot;</span><br>    <span class="hljs-built_in">return</span> $((<span class="hljs-variable">$aNum</span>+<span class="hljs-variable">$anotherNum</span>))<br>&#125;<br>funWithReturn<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;输入的两个数字之和为 $? !&quot;</span><br></code></pre></td></tr></table></figure>
<p>输出类似下面：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">这个函数会对输入的两个数字进行相加运算...<br>输入第一个数字: <br>1<br>输入第二个数字: <br>2<br>两个数字分别为<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 2 </span>!<br>输入的两个数字之和为<span class="hljs-number"> 3 </span>!<br></code></pre></td></tr></table></figure>
<p>函数返回值在调用该函数后通过 $? 来获得。</p>
<p>注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</p>
<h5 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h5><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数…</p>
<p>带参数的函数示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-function"><span class="hljs-title">funWithParam</span></span>()&#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第一个参数为 <span class="hljs-variable">$1</span> !&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第二个参数为 <span class="hljs-variable">$2</span> !&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第十个参数为 <span class="hljs-variable">$10</span> !&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第十个参数为 <span class="hljs-variable">$&#123;10&#125;</span> !&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第十一个参数为 <span class="hljs-variable">$&#123;11&#125;</span> !&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;参数总数有 <span class="hljs-variable">$#</span> 个!&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;作为一个字符串输出所有参数 $* !&quot;</span><br>&#125;<br>funWithParam 1 2 3 4 5 6 7 8 9 34 73<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">第一个参数为<span class="hljs-number"> 1 </span>!<br>第二个参数为<span class="hljs-number"> 2 </span>!<br>第十个参数为<span class="hljs-number"> 10 </span>!<br>第十个参数为<span class="hljs-number"> 34 </span>!<br>第十一个参数为<span class="hljs-number"> 73 </span>!<br>参数总数有<span class="hljs-number"> 11 </span>个!<br>作为一个字符串输出所有参数<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 5 </span>6<span class="hljs-number"> 7 </span>8<span class="hljs-number"> 9 </span>34<span class="hljs-number"> 73 </span>!<br></code></pre></td></tr></table></figure>
<p>注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;&#x3D;10时，需要使用${n}来获取参数。</p>
<p>另外，还有几个特殊字符用来处理参数：</p>
<table>
<thead>
<tr>
<th>参数处理</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$#</td>
<td>传递到脚本或函数的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>以一个单字符串显示所有向脚本传递的参数</td>
</tr>
<tr>
<td>$$</td>
<td>脚本运行的当前进程ID号</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td>$@</td>
<td>与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>
</tr>
<tr>
<td>$-</td>
<td>显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr>
<td>$?</td>
<td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody></table>
<h1 id="裸机开发篇"><a href="#裸机开发篇" class="headerlink" title="裸机开发篇"></a>裸机开发篇</h1><h2 id="一、开发环境搭建"><a href="#一、开发环境搭建" class="headerlink" title="一、开发环境搭建"></a>一、开发环境搭建</h2><h4 id="VIM编辑器"><a href="#VIM编辑器" class="headerlink" title="VIM编辑器"></a>VIM编辑器</h4><p>Linux系统都会自带vi编辑器，但是vi编辑器太难用了！所以建议大家安装vim编辑器，安装命令：<br><code>sudo apt-get install vim</code></p>
<h4 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h4><p><code>sudo apt-get install nfs-kernel-server rpcbind</code></p>
<p>新建 linux-&gt;nfs 文件夹<br>sudo vi &#x2F;etc&#x2F;exports<br>文件后追加<br><code>/home/用户名/linux/nfs *(rw,sync,no_root_squash)</code><br><code>sudo /etc/init.d/nfs-kernel-server restart</code> 重启服务</p>
<h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><p><code>sudo apt-get install openssh-server</code>  开启服务<br>配置文件为&#x2F;etc&#x2F;ssh&#x2F;sshd_config，使用默认配置即可。</p>
<h4 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h4><p>图标都在目录&#x2F;usr&#x2F;share&#x2F;applications 中，找到 Visual Studio Code 的图标，点击鼠标右键，选择复制到-&gt;桌面</p>
<p><strong>插件：</strong></p>
<ul>
<li>C&#x2F;C++，这个肯定是必须的。</li>
<li>C&#x2F;C++ Snippets，即 C&#x2F;C++重用代码块</li>
<li>C&#x2F;C++ Advanced Lint,即 C&#x2F;C++静态检测 。</li>
<li>Code Runner，即代码运行。</li>
<li>Include AutoComplete，即自动头文件包含。</li>
<li>GBKtoUTF8，将 GBK 转换为 UTF8。</li>
<li>ARM，即支持 ARM 汇编语法高亮显示。</li>
<li>compareit，比较插件，可以用于比较两个文件的差异。</li>
<li>DeviceTree，设备树语法插件。</li>
<li>TabNine，一款 AI 自动补全插件，强烈推荐，谁用谁知道！</li>
</ul>
<h3 id="FTP-服务（文件互传）"><a href="#FTP-服务（文件互传）" class="headerlink" title="FTP 服务（文件互传）"></a>FTP 服务（文件互传）</h3><p>这里的互传不是使用 VirtualBox 的扩展功能，而是借用 FTP 服务，这样，我们就可以远程互传文件。</p>
<h4 id="开启Ubuntu下的FTP服务"><a href="#开启Ubuntu下的FTP服务" class="headerlink" title="开启Ubuntu下的FTP服务"></a>开启Ubuntu下的FTP服务</h4><p>安装FTP服务：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install vsftpd<br></code></pre></td></tr></table></figure>
<p>安装完成以后使用如下VI命令打开&#x2F;etc&#x2F;vsftpd.conf：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/etc/</span>vsftpd.conf<br></code></pre></td></tr></table></figure>
<p>找到如下两行：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">local_enable</span>=<span class="hljs-literal">YES</span><br><span class="hljs-attr">write_enable</span>=<span class="hljs-literal">YES</span><br></code></pre></td></tr></table></figure>
<p>确保上面两行前面没有“#”，有的话就取消掉，完成以后如图所示：</p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1606147159517.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>修改修改完vsftpd.conf以后保存退出，使用如下命令重启FTP服务：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo <span class="hljs-regexp">/etc/i</span>nit.d/vsftpd restart<br></code></pre></td></tr></table></figure>

<h4 id="Windows-下-FTP-安装"><a href="#Windows-下-FTP-安装" class="headerlink" title="Windows 下 FTP 安装"></a>Windows 下 FTP 安装</h4><h5 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h5><p>这里是一个大坑，为了避免问题，需要有限解决该问题。  </p>
<p>我们先在Ubuntu的命令行输入  <code>ifconfig</code> 查询虚拟机当前的地址：</p>
<p>期间可能会提示没有   <code>ifconfig</code> ，如下，根据提示输入指令 <code>sudo apt install net-tools</code> 安装即可</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs elixir">lonly<span class="hljs-variable">@lonly</span>-<span class="hljs-symbol">VirtualBox:</span>~<span class="hljs-variable">$ </span>ifconfig<br><br><span class="hljs-title class_">Command</span> <span class="hljs-string">&#x27;ifconfig&#x27;</span> <span class="hljs-keyword">not</span> found, but can be installed <span class="hljs-symbol">with:</span><br><br>sudo apt install net-tools<br><br>lonly<span class="hljs-variable">@lonly</span>-<span class="hljs-symbol">VirtualBox:</span>~<span class="hljs-variable">$ </span>sudo apt install net-tools<br>[sudo] lonly 的密码： <br>正在读取软件包列表... 完成<br></code></pre></td></tr></table></figure>


<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lonly</span>@lonly-VirtualBox:~$ ifconfig<br><span class="hljs-attribute">enp0s3</span>: flags=<span class="hljs-number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="hljs-number">1500</span><br>        <span class="hljs-attribute">inet</span> <span class="hljs-number">192.168.1.9</span>  netmask <span class="hljs-number">255.255.255.0</span>  broadcast <span class="hljs-number">192.168.1.255</span><br>        <span class="hljs-attribute">inet6</span> <span class="hljs-number">240</span>e:<span class="hljs-number">3</span>a1:a10:a6f0:<span class="hljs-number">244</span>d:d97c:<span class="hljs-number">7</span>e95:<span class="hljs-number">883</span>b  prefixlen <span class="hljs-number">64</span>  scopeid <span class="hljs-number">0</span>x0&lt;global&gt;<br>        <span class="hljs-attribute">inet6</span> <span class="hljs-number">240</span>e:<span class="hljs-number">3</span>a1:a10:a6f0:ae08:<span class="hljs-number">7</span>e36:<span class="hljs-number">2613</span>:<span class="hljs-number">2</span>d3a  prefixlen <span class="hljs-number">64</span>  scopeid <span class="hljs-number">0</span>x0&lt;global&gt;<br>        <span class="hljs-attribute">inet6</span> fe80::a397:<span class="hljs-number">12</span>be:<span class="hljs-number">107</span>d:<span class="hljs-number">4</span>a2d  prefixlen <span class="hljs-number">64</span>  scopeid <span class="hljs-number">0</span>x20&lt;link&gt;<br>        <span class="hljs-attribute">ether</span> <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:fc:<span class="hljs-number">78</span>:e4  txqueuelen <span class="hljs-number">1000</span>  (Ethernet)<br>        <span class="hljs-attribute">RX</span> packets <span class="hljs-number">5617</span>  bytes <span class="hljs-number">4691857</span> (<span class="hljs-number">4</span>.<span class="hljs-number">6</span> MB)<br>        <span class="hljs-attribute">RX</span> errors <span class="hljs-number">2</span>  dropped <span class="hljs-number">3</span>  overruns <span class="hljs-number">0</span>  frame <span class="hljs-number">0</span><br>        <span class="hljs-attribute">TX</span> packets <span class="hljs-number">4728</span>  bytes <span class="hljs-number">532025</span> (<span class="hljs-number">532</span>.<span class="hljs-number">0</span> KB)<br>        <span class="hljs-attribute">TX</span> errors <span class="hljs-number">0</span>  dropped <span class="hljs-number">0</span> overruns <span class="hljs-number">0</span>  carrier <span class="hljs-number">0</span>  collisions <span class="hljs-number">0</span><br>        <span class="hljs-attribute">device</span> interrupt <span class="hljs-number">19</span>  base <span class="hljs-number">0</span>xd020  <br><br><span class="hljs-attribute">lo</span>: flags=<span class="hljs-number">73</span>&lt;UP,LOOPBACK,RUNNING&gt;  mtu <span class="hljs-number">65536</span><br>        <span class="hljs-attribute">inet</span> <span class="hljs-number">127.0.0.1</span>  netmask <span class="hljs-number">255.0.0.0</span><br>        <span class="hljs-attribute">inet6</span> ::<span class="hljs-number">1</span>  prefixlen <span class="hljs-number">128</span>  scopeid <span class="hljs-number">0</span>x10&lt;host&gt;<br>        <span class="hljs-attribute">loop</span>  txqueuelen <span class="hljs-number">1000</span>  (Local Loopback)<br>        <span class="hljs-attribute">RX</span> packets <span class="hljs-number">444</span>  bytes <span class="hljs-number">48687</span> (<span class="hljs-number">48</span>.<span class="hljs-number">6</span> KB)<br>        <span class="hljs-attribute">RX</span> errors <span class="hljs-number">0</span>  dropped <span class="hljs-number">0</span>  overruns <span class="hljs-number">0</span>  frame <span class="hljs-number">0</span><br>        <span class="hljs-attribute">TX</span> packets <span class="hljs-number">444</span>  bytes <span class="hljs-number">48687</span> (<span class="hljs-number">48</span>.<span class="hljs-number">6</span> KB)<br>        <span class="hljs-attribute">TX</span> errors <span class="hljs-number">0</span>  dropped <span class="hljs-number">0</span> overruns <span class="hljs-number">0</span>  carrier <span class="hljs-number">0</span>  collisions <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>第三行的 <code>192.168.1.9</code>  就是我们的网络地址了。你的可能跟会和我的不同，后面会解决该问题。  </p>
<p>我们接着打开 Windows的命令行输出 <code>ipconfig</code> 查询电脑主机网络地址：</p>
<figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext">C:\Users\23714&gt;ipconfig<br><br><span class="hljs-attribute">Windows IP 配置</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">以太网适配器 SSTAP 1</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br>   <span class="hljs-attribute">媒体状态  . . . . . . . . . . . .</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">媒体已断开连接</span><br>   <span class="hljs-attribute">连接特定的 DNS 后缀 . . . . . . . </span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br><span class="hljs-attribute">以太网适配器 以太网</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br>   <span class="hljs-attribute">连接特定的 DNS 后缀 . . . . . . . </span><span class="hljs-punctuation">:</span><br>   <span class="hljs-attribute">IPv6 地址 . . . . . . . . . . . .</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">240e:3a1:a10:a6f0:c8b6:2a80:ec72:f670</span><br>   <span class="hljs-attribute">临时 IPv6 地址. . . . . . . . . .</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">240e:3a1:a10:a6f0:b18d:e4ec:7905:743c</span><br>   <span class="hljs-attribute">本地链接 IPv6 地址. . . . . . . .</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">fe80::c8b6:2a80:ec72:f670%13</span><br>   <span class="hljs-attribute">IPv4 地址 . . . . . . . . . . . .</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">192.168.1.7</span><br>   <span class="hljs-attribute">子网掩码  . . . . . . . . . . . .</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">255.255.255.0</span><br>   <span class="hljs-attribute">默认网关. . . . . . . . . . . . .</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">fe80::1%13</span><br>                                       <span class="hljs-attribute">192.168.1.1</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">以太网适配器 VirtualBox Host-Only Network</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br>   <span class="hljs-attribute">连接特定的 DNS 后缀 . . . . . . . </span><span class="hljs-punctuation">:</span><br>   <span class="hljs-attribute">本地链接 IPv6 地址. . . . . . . .</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">fe80::9142:54cb:53c3:d135%5</span><br>   <span class="hljs-attribute">IPv4 地址 . . . . . . . . . . . .</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">192.168.56.1</span><br>   <span class="hljs-attribute">子网掩码  . . . . . . . . . . . .</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">255.255.255.0</span><br>   <span class="hljs-attribute">默认网关. . . . . . . . . . . . . </span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br>...<br></code></pre></td></tr></table></figure>
<p><code>以太网适配器 以太网:</code>项中的 IPv4 地址：<code>192.168.1.7</code> 就是我们的主机地址了。可以看到和我们的虚拟主机地址只有最后一位不一样的，如果你的虚拟机不知最后一位不一样，如：<code>10.0.2.15</code>。那就说明网络设置有错误，我们需要修改 VirtualBox 软件的网络配置。</p>
<ol>
<li>Ubuntu 关键，进入 VirtualBox的网络配置界面：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Virtual%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE.png" srcset="/img/loading.gif" lazyload alt="enter description here"></li>
</ol>
<p>按如下要求设置</p>
<ul>
<li>连接方式 选择 桥接网卡</li>
<li>界面名称 选择 （需要根据现在的上网方式对应选择，当前是无线联网就选无线网卡，有线选有线网卡）</li>
<li>高级-控制芯片 一般是选择 PCnet-FAST III，如果你的有多个，可以尝试不同配置（如果不能上网的话）</li>
<li>高级-混杂模式 拒绝</li>
<li>高级-接入网线 √</li>
</ul>
<p>重启 ubuntu，再重新查看IP地址，确保虚拟机和主机的IP地址只有最后一位不同即可（仅主机(Host-Only)网络模式下，有两位不同）。为了保险起见，我们可以在windows命令行中 ping 一下虚拟机地址。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros"> C:\Users\23714&gt;ping 192.168.1.9<br><br>正在<span class="hljs-built_in"> Ping </span>192.168.1.9 具有 32 字节的数据:<br>来自 192.168.1.9 的回复: 字节=32 时间&lt;1ms <span class="hljs-attribute">TTL</span>=64<br>来自 192.168.1.9 的回复: 字节=32 时间&lt;1ms <span class="hljs-attribute">TTL</span>=64<br>来自 192.168.1.9 的回复: 字节=32 时间&lt;1ms <span class="hljs-attribute">TTL</span>=64<br>来自 192.168.1.9 的回复: 字节=32 时间&lt;1ms <span class="hljs-attribute">TTL</span>=64<br><br>192.168.1.9 的<span class="hljs-built_in"> Ping </span>统计信息:<br>    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，<br>往返行程的估计时间(以毫秒为单位):<br>    最短 = 0ms，最长 = 0ms，平均 = 0ms<br></code></pre></td></tr></table></figure>
<p>可以看到网络能够ping通（虚拟机有回复）。<br>此时我们就可以将虚拟机地址点入上面的设置中了。</p>
<h5 id="指定ip地址"><a href="#指定ip地址" class="headerlink" title="指定ip地址"></a>指定ip地址</h5><p>虚拟机的 ip 地址是随机分配的，每次开机时可能会不一样，这样每次我们都需要重新设置 Ip 地址，我们可以通过指定ip地址，来保持一致。</p>
<ol>
<li>首先要先查看 Windows 的ip地址<br> 上面已经查过了：192.168.1.7</li>
<li>修改最后一位(不超过254)，并Windows 下 ping 一下该地址，保证 ping 不同，也就是没用到该地址。<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"> C:\Users\<span class="hljs-number">23714</span>&gt;ping <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">254</span><br><br>正在 Ping <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">254</span> 具有 <span class="hljs-number">32</span> 字节的数据:<br>来自 <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">7</span> 的回复: 无法访问目标主机。<br>来自 <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">8</span> 的回复: 无法访问目标主机。<br><br><span class="hljs-number">192.168.1.254</span> 的 Ping 统计信息:<br>	数据包: 已发送 = <span class="hljs-number">2</span>，已接收 = <span class="hljs-number">2</span>，丢失 = <span class="hljs-number">0</span> (<span class="hljs-number">0</span>% 丢失)，<br></code></pre></td></tr></table></figure></li>
<li>进入Ubuntu，找到设置 -&gt; 网络，Wired 选项中点击设置图标，再选中 IPV4，按如下配置</li>
</ol>
<ul>
<li><strong>如果有两个网卡，例如启用了网卡2：主机(Host-Only)网络模式，这里会有两个网络，需要区分一下（只修改IP地址能ping通的那个网络）</strong><ul>
<li>Adress: 上一步修改的ip地址</li>
<li>Netmask：windows 下查询的的 <code>以太网适配器 以太网:</code>下的子网掩码</li>
<li>Gateway：<code>以太网适配器 以太网:</code> 默认网关</li>
<li>DNS 一般是和网关类似，再最后一位是1</li>
<li>右上角 Apply 保存。重启Ubuntu，再次查看IP地址，即可看到已经修改过来了。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ip.png" srcset="/img/loading.gif" lazyload alt="enter description here"></li>
</ul>
</li>
</ul>
<h5 id="FTP安装"><a href="#FTP安装" class="headerlink" title="FTP安装"></a>FTP安装</h5><p>下载地址：<a target="_blank" rel="noopener" href="https://www.filezilla.cn/download/client">FileZilla官网</a></p>
<p>下载后，安装一路默认即可，可更改安装路径。<br>打开站点管理器，点击：文件-&gt;站点管理器，或者直接点击左上角图标<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1606231575210.png" srcset="/img/loading.gif" lazyload><br>打开以后，按下图所示设置：</p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Filezilla%E8%AE%BE%E7%BD%AE.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>其中用户名就是当前登录的用户，注意不是系统登录界面显示的那个。我们可以使用命令查看：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle">lonly@lonly-VirtualBox:~$ pwd<br><span class="hljs-regexp">/home/</span>lonly<br>lonly@lonly-VirtualBox:~$ w<br> <span class="hljs-number">23</span>:<span class="hljs-number">36</span>:<span class="hljs-number">09</span> up <span class="hljs-number">15</span> min,  <span class="hljs-number">1</span> user,  load average: <span class="hljs-number">0.00</span>, <span class="hljs-number">0.01</span>, <span class="hljs-number">0.03</span><br>USER     TTY      <span class="hljs-keyword">FROM</span>             LOGIN@   IDLE   JCPU   PCPU WHAT<br>lonly    :<span class="hljs-number">0</span>       :<span class="hljs-number">0</span>               <span class="hljs-number">23</span>:<span class="hljs-number">21</span>   ?xdm?   <span class="hljs-number">8.15</span>s  <span class="hljs-number">0.00</span>s <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/gdm3/g</span><br></code></pre></td></tr></table></figure>
<p><code>pwd</code>或<code>w</code>命令都可以，可以看到当前用户名是<code>lonly</code>.<br>密码就是开机的登录密码了</p>
<p>连接成功后，会看到如下界面，左边是 Windows 系统的目录文件，右边是Ubuntu 系统的目录文件。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/filezilla_%E7%95%8C%E9%9D%A2.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>但是Ubuntu 文件目录下的中文目录都是乱码的，这是因为编码方式没有选对，先断开连接，点击：<br>服务器(S)-&gt;断开连接，然后打开站点管理器，选中要设置的站点“Ubuntu”，选择“字符集”，<br>设置所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1649328733209.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<h5 id="参考链接：-1"><a href="#参考链接：-1" class="headerlink" title="参考链接："></a>参考链接：</h5><ul>
<li><a target="_blank" rel="noopener" href="https://blog.51cto.com/11585002/2476265">VirtualBox虚拟机网络设置（四种方式）</a></li>
<li><a target="_blank" rel="noopener" href="https://rqsir.github.io/2019/05/23/VirtualBox-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/">VirtualBox 网络模式总结</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0537b056790b">VirtualBox虚拟机网络搭建NAT、桥接、Host-Only、Internal等(centos7)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a88a37957960">Windows下VirtualBox虚拟机互ping+外网配置</a></li>
</ul>
<h3 id="NFS和SSH服务开启"><a href="#NFS和SSH服务开启" class="headerlink" title="NFS和SSH服务开启"></a>NFS和SSH服务开启</h3><h4 id="NFS服务开启"><a href="#NFS服务开启" class="headerlink" title="NFS服务开启"></a>NFS服务开启</h4><p>后面进行Linux驱动开发的时候需要NFS启动，因此要先安装并开启Ubuntu中的NFS服务，使用如下命令安装NFS服务：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> install nfs-kernel-<span class="hljs-keyword">server</span> rpcbind<br></code></pre></td></tr></table></figure>
<p>等待安装完成，安装完成以后在用户根目录下创建一个名为“linux”的文件夹，以后所有的东西都放到这个“linux”文件夹里面，在“linux”文件夹里面新建一个名为“nfs”的文件夹</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">lonly@lonly-VirtualBox:~$ <span class="hljs-built_in">ls</span><br>Desktop    Downloads         linux  Pictures  Templates  Videos<br>Documents  examples.desktop  Music  Public    <span class="hljs-built_in">test</span><br>lonly@lonly-VirtualBox:~/linux$ <span class="hljs-built_in">ls</span><br>nfs<br></code></pre></td></tr></table></figure>
<p>创建的nfs文件夹供nfs服务器使用，以后我们可以在开发板上通过网络文件系统来访问nfs文件夹，要先配置nfs，使用如下命令打开nfs配置文件 <code>exports：</code></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/etc/</span>exports<br></code></pre></td></tr></table></figure>

<p>打开&#x2F;etc&#x2F;exports以后在后面添加如下所示内容：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/home/</span>lonly<span class="hljs-regexp">/linux/</span>nfs *(rw,sync,no_root_squash)<br></code></pre></td></tr></table></figure>
<p>添加完成以后的&#x2F;etc&#x2F;exports如下所示：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-number"> 1 </span><span class="hljs-comment"># /etc/exports: the access control list for filesystems which may be exporte    d</span><br><span class="hljs-number"> 2 </span><span class="hljs-comment">#       to NFS clients.  See exports(5).</span><br><span class="hljs-number"> 3 </span><span class="hljs-comment">#</span><br><span class="hljs-number"> 4 </span><span class="hljs-comment"># Example for NFSv2 and NFSv3:</span><br><span class="hljs-number"> 5 </span><span class="hljs-comment"># /srv/homes       hostname1(rw,sync,no_subtree_check) hostname2(ro,sync,no_    subtree_check)</span><br><span class="hljs-number"> 6 </span><span class="hljs-comment">#</span><br><span class="hljs-number"> 7 </span><span class="hljs-comment"># Example for NFSv4:</span><br><span class="hljs-number"> 8 </span><span class="hljs-comment"># /srv/nfs4        gss/krb5i(rw,sync,fsid=0,crossmnt,no_subtree_check)</span><br><span class="hljs-number"> 9 </span><span class="hljs-comment"># /srv/nfs4/homes  gss/krb5i(rw,sync,no_subtree_check)</span><br>10 <span class="hljs-comment">#</span><br>11 <br>12 /home/lonly/linux/nfs *(rw,sync,no_root_squash)<br></code></pre></td></tr></table></figure>
<p>重启NFS服务，使用命令如下：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo <span class="hljs-regexp">/etc/i</span>nit.d/nfs-kernel-server restart<br></code></pre></td></tr></table></figure>

<h4 id="SSH服务开启开启"><a href="#SSH服务开启开启" class="headerlink" title="SSH服务开启开启"></a>SSH服务开启开启</h4><p>Ubuntu的SSH服务以后我们就可以在Windwos下使用终端软件登陆到Ubuntu，比如使用SecureCRT，Ubuntu下使用如下命令开启SSH服务：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> install openssh-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure>

<p>上述命令安装ssh服务，ssh的配置文件为&#x2F;etc&#x2F;ssh&#x2F;sshd_config，使用默认配置即可。</p>
<h3 id="交叉编译器安装"><a href="#交叉编译器安装" class="headerlink" title="交叉编译器安装"></a>交叉编译器安装</h3><p>下载地址如下：<a target="_blank" rel="noopener" href="https://www.linaro.org/">https://www.linaro.org/</a> </p>
<p>从官方很难找到编译器下载地址，建议使用一下链接直接进入下载界面<br>Linaro GCC 编译器：<a target="_blank" rel="noopener" href="https://releases.linaro.org/components/toolchain/binaries/">https://releases.linaro.org/components/toolchain/binaries/</a></p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linaro_release.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p><em><strong>经测试，这里不能安装最新版本，会导致后面uboot编译出问题（正常程序的编译没问题），会导致在uboot中无法使用 <code>dhcp</code> 和<code>ping</code> 命令。所以不要使用最新版！不要使用最新！不要使用最新！请下载和正点原子教程同样的版本 <code>4.9.4-2017.01</code></strong></em></p>
<p><strong>下载地址：</strong> <a target="_blank" rel="noopener" href="https://releases.linaro.org/components/toolchain/binaries/4.9-2017.01/arm-linux-gnueabihf/">https://releases.linaro.org/components/toolchain/binaries/4.9-2017.01/arm-linux-gnueabihf/</a></p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1655037345847.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://47.111.11.73/forum.php?mod=viewthread&tid=319724&highlight=dhcp+%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD">用uboot命令dhcp后为什么会重启uboot进入倒计时呢？</a></li>
<li><a target="_blank" rel="noopener" href="http://47.111.11.73/forum.php?mod=viewthread&tid=325306&highlight=uboot+ping%CA%A7%EF%BF%BD%EF%BF%BD">学习教材中uboot下命令试验ping失败导致重启</a></li>
</ul>
<p><del>进入下面的下载界面，其中有很多种交叉编译器，我们只需要关注红框中部分，一个是针对32位系统的，第二个是针对64位系统的。大家根据自己所使用的Ubuntu系统类型选择合适的版本，我安装的Ubuntu16.04是64位系统，因此我要<br>使用 <code>gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf.tar.xz</code>。</del></p>
<p>创建一个“tool”的文件夹：  <code>linux/tool</code>，存放开发工具（这里只是存放，安装在别的位置）。使用前面已经安装好的FileZilla将交叉编译器拷贝到Ubuntu中刚刚新建的“tool”文件夹中。</p>
<p>在Ubuntu中创建目录：<code>sudo mkdir /usr/local/arm</code>。存放编译器</p>
<p>进入tool目录，将交叉编译器下载文件（不要解压、不要解压）复制到arm目录中<br><code>sudo cp gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf.tar.xz /usr/local/arm/ -f</code></p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/filezilla_%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>这里一定要保证压缩文件名是.xz 结尾，否则后面uboot编译时会出错，下图第第二个文件就是错的<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1651106667942.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>进入arm目录，解压：<br><code>sudo tar -vxf gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf.tar.xz</code></p>
<p>修改环境变量，<code>sudo vi /etc/profile</code><br>最后面输入如下所示内容：<br><code>export PATH=$PATH:/usr/local/arm/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf/bin</code></p>
<p>添加完成以后的&#x2F;etc&#x2F;profile如下图所示</p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linaro_profile.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>修改好以后就保存退出，重启Ubuntu系统，交叉编译工具链(编译器)就安装成功了。</p>
<p>安装相关库：<code>sudo apt-get install lsb-core lib32stdc++6</code></p>
<p>验证：<code>arm-linux-gnueabihf-gcc -v</code><br>如果交叉编译器安装正确的话就会显示版本号，如下图所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linaro_version.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>注意，以下内容一定要有，特别是COLLECT_LTO_WRAPPER这一行。这一行没有的话，裸机编译可能没错，但是后面的uboot移植编译就会出错<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1651061897534.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>编译第一个裸机例程“1_leds”试试，在前面创建的linux文件夹下创建driver&#x2F;board_driver文件夹，用来存放裸机例程<br>将第一个裸机例程“1_leds”拷贝到board_driver中，然后执行make命令进行编译，</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">lonly@lonly-VirtualBox:~/linux/driver/board_driver/<span class="hljs-number">1</span>_leds$ make clean<br>rm -rf *<span class="hljs-selector-class">.o</span> led<span class="hljs-selector-class">.bin</span> led<span class="hljs-selector-class">.elf</span> led<span class="hljs-selector-class">.dis</span><br>lonly@lonly-VirtualBox:~/linux/driver/board_driver/<span class="hljs-number">1</span>_leds$ make<br>arm-linux-gnueabihf-gcc -g -c led<span class="hljs-selector-class">.s</span> -o led<span class="hljs-selector-class">.o</span><br>arm-linux-gnueabihf-ld -Ttext <span class="hljs-number">0</span>X87800000 led<span class="hljs-selector-class">.o</span> -o led<span class="hljs-selector-class">.elf</span><br>arm-linux-gnueabihf-objcopy -O binary -S -g led<span class="hljs-selector-class">.elf</span> led<span class="hljs-selector-class">.bin</span><br>arm-linux-gnueabihf-objdump -D led<span class="hljs-selector-class">.elf</span> &gt; led<span class="hljs-selector-class">.dis</span><br>lonly@lonly-VirtualBox:~/linux/driver/board_driver/<span class="hljs-number">1</span>_leds$ ls<br>imxdownload  led<span class="hljs-selector-class">.bin</span>  led<span class="hljs-selector-class">.dis</span>  led<span class="hljs-selector-class">.elf</span>  led<span class="hljs-selector-class">.o</span>  led<span class="hljs-selector-class">.s</span>  leds<span class="hljs-selector-class">.code-workspace</span>  load<span class="hljs-selector-class">.imx</span>  Makefile  SI<br></code></pre></td></tr></table></figure>
<p>可以看到例程“1_leds”编译成功了，编译生成了led.o和led.bin这两个文件，使用如下命令查看led.o文件信息：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal">lonly<span class="hljs-variable">@lonly</span>-<span class="hljs-symbol">VirtualBox:</span>~<span class="hljs-regexp">/linux/driver</span><span class="hljs-regexp">/board_driver/</span><span class="hljs-number">1_</span>leds<span class="hljs-variable">$ </span>file led.o<br>led.<span class="hljs-symbol">o:</span> ELF <span class="hljs-number">32</span>-bit LSB relocatable, ARM, EABI5 version <span class="hljs-number">1</span> (SYSV), <span class="hljs-keyword">with</span> debug_info, not stripped<br></code></pre></td></tr></table></figure>
<p>可以看到led.o是32位LSB 的ELF格式文件，目标机架构为ARM，说明我们的交叉编译器工作正常</p>
<h3 id="VisualStudioCode软件的安装和使用"><a href="#VisualStudioCode软件的安装和使用" class="headerlink" title="VisualStudioCode软件的安装和使用"></a>VisualStudioCode软件的安装和使用</h3><p>VSCode是微软出的一款编辑器，但是免费的。VSCode有Windows、Linux和macOS三个版本的，是一个跨平台的编辑器。VSCode下载地址是：<a target="_blank" rel="noopener" href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p>
<p>本教程需要Windows和Linux这两个版本，所以下载这两个即可</p>
<p><strong>windows版本安装</strong><br>默认安装即可。</p>
<p><strong>Linux版本安装</strong><br>在Ubuntu主要是阅读代码，不要用于编写代码等用途（请培养 VIM 的使用习惯 ）<br>直接在应用商店搜索下载安装即可，速度可能比较慢，但不要退出，否则重装很麻烦。</p>
<h5 id="VisualStudio-Code插件的安装"><a href="#VisualStudio-Code插件的安装" class="headerlink" title="VisualStudio Code插件的安装"></a>VisualStudio Code插件的安装</h5><p>VSCode支持多种语言，比如C&#x2F;C++、Python、C#等等，本教程我们主要用来编写C&#x2F;C++程序的，所以需要安装C&#x2F;C++的扩展包，扩展包安装很简单，如图所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/vscode_%E6%8F%92%E4%BB%B6.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>我们需要按照的插件有下面几个：</p>
<ul>
<li>C&#x2F;C++，这个肯定是必须的。</li>
<li>C&#x2F;C++ Snippets，即C&#x2F;C++重用代码块。</li>
<li>C&#x2F;C++ Advanced Lint,即C&#x2F;C++静态检测。</li>
<li>CodeRunner，即代码运行。</li>
<li>IncludeAutoComplete，即自动头文件包含。</li>
<li>Rainbow Brackets，彩虹花括号，有助于阅读代码。可选</li>
<li>OneDarkPro，VSCode的主题。可选</li>
<li>GBKtoUTF8，将GBK转换为UTF8</li>
<li>ARM，即支持ARM汇编语法高亮显示</li>
<li>Chinese(Simplified)，即中文环境。可选</li>
<li>vscode-icons，VSCode图标插件，主要是资源管理器下各个文件夹的图标。可选</li>
<li>compareit，比较插件，可以用于比较两个文件的差异。</li>
<li>DeviceTree，设备树语法插件。</li>
<li>TabNine，一款AI自动补全插件，强烈推荐，谁用谁知道！</li>
</ul>
<h4 id="VisualStudioCode新建工程"><a href="#VisualStudioCode新建工程" class="headerlink" title="VisualStudioCode新建工程"></a>VisualStudioCode新建工程</h4><p>新建一个文件夹用于存放工程，比如我新建了文件夹目录为E:\VScode_Program\1_test，路径尽量不要有中文和空格。<br>然后打开VSCode，点击文件-&gt;打开文件夹…，选刚刚创建的“1_test”文件夹，<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/vscode_%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>可以看出此时的文件夹“1_TEST”是空的，点击文件-&gt;将工作区另存为…，打开工作区命名对话框，输入要保存的工作区路径和工作区名字，如图所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/vscode_%E5%B7%A5%E4%BD%9C%E5%8C%BA%E4%BF%9D%E5%AD%98%E8%AE%BE%E7%BD%AE.png" srcset="/img/loading.gif" lazyload alt="enter description here"><br>工作区保存成功以后，点击“新建文件”按钮创建main.c和main.h这两个文件，创建成功以后VSCode如图所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E4%BB%A5%E5%90%8E%E7%9A%84VSCode.png" srcset="/img/loading.gif" lazyload alt="enter description here"><br>之后就可以编写代码了。</p>
<h3 id="CH340串口驱动安装"><a href="#CH340串口驱动安装" class="headerlink" title="CH340串口驱动安装"></a>CH340串口驱动安装</h3><p>我们一般在Windwos下通过串口来调试程序，或者使用串口作为终端，I.MX6U-ALPHA开发板使用CH340这个芯片实现了USB转串口功能，。先通过USB线将开发板的串口和电脑连接起来起来</p>
<blockquote>
<p>一定要先将开发板与电脑连接，否则驱动会安装失败。</p>
</blockquote>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%B2%E5%8F%A3%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>点击 “安装”按钮开始安装驱动，等待驱动安装完成。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/CH340%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>进入设备管理器 -&gt; 端口，可以看到有“USB-SERIAL CH340”字样的端口设备就说明CH340驱动成功了。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%99%A8.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<h3 id="Putty软件的安装和使用"><a href="#Putty软件的安装和使用" class="headerlink" title="Putty软件的安装和使用"></a>Putty软件的安装和使用</h3><p>Putty软件是用来作为SSH或者串口终端的，虽然Putty没有SecureCRT功能强大，但是Putty用来作为嵌入式Linux的串口终端是绰绰有余。Putty在官网下载即可，下载地址为：<a target="_blank" rel="noopener" href="https://www.putty.org/">Download PuTTY</a>。下载界面如图所示  </p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Download_PuTTY.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>根据自己电脑下载 32位或64位版本，双击开始安装，安装一路默认即可，可自行更改安装路径。</p>
<h4 id="Putty软件使用"><a href="#Putty软件使用" class="headerlink" title="Putty软件使用"></a>Putty软件使用</h4><p>使用USB线将开发板串口和电脑连接起来，打开Putty软件，打开以后是配置界面。  </p>
<p>我们要用到串口功能，所以在左侧选择“Serial”，然后在右侧配置串口，配置完成以后如下左半图所示；还需要设置“Session”，设置如下右半图所示。  </p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/putty_%E4%B8%B2%E5%8F%A3%E9%85%8D%E7%BD%AE.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>设置好以后，点击“Open”打开串口。此时重启开发板，如果开发板里面烧写了Linux系统的话，Putty就会显示Linux启动过程的信息，并且作为开发板的终端，如图所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Putty%E4%BD%9C%E4%B8%BA%E4%B8%B2%E5%8F%A3%E7%BB%88%E7%AB%AF.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<blockquote>
<p>另外还有一款类似的但功能更加强大的软件：<a target="_blank" rel="noopener" href="https://mobaxterm.mobatek.net/">MobaXterm</a>。但我们开发时仅作为串口终端，所以 Putty 已完全满足需求。</p>
</blockquote>
<h3 id="MobaXterm-软件安装和使用"><a href="#MobaXterm-软件安装和使用" class="headerlink" title="MobaXterm 软件安装和使用"></a>MobaXterm 软件安装和使用</h3><p><a target="_blank" rel="noopener" href="https://mobaxterm.mobatek.net/">https://mobaxterm.mobatek.net</a><br>点击菜单栏中的“Sessions-&gt;New session”按钮，打开新建会话窗口<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1652347394139.png" srcset="/img/loading.gif" lazyload alt="enter description here"><br>串口设置<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1652347512693.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<h2 id="Cortex-A7-MPCore架构"><a href="#Cortex-A7-MPCore架构" class="headerlink" title="Cortex-A7 MPCore架构"></a>Cortex-A7 MPCore架构</h2><h3 id="Cortex-A处理器运行模型"><a href="#Cortex-A处理器运行模型" class="headerlink" title="Cortex-A处理器运行模型"></a>Cortex-A处理器运行模型</h3><p>STM32只有两种运行模式，特权模式和非特权模式，但是Cortex-A就有9种运行模式。</p>
<p>以前的ARM处理器有7中运行模型：User、FIQ、IRQ、Supervisor(SVC)、Abort、Undef和System，其中User是非特权模式，其余6中都是特权模式。但新的Cortex-A7处理器有9种处理模式，如表所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B9%9D%E7%A7%8D%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<ul>
<li>在表中，除了User(USR)用户模式以外，其它8种运行模式都是特权模式。</li>
<li>这几个运行模式可以通过软件进行任意切换，也可以通过中断或者异常来进行切换。</li>
<li>大多数的程序都运行在用户模式，用户模式下是不能访问系统所有资源的，有些资源是受限的，要想访问这些受限的资源就必须进行模式切换。</li>
<li>用户模式是不能直接进行切换的，需要借助异常来完成模式切换，当要切换模式的时候，应用程序可以产生异常，在异常的处理过程中完成处理器模式切换。</li>
</ul>
<p>当中断或者异常发生以后，处理器就会进入到相应的异常模式种，每一种模式都有一组寄存器供异常处理程序使用，这样的目的是为了保证在进入异常模式以后，用户模式下的寄存器不会被破坏。</p>
<h3 id="Cortex-A寄存器组"><a href="#Cortex-A寄存器组" class="headerlink" title="Cortex-A寄存器组"></a>Cortex-A寄存器组</h3><p>ARM架构提供了16个32位的通用寄存器(R0~R15)供软件使用</p>
<ul>
<li>R0~R14 可以用作通用的数据存储，</li>
<li>R15是程序计数器PC，用来保存将要执行的指令</li>
</ul>
<p> 还提供了程序状态寄存器</p>
<ul>
<li>当前程序状态寄存器CPSR</li>
<li>备份程序状态寄存器SPSR，SPSR寄存器就是CPSR寄存器的备份。</li>
</ul>
<p>这18个寄存器如图所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Cortex-A%E5%AF%84%E5%AD%98%E5%99%A8.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>Cortex-A7有9种运行模式</p>
<ol>
<li>每一种运行模式都有一组与之对应的寄存器组。</li>
<li>每一种模式可见的寄存器包括15个通用寄存器(R0~R14)，一两个程序状态寄存器和一个程序计数器PC。</li>
</ol>
<p>在这些寄存器中，有些是所有模式所共用的同一个物理寄存器，有一些是各模式自己所独立拥有的，各个模式所拥有的寄存器如图所示<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B9%9D%E7%A7%8D%E6%A8%A1%E5%BC%8F%E6%89%80%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<ul>
<li>图中浅色字体的是与User模式所共有的寄存器</li>
<li>蓝绿色背景的是各个模式所独有的寄存器</li>
</ul>
<p> 可以看出，在所有的模式中</p>
<ul>
<li>低寄存器组(R0~R7)是共享同一组物理寄存器的，只是一些高寄存器组在不同的模式有自己独有的寄存器</li>
<li>只有一个 R15 程序计数器(PC)</li>
<li>比如FIQ模式下R8~R14是独立的物理寄存器。假如某个程序在<strong>FIQ模式下访问R13寄存器</strong>，那它<strong>实际访问的是寄存器R13_fiq</strong>，</li>
<li>如果程序处于<strong>SVC模式下访问R13寄存器</strong>，那它实<strong>际访问的是寄存器R13_svc</strong>。</li>
</ul>
<p>总结一下，Cortex-A内核寄存器组成如下：</p>
<ul>
<li>34个通用寄存器，包括R15程序计数器(PC)，这些寄存器都是32位的。</li>
<li>8个状态寄存器，包括CPSR和SPSR。</li>
<li>Hyp模式下独有一个ELR_Hyp寄存器。</li>
</ul>
<h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><p>请配合上图阅读该小节文字，R0~R15就是通用寄存器，通用寄存器可以分为以下三类：</p>
<ol>
<li>未备份寄存器，即R0~R7。</li>
<li>备份寄存器，即R8~R14。</li>
<li>程序计数器PC，即R15。</li>
</ol>
<p>分别来看一下这三类寄存器</p>
<h5 id="1、未备份寄存器"><a href="#1、未备份寄存器" class="headerlink" title="1、未备份寄存器"></a>1、未备份寄存器</h5><p>R0~R7。所有的运行模式共享这8个寄存器，在<strong>不同的模式下，这8个寄存器中的数据就会被破坏</strong>。所以这8个寄存器并没有被用作特殊用途。</p>
<h5 id="2、备份寄存器"><a href="#2、备份寄存器" class="headerlink" title="2、备份寄存器"></a>2、备份寄存器</h5><p>R8<del>R12。快速中断模式下(FIQ)独有 **Rx_irq(x&#x3D;8</del>12)** 物理寄存器，其他模式下共享 <strong>Rx(8~12)</strong> 物理寄存器。<br>FIQ模式要求快速执行！因为FIQ模式下的R8~R12是独立的，因此中断处理程序可以不用执行保存和恢复中断现场的指令，从而加速中断的执行过程。</p>
<p>R13。一共有8个不同物理寄存器，其中一个是用户模式(User)和系统模式(Sys)共用的，剩下的7个分别对应7种不同的模式。<br><strong>R13也叫做SP，用来做为栈指针。基本上每种模式都有一个自己的R13物理寄存器，应用程序会初始化R13，使其指向该模式专用的栈地址，这就是常说的初始化SP指针。</strong></p>
<p>R14。一共有7个物理寄存器，其中一个是用户模式(User)、系统模式(Sys)和超级监视模式(Hyp)所共有的，剩下的6个分别对应6种不同的模式。R14也称为连接寄存器(LR)，LR寄存器在ARM中主要用作如下两种用途：</p>
<ol>
<li>每种模式使用R14(LR)来存放当前子程序的返回地址，如果使用BL（汇编代码）或者BLX（汇编代码）来调用子函数的话， R14(LR)被设置成该子函数的返回地址，在子函数中，将R14(LR)中的值赋给R15(PC)即可完成子函数返回，比如在子程序中可以使用如下代码：<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">PC</span>, <span class="hljs-built_in">LR</span> <span class="hljs-comment">@寄存器LR中的值赋值给PC，实现跳转</span><br></code></pre></td></tr></table></figure>
或者可以在子函数的入口出将LR入栈：<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">PUSH</span> &#123;<span class="hljs-built_in">LR</span>&#125;<span class="hljs-comment">@将LR寄存器压栈</span><br></code></pre></td></tr></table></figure>
在子函数的最后面出栈即可：<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">POP</span> &#123;PC&#125;@将上面压栈的LR寄存器数据出栈给PC寄存器，严格意义上来讲应该是将@LR-<span class="hljs-number">4</span>赋给PC，因为<span class="hljs-number">3</span>级流水线，这里只是演示代码。<br></code></pre></td></tr></table></figure></li>
<li>当异常发生以后，该异常模式对应的R14寄存器被设置成该异常模式将要返回的地址，R14也可以当作普通寄存器使用</li>
</ol>
<h5 id="3、程序计数器R15"><a href="#3、程序计数器R15" class="headerlink" title="3、程序计数器R15"></a>3、程序计数器R15</h5><p>R15。也叫做PC，R15保存着当前执行的指令地址值加8个字节，这是因为ARM的流水线机制导致的。ARM处理器3级流水线：<br><strong>取指-&gt;译码-&gt;执行</strong><br>这三级流水线循环执行，比如当前正在执行第一条指令的同时也对第二条指令进行译码，第三条指令也同时被取出存放在R15(PC)中。我们喜欢以当前正在执行的指令作为参考点，也就是以第一条指令为参考点，那么R15(PC)中存放的就是第三条指令，换句话说就是<strong>R15(PC)总是指向当前正在执行的指令地址再加上2条指令的地址</strong>。对于32位的ARM处理器，每条指令是4个字节，所以:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">R15</span> (PC)值= 当前执行的程序位置+<span class="hljs-number">8</span>个字节。<br></code></pre></td></tr></table></figure>
<h4 id="程序状态寄存器"><a href="#程序状态寄存器" class="headerlink" title="程序状态寄存器"></a>程序状态寄存器</h4><p>所有的处理器模式都共用一个CPSR物理寄存器，因此CPSR可以在任何模式下被访问。该寄存器包含了条件标志位、中断禁止位、当前处理器模式标志等一些状态位以及一些控制位。所有的处理器模式都共用一个CPSR必然会导致冲突，为此，除了User和Sys这两个模式以外，其他7个模式每个都配备了一个专用的物理状态寄存器，叫做SPSR(备份程序状态寄存器)，<strong>当特定的异常中断发生时，SPSR寄存器用来保存当前程序状态寄存器(CPSR)的值，当异常退出以后可以用SPSR中保存的值来恢复CPSR。</strong></p>
<p>因为User和Sys这两个模式不是异常模式，所以并没有配备SPSR，因此<strong>不能在User和Sys模式下访问SPSR</strong>，会导致不可预知的结果。由于SPSR是CPSR的备份，因此SPSR和CPSR的寄存器结构相同，如图所示：</p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/CPSR%E5%AF%84%E5%AD%98%E5%99%A8.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p><strong>N(bit31)：</strong> 当两个补码表示的有符号整数运算的时候，N&#x3D;1表示运算对的结果为负数，N&#x3D;0表示结果为正数。<br><strong>Z(bit30)：</strong> Z&#x3D;1表示运算结果为零，Z&#x3D;0表示运算结果不为零，对于CMP指令，Z&#x3D;1表示进行比较的两个数大小相等。<br><strong>C(bit29)：</strong> 在加法指令中，当结果产生了进位，则C&#x3D;1，表示无符号数运算发生上溢，其它情况下C&#x3D;0。在减法指令中，当运算中发生借位，则C&#x3D;0，表示无符号数运算发生下溢，其它情况下C&#x3D;1。对于包含移位操作的非加&#x2F;减法运算指令，C中包含最后一次溢出的位的数值，对于其它非加&#x2F;减运算指令，C位的值通常不受影响。<br><strong>V(bit28)：</strong> 对于加&#x2F;减法运算指令，当操作数和运算结果表示为二进制的补码表示的带符号数时，V&#x3D;1表示符号位溢出，通常其他位不影响V位。<br><strong>Q(bit27)：</strong> 仅ARM v5TE_J架构支持，表示饱和状态，Q&#x3D;1表示累积饱和，Q&#x3D;0表示累积不饱和。<br>**IT[1:0](bit26:25)**： 和IT[7:2](bit15:bit10)一起组成IT[7:0]，作为IF-THEN指令执行状态。<br><strong>J(bit24)：</strong> 仅ARM_v5TE-J架构支持，J&#x3D;1表示处于Jazelle状态，此位通常和T(bit5)位一起表示当前所使用的指令集，如表所示：  </p>
<table>
<thead>
<tr>
<th>J</th>
<th>T</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>ARM</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>Thumb</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>ThumbEE</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>Jazelle</strong></td>
</tr>
</tbody></table>
<p><strong>GE[3:0](bit19:16)：</strong> SIMD指令有效，大于或等于。<br><strong>IT[7:2](bit15:10)：</strong> 参考IT[1:0]。<br><strong>E(bit9)：</strong> 大小端控制位，E&#x3D;1表示大端模式，E&#x3D;0表示小端模式。<br>**A(bit8)**： 禁止异步中断位，A&#x3D;1表示禁止异步中断。<br><strong>I(bit7)：</strong> I&#x3D;1禁止IRQ，I&#x3D;0使能IRQ。<br><strong>F(bit6)：</strong> F&#x3D;1禁止FIQ，F&#x3D;0使能FIQ。<br><strong>T(bit5)：</strong> 控制指令执行状态，表明本指令是ARM指令还是Thumb指令，通常和J(bit24)一起表明指令类型，参考J(bit24)位。<br>**M[4:0]**： 处理器模式控制位，含义如表所示：</p>
<table>
<thead>
<tr>
<th>M[4:0]</th>
<th>处理器模式</th>
</tr>
</thead>
<tbody><tr>
<td>10000</td>
<td>User模式</td>
</tr>
<tr>
<td>10001</td>
<td>FIQ模式</td>
</tr>
<tr>
<td>10010</td>
<td>IRQ模式</td>
</tr>
<tr>
<td>10011</td>
<td>Supervisor(SVC)模式</td>
</tr>
<tr>
<td>10110</td>
<td>Monitor(MON)模式</td>
</tr>
<tr>
<td>10111</td>
<td>Abort(ABT)模式</td>
</tr>
<tr>
<td>11010</td>
<td>Hyp(HYP)模式</td>
</tr>
<tr>
<td>11011</td>
<td>Undef(UND)模式</td>
</tr>
<tr>
<td>11111</td>
<td>System(SYS)模式</td>
</tr>
</tbody></table>
<h2 id="ARM汇编基础"><a href="#ARM汇编基础" class="headerlink" title="ARM汇编基础"></a>ARM汇编基础</h2><p>我们在进行嵌入式Linux开发的时候是绝对要掌握基本的ARM汇编，因为Cortex-A芯片一上电SP指针还没初始化，C环境还没准备好，所以肯定不能运行C代码，必须先用汇编语言设置好C环境，比如初始化DDR、设置SP指针等等，当汇编把C环境设置好了以后才可以运行C代码。所以Cortex-A一开始肯定是汇编代码，其实STM32也一样的，一开始也是汇编，以STM32F103为例，启动文件startup_stm32f10x_hd.s就是汇编文件，只是这个文件ST已经写好了，我们根本不用去修改，所以大部分学习者都没有深入的去研究。汇编的知识很庞大，本章我们只讲解最常用的一些指令，满足我们后续学习即可。</p>
<h3 id="GNU汇编语法"><a href="#GNU汇编语法" class="headerlink" title="GNU汇编语法"></a>GNU汇编语法</h3><p>我们要编写的是ARM汇编，编译使用的GCC交叉编译器，所以我们的汇编代码要符合GNU语法。</p>
<p>GNU汇编语法适用于所有的架构，并不是ARM独享的，GNU汇编由一系列的语句组成，每行一条语句，每条语句有三个可选部分，如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">label</span>：instruction <span class="hljs-keyword">@comment</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>label</strong> 即标号，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到指令的地址，标号也可以用来表示数据地址。注意label后面的“：”，任何以“：”结尾的标识符都会被识别为一个标号。    </li>
<li><strong>instruction</strong> 即指令，也就是汇编指令或伪指令。@符号，表示后面的是注释，就跟C语言里面的“&#x2F;*”和“*&#x2F;”一样，其实在GNU汇编文件中我们也可以使用“&#x2F;*”和“*&#x2F;”来注释。    </li>
<li><strong>comment</strong> 就是注释内容。</li>
</ul>
<p>代码举例：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">add:</span><br>	MOVS <span class="hljs-built_in">R0</span>, <span class="hljs-meta">#0X12  @设置 R0=0X12</span><br></code></pre></td></tr></table></figure>
<p>上面代码中“add:”就是标号，“MOVS R0, #0X12” 就是指令，最后的 “@设置R0&#x3D;0X12” 就是注释。</p>
<blockquote>
<p>label 可以理解为函数名，可以通过该标号找到后面的程序，是系统直接跳转过来<br>注意！ARM中的指令、伪指令、伪操作、寄存器名等可以全部使用大写，也可以全部使用小写，但是不能大小写混用。</p>
</blockquote>
<p>用户可以使用 <strong>.section 伪操作</strong>来定义一个段，汇编系统预定义了一些段名：</p>
<ul>
<li><strong>.text</strong> 表示代码段。</li>
<li><strong>.data</strong> 初始化的数据段。</li>
<li><strong>.bss</strong> 未初始化的数据段。</li>
<li><strong>.rodata</strong> 只读数据段。</li>
</ul>
<p>我们当然可以自己使用.section来定义一个段，每个段以段名开始，以下一段名或者文件结尾结束，比如：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.section</span> <span class="hljs-string">.testsection</span> @定义一个testsetcion段<br></code></pre></td></tr></table></figure>
<p>汇编程序的默认入口标号是 <code>_start</code>，不过我们也可以在链接脚本中使用 <code>ENTRY</code> 来指明其它的入口点，下面的代码就是使用 <code>_start</code> 作为入口标号：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit">.<span class="hljs-keyword">global</span> _start   <br><br>_start:<br>	ldrr0, =<span class="hljs-number">0x12</span>  <span class="hljs-symbol">@r0</span>=<span class="hljs-number">0x12</span><br></code></pre></td></tr></table></figure>

<p>上面代码中 <code>.global</code> 是伪操作（和上面的都属于伪操作，这里时定义变量，上面的是定义段），表示<code>_start</code>是一个全局标号，类似C语言里面的全局变量一样，常见的伪操作有：</p>
<ul>
<li><strong>.byte</strong>  定义单字节数据 ，比如.byte 0x12。</li>
<li><strong>.short</strong> 定义双字节数据，比如.short0x1234。</li>
<li><strong>.long</strong> 定义一个4字节数据，比如.long 0x12345678。</li>
<li><strong>.equ</strong> 赋值语句，格式为：.equ 变量名，表达式，比如.equ num, 0x12，表示num&#x3D;0x12。</li>
<li><strong>.align</strong> 数据字节对齐，比如：.align 4表示4字节对齐。</li>
<li><strong>.end</strong> 表示源文件结束。</li>
<li><strong>.global</strong> 定义一个全局符号，格式为：.global symbol，比如：.global_start。</li>
</ul>
<p>GNU汇编同样也支持函数，函数格式如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">函数名:</span><br>	函数体<br>	返回语句<br></code></pre></td></tr></table></figure>
<p>GNU汇编函数返回语句不是必须的，如下代码就是用汇编写的Cortex-A7中断服务函数：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">/* 未定义中断*/</span><br><span class="hljs-symbol">Undefined_Handler:</span><br>	<span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>,<span class="hljs-symbol">=Undefined_Handler</span><br>	<span class="hljs-keyword">bx</span> <span class="hljs-built_in">r0</span><br><br><span class="hljs-comment">/* SVC中断*/</span><br><span class="hljs-symbol">SVC_Handler:</span><br>	<span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>,<span class="hljs-symbol">=SVC_Handler</span><br>	<span class="hljs-keyword">bx</span> <span class="hljs-built_in">r0</span><br><br><span class="hljs-comment">/* 预取终止中断*/</span><br><span class="hljs-symbol">PrefAbort_Handler:</span><br>	<span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>,<span class="hljs-symbol">=PrefAbort_Handler</span>  <br>	<span class="hljs-keyword">bx</span> <span class="hljs-built_in">r0</span><br></code></pre></td></tr></table></figure>
<p>上述代码中定义了三个汇编函数：Undefined_Handler、SVC_Handler和PrefAbort_Handler。<br>以函数Undefined_Handler为例我们来看一下汇编函数组成，“Undefined_Handler”就是函数名，“ldr r0, &#x3D;Undefined_Handler”是函数体，“bx r0”是函数返回语句，“bx”指令是返回指令，函数返回语句不是必须的。</p>
<h3 id="Cortex-A7常用汇编指令"><a href="#Cortex-A7常用汇编指令" class="headerlink" title="Cortex-A7常用汇编指令"></a>Cortex-A7常用汇编指令</h3><h4 id="处理器内部数据传输指令"><a href="#处理器内部数据传输指令" class="headerlink" title="处理器内部数据传输指令"></a>处理器内部数据传输指令</h4><p>使用处理器做的最多事情就是在处理器内部来回的传递数据，常见的操作有：</p>
<ol>
<li>将数据从一个寄存器传递到另外一个寄存器。</li>
<li>将数据从一个寄存器传递到特殊寄存器，如CPSR和SPSR寄存器。</li>
<li>将立即数传递到寄存器。</li>
</ol>
<p>数据传输常用的指令有三个：MOV、MRS和MSR，这三个指令的用法如表所示：</p>
<blockquote>
<p>这三条指令只能在寄存器之间移动数据</p>
</blockquote>
<table>
<thead>
<tr>
<th>指令</th>
<th>目的</th>
<th>源</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>MOV</td>
<td>Rx</td>
<td>Ry</td>
<td>Ry数据复制到Rx</td>
</tr>
<tr>
<td>MRS</td>
<td>Rx</td>
<td>xPSR</td>
<td>特殊寄存器xPSR数据复制到Rx</td>
</tr>
<tr>
<td>MSR</td>
<td>xPSR</td>
<td>Rx</td>
<td>Rx数据复制到特殊寄存器xPSR</td>
</tr>
</tbody></table>
<h5 id="MOV指令"><a href="#MOV指令" class="headerlink" title="MOV指令"></a>MOV指令</h5><p>MOV指令用于将数据从一个寄存器拷贝到另外一个寄存器，或者将一个立即数传递到寄存器里面，使用示例如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R0</span>，<span class="hljs-built_in">R1</span>    @将寄存器<span class="hljs-built_in">R1</span>中的数据传递给<span class="hljs-built_in">R0</span>，即<span class="hljs-built_in">R0</span>=<span class="hljs-built_in">R1</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R0</span>, #<span class="hljs-number">0X12</span> @将立即数<span class="hljs-number">0X12</span>传递给<span class="hljs-built_in">R0</span>寄存器，即<span class="hljs-built_in">R0</span>=<span class="hljs-number">0X122</span>、<br></code></pre></td></tr></table></figure>
<h5 id="MRS指令"><a href="#MRS指令" class="headerlink" title="MRS指令"></a>MRS指令</h5><p>MRS指令用于将特殊寄存器(如CPSR和SPSR)中的数据传递给通用寄存器，要读取特殊寄存器的数据只能使用MRS指令！使用示例如下：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">MRS <span class="hljs-built_in">R0</span>, CPSR@将特殊寄存器CPSR里面的数据传递给<span class="hljs-built_in">R0</span>，即<span class="hljs-built_in">R0</span>=CPSR<br></code></pre></td></tr></table></figure>
<h5 id="MSR指令"><a href="#MSR指令" class="headerlink" title="MSR指令"></a>MSR指令</h5><p>MSR指令和MRS刚好相反，MSR指令用来将普通寄存器的数据传递给特殊寄存器，也就是写特殊寄存器，写特殊寄存器只能使用MSR，使用示例如下：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">MSR CPSR, <span class="hljs-built_in">R0</span>@将<span class="hljs-built_in">R0</span>中的数据复制到CPSR中，即CPSR=<span class="hljs-built_in">R0</span><br></code></pre></td></tr></table></figure>
<h4 id="存储器访问指令"><a href="#存储器访问指令" class="headerlink" title="存储器访问指令"></a>存储器访问指令</h4><p>上述的 MOV、MRS、MSR 是无法直接访问 ARM存储器的，比如 RAM （运存）中的数据，I.MX6UL中的存储器（数据地址）就是 RAM 类型的，我们用汇编来配置 I.MX6UL 的时候需要借助存储器访问指令。一般先将要配置的值写入到Rx(x&#x3D;0~12)寄存器中，然后借助存储器访问指令将Rx中的数据写入到I.MX6UL存储器中。读取I.MX6UL存储器也是一样的，只是过程相反。常用的存储器访问指令有两种：LDR和STR，用法如表所示：</p>
<blockquote>
<p>所有运算处理都是发生通用寄存器(一般是R0~R14)的之中。所有存储器空间(如C语言变量的本质就是一个存储器空间上的几个BYTE)的值的处理，都是要传送到通用寄存器来完成。因此代码中大量需要LDR,STR指令来传送值</p>
</blockquote>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LDR Rd, [Rn , #offset]</td>
<td>从存储器Rn+offset的位置读取数据存放到Rd中。</td>
</tr>
<tr>
<td>STR Rd, [Rn, #offset]</td>
<td>将Rd中的数据写入到存储器中的Rn+offset位置。</td>
</tr>
</tbody></table>
<h5 id="1、LDR指令"><a href="#1、LDR指令" class="headerlink" title="1、LDR指令"></a>1、LDR指令</h5><p>L表示LOAD，LOAD的含义应该理解为：Load from memory into register。<br>LDR主要用于从存储加载数据到寄存器Rx中，LDR也可以将一个立即数加载到寄存器Rx中，LDR加载立即数的时候要使用“&#x3D;”，而不是“#”。<br>在嵌入式开发中，LDR最常用的就是读取CPU的寄存器值，比如I.MX6UL有个寄存器GPIO1_GDIR，其地址为0X0209C004，我们现在要读取这个寄存器中的数据，示例代码如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">LDR <span class="hljs-built_in">R0</span>,=<span class="hljs-number">0X0209C004</span>   @将寄存器地址<span class="hljs-number">0X0209C004</span>加载到<span class="hljs-built_in">R0</span>中，即<span class="hljs-built_in">R0</span>=<span class="hljs-number">0X0209C004</span> ，立即数加载<br>LDR <span class="hljs-built_in">R1</span>,[<span class="hljs-built_in">R0</span>]			 @读取地址<span class="hljs-number">0X0209C004</span>中的数据到<span class="hljs-built_in">R1</span>寄存器中，从存储器加载数据到<span class="hljs-built_in">R1</span>中<br><br>@也可以直接这么写<br>LDR <span class="hljs-built_in">R1</span>,<span class="hljs-number">0X0209C004</span> 	 <br></code></pre></td></tr></table></figure>
<p>上述代码就是读取寄存器GPIO1_GDIR中的值，读取到的寄存器值保存在R1寄存器中，上面代码中offset是0，也就是没有用到offset。</p>
<h5 id="2、STR指令"><a href="#2、STR指令" class="headerlink" title="2、STR指令"></a>2、STR指令</h5><p>S表示STORE，STORE的含义应该理解为：Store from a register into memory。<br>LDR是从存储器读取数据，STR就是将数据写入到存储器中，同样以I.MX6UL寄存器GPIO1_GDIR为例，现在我们要配置寄存器GPIO1_GDIR的值为0X2000002，示例代码如下：示例代码7.2.2.2    </p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">LDR <span class="hljs-built_in">R0</span>,=<span class="hljs-number">0X0209C004</span>	@将寄存器地址<span class="hljs-number">0X0209C004</span>加载到<span class="hljs-built_in">R0</span>中，即<span class="hljs-built_in">R0</span>=<span class="hljs-number">0X0209C004</span><br>LDR <span class="hljs-built_in">R1</span>,=<span class="hljs-number">0X20000002</span>	@<span class="hljs-built_in">R1</span>保存要写入到寄存器的值，即<span class="hljs-built_in">R1</span>=<span class="hljs-number">0X20000002</span><br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">R1</span>,[<span class="hljs-built_in">R0</span>]			@将<span class="hljs-built_in">R1</span>中的值写入到<span class="hljs-built_in">R0</span>中所保存的地址中<br></code></pre></td></tr></table></figure>
<p>LDR和STR都是按照字进行读取和写入的，也就是操作的32位数据，如果要按照字节、半字进行操作的话可以在指令“LDR”后面加上B或H，比如按字节操作的指令就是LDRB和STRB，按半字操作的指令就是LDRH和STRH。</p>
<h4 id="压栈和出栈指令"><a href="#压栈和出栈指令" class="headerlink" title="压栈和出栈指令"></a>压栈和出栈指令</h4><p>我们通常会在A函数中调用B函数，当B函数执行完以后再回到A函数继续执行。要想在跳回A函数以后代码能够接着正常运行，那就必须在跳到B函数之前将当前处理器状态保存起来(就是保存R0<del>R15这些寄存器值)，当B函数执行完成以后再用前面保存的寄存器值恢复R0</del>R15即可。  </p>
<p>保存R0-R15寄存器的操作就叫做现场保护，恢复R0~R15寄存器的操作就叫做恢复现场。在进行现场保护的时候需要进行压栈(入栈)操作，恢复现场就要进行出栈操作。压栈的指令为PUSH，出栈的指令为POP，PUSH和POP是一种多存储和多加载指令，即可以一次操作多个寄存器数据，他们利用当前的栈指针SP来生成地址，PUSH和POP的用法如表所示：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PUSH &lt;reglist&gt;</td>
<td>将寄存器列表存入栈中</td>
</tr>
<tr>
<td>POP   &lt;reg list&gt;</td>
<td>从栈中恢复寄存器列表</td>
</tr>
</tbody></table>
<p>假如我们现在要将R0~R3和R12这5个寄存器压栈，当前的SP指针指向0X80000000，处理器的堆栈是向下增长的，使用的汇编代码如下：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">PUSH</span> &#123;<span class="hljs-built_in">R0</span>~<span class="hljs-built_in">R3</span>, <span class="hljs-built_in">R12</span>&#125;	@将<span class="hljs-built_in">R0</span>~<span class="hljs-built_in">R3</span>和<span class="hljs-built_in">R12</span>压栈<br></code></pre></td></tr></table></figure>
<p>压栈完成以后的堆栈如图所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8E%8B%E6%A0%88%E4%BB%A5%E5%90%8E%E7%9A%84%E5%A0%86%E6%A0%88.png" srcset="/img/loading.gif" lazyload alt="enter description here"><br>图7.2.3.1就是对R0~R3,R12进行压栈以后的堆栈示意图，此时的SP指向了0X7FFFFFEC，假如我们现在要再将LR进行压栈，汇编代码如下：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">PUSH</span> &#123;<span class="hljs-built_in">LR</span>&#125;<span class="hljs-comment">@将LR进行压栈</span><br></code></pre></td></tr></table></figure>
<p>对LR进行压栈完成以后的堆栈模型如图7.2.3.2所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/LR%E5%8E%8B%E6%A0%88%E4%BB%A5%E5%90%8E%E7%9A%84%E5%A0%86%E6%A0%88.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>图7.2.3.2就是分两步对R0~R3,R2和LR进行压栈以后的堆栈模型，如果我们要出栈的话就是使用如下代码：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">POP</span> &#123;LR&#125;	 	@先恢复LR<br><span class="hljs-keyword">POP</span> &#123;<span class="hljs-built_in">R0</span>~<span class="hljs-built_in">R3</span>,<span class="hljs-built_in">R12</span>&#125;	@在恢复<span class="hljs-built_in">R0</span>~<span class="hljs-built_in">R3</span>,<span class="hljs-built_in">R12</span><br></code></pre></td></tr></table></figure>
<p>出栈的就是从栈顶，也就是SP当前执行的位置开始，地址依次减小来提取堆栈中的数据到要恢复的寄存器列表中(先入后出)。PUSH和POP的另外一种写法是“STMFD SP！”和“LDMFD SP!”，因此上面的汇编代码可以改为：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">STMFD <span class="hljs-built_in">SP</span>!,&#123;<span class="hljs-built_in">R0</span>~<span class="hljs-built_in">R3</span>,<span class="hljs-built_in">R12</span>&#125;	@<span class="hljs-built_in">R0</span>~<span class="hljs-built_in">R3</span>,<span class="hljs-built_in">R12</span>入栈<br>STMFD <span class="hljs-built_in">SP</span>!,&#123;LR&#125;			@LR入栈<br><br>LDMFD <span class="hljs-built_in">SP</span>!,&#123;LR&#125;			@先恢复LR<br>LDMFD <span class="hljs-built_in">SP</span>!,&#123;<span class="hljs-built_in">R0</span>~<span class="hljs-built_in">R3</span>,<span class="hljs-built_in">R12</span>&#125;	@再恢复<span class="hljs-built_in">R0</span>~<span class="hljs-built_in">R3</span>,<span class="hljs-built_in">R12</span><br></code></pre></td></tr></table></figure>
<p>STMFD可以分为两部分：STM和FD，同理，LDMFD也可以分为LDM和FD。看到STM和LDM有没有觉得似曾相识，前面我们讲了LDR和STR，这两个是数据加载和存储指令，但是每次只能读写存储器中的一个数据。STM和LDM就是多存储和多加载，可以连续的读写存储器中的多个连续数据。<br>FD是FullDescending的缩写，即满递减的意思。根据ATPCS规则,ARM使用的FD类型的堆栈，SP指向最后一个入栈的数值，堆栈是由高地址向下增长的，也就是前面说的向下增长的堆栈，因此最常用的指令就是STMFD和LDMFD。STM和LDM的指令寄存器列表中编号小的对应低地址，编号高的对应高地址。</p>
<p><code>LDMFD SP!,&#123;R0~R3,R12&#125;</code>：把sp指向的3个连续地址段（应该是3*4&#x3D;12字节)中数据拷贝到 r0,r1,r2 这3个寄存器中去了（因为 r0,r1,r2 都是32位，所以数据要分别存储 ）。</p>
<h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><p>有多种跳转操作，比如：</p>
<ul>
<li>直接使用跳转指令B、BL、BX等。</li>
<li>直接向PC寄存器里面写入数据。<br>上述两种方法都可以完成跳转操作，但是一般常用的还是B、BL或BX，用法如表</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>B&lt;label&gt;</td>
<td>跳转到label，如果跳转范围超过了+&#x2F;-2KB，可以使用32位版本的跳转指令 <code>B.W \&lt;label&gt;</code>，这样可以得到较大范围的跳转</td>
</tr>
<tr>
<td>BX&lt;Rm&gt;</td>
<td>间接跳转，跳转到存放于Rm中的地址处，并且切换指令集</td>
</tr>
<tr>
<td>BL &lt;label&gt;</td>
<td>跳转到标号地址，并将返回地址保存在LR中</td>
</tr>
<tr>
<td>BLX&lt;Rm&gt;</td>
<td>结合BX和BL的特点，跳转到Rm指定的地址，并将返回地址保存在LR中，切换指令集</td>
</tr>
</tbody></table>
<h5 id="1、B指令"><a href="#1、B指令" class="headerlink" title="1、B指令"></a>1、B指令</h5><p>有去无回。这是最简单的跳转指令，B指令会将PC寄存器的值设置为跳转目标地址，一旦执行B指令，ARM处理器就会立即跳转到指定的目标地址。如果要调用的函数不会再返回到原来的执行处，那就可以用B指令，如下示例：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">_start:</span><br>	<span class="hljs-keyword">ldr</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">=0X80200000</span>	<span class="hljs-comment">@设置栈指针</span><br>	<span class="hljs-keyword">b</span> main              <span class="hljs-comment">@跳转到main函数</span><br></code></pre></td></tr></table></figure>
<p>上述代码只是初始化了SP指针，有些处理器还需要做其他的初始化，比如初始化DDR等等。因为跳转到C文件以后再也不会回到汇编了，所以在第4行使用了B指令来完成跳转。</p>
<h5 id="2、BL指令"><a href="#2、BL指令" class="headerlink" title="2、BL指令"></a>2、BL指令</h5><p>BL指令相比B指令，在跳转之前会在寄存器LR(R14)中保存当前PC寄存器值，所以可以通过将LR寄存器中的值重新加载到PC中来继续从跳转之前的代码处运行，这是子程序调用的一个基本但常用的手段。常用在中断处理中。示例代码如下：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>push &#123;r0,r1&#125;	@保存r0,r1<br><span class="hljs-symbol">2 </span>cps #<span class="hljs-number">0</span>x13	@进入SVC模式，允许其他中断再次进去<br><br><span class="hljs-symbol">3 </span>bl system_irqhandler   @加载C语言中断处理函数到r2寄存器中<br><br><span class="hljs-symbol">4 </span>cps #<span class="hljs-number">0</span>x12	@进入IRQ模式<br><span class="hljs-symbol">5 </span>pop &#123;r0,r1&#125;<br><span class="hljs-symbol">6 </span>str r0,[r1,#<span class="hljs-number">0</span>X10]	@中断执行完成，写EOIR<br></code></pre></td></tr></table></figure>
<p>上述代码中第5行就是执行C语言版的中断处理函数，当处理完成以后是需要返回来继续执行下面的程序，所以使用了BL指令。</p>
<h4 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h4><p>汇编中也可以进行算术运算，比如加减乘除，常用的运算指令用法如表所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4.png" srcset="/img/loading.gif" lazyload alt="enter description here"><br>在嵌入式开发中最常会用的就是加减指令，乘除基本用不到。</p>
<h4 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h4><p>我们用C语言进行CPU寄存器配置的时候常常需要用到逻辑运算符号，比如“&amp;”、“|”等逻辑运算符。使用汇编语言的时候也可以使用逻辑运算指令，常用的运算指令用法如表所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4.png" srcset="/img/loading.gif" lazyload alt="enter description here"><br>逻辑运算指令都很好理解，后面时候汇编配置I.MX6UL的外设寄存器的时候可能会用到，ARM汇编就讲解到这里，</p>
<p>本节主要讲解了一些最常用的指令。要想详细的学习ARM的所有指令请参考</p>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ul>
<li><a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/den0013/d">ARM® Cortex™-A Series Programmer’s Guide  Version: 4.0</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/ddi0406/cd">ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf</a></li>
</ul>
<h2 id="汇编LED灯实验"><a href="#汇编LED灯实验" class="headerlink" title="汇编LED灯实验"></a>汇编LED灯实验</h2><h3 id="I-MX6U-GPIO详解"><a href="#I-MX6U-GPIO详解" class="headerlink" title="I.MX6U GPIO详解"></a>I.MX6U GPIO详解</h3><p>STM32的GPIO初始化步骤：</p>
<ol>
<li>使能指定GPIO的时钟。</li>
<li>初始化GPIO，比如输出功能、上拉、速度等等。</li>
<li>STM32有的IO可以作为其它外设引脚，也就是IO复用，如果要将IO作为其它外设引脚使用的话就需要设置IO的复用功能。</li>
<li>最后设置GPIO输出高电平或者低电平。</li>
</ol>
<p>要将I.MX6U的IO作为GPIO使用，我们需要一下几步：</p>
<ol>
<li>使能GPIO对应的时钟。</li>
<li>设置寄存器IOMUXC_SW_MUX_CTL_PAD_XX_XX，设置IO的复用功能，使其复用为GPIO功能。</li>
<li>设置寄存器IOMUXC_SW_PAD_CTL_PAD_XX_XX，设置IO的上下拉、速度等等。</li>
<li>配置GPIO，设置输入&#x2F;输出、是否使用中断、默认输出电平等。</li>
</ol>
<h4 id="I-MX6U-IO命名"><a href="#I-MX6U-IO命名" class="headerlink" title="I.MX6U IO命名"></a>I.MX6U IO命名</h4><p>打开I.MX6UL参考手册的第30章“Chapter32: IOMUX Controller(IOMUXC)”</p>
<p>根据 IO 功能命名，GPIO只有GPIO1_IO00~GPIO_IO09，其他为复用IO。<br>I.MX6U 的 GPIO 一共有 5 组：GPIO1、GPIO2、GPIO3、GPIO4 和 GPIO5，其中 GPIO1 有 32 个 IO，GPIO2 有 22 个 IO，GPIO3 有 29 个 IO、GPIO4 有 29 个 IO，GPIO5最少，只有 12 个 IO，这样一共有 124 个 GPIO。</p>
<h4 id="I-MX6U-IO复用"><a href="#I-MX6U-IO复用" class="headerlink" title="I.MX6U IO复用"></a>I.MX6U IO复用</h4><p>看每个IO能复用什么外设的话可以直接查阅《IMX6UL参考手册》的第4章“Chapter4ExternalSignalsandPinMultiplexing”。<br>如果我们要编写代码，设置某个IO的复用功能的话就需要查阅第30章“Chapter32: IOMUX Controller(IOMUXC)”。</p>
<h4 id="I-MX6U-IO配置"><a href="#I-MX6U-IO配置" class="headerlink" title="I.MX6U IO配置"></a>I.MX6U IO配置</h4><p>前面说过，配置 IO 需要两种寄存器。</p>
<ul>
<li>SW_MUX_CTL_PAD_*负责设置管脚使用什么复用功能，</li>
<li>SW_PAD_CTL_PAD_*用来设置管脚的属性，比如在输出时什么属性，输入时什么属性。</li>
</ul>
<p>GPIO功能图<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/GPIO%E5%8A%9F%E8%83%BD%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>我们对照着图来详细看一下寄存器各个位的含义：</p>
<ul>
<li>HYS(bit16)：对应图中HYS，用来使能迟滞比较器，当IO作为输入功能的时候有效，用于设置输入接收器的施密特触发器是否使能。如果需要对输入波形进行整形的话可以使能此位。此位为0的时候禁止迟滞比较器，为1的时候使能迟滞比较器。</li>
<li>PUS(bit15:14)：对应图中的PUS，用来设置上下拉电阻的，一共有四种选项可以选择，如表所示<br> <img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%8A%E4%B8%8B%E6%8B%89%E8%AE%BE%E7%BD%AE.png" srcset="/img/loading.gif" lazyload alt="enter description here"></li>
<li>PUE(bit13)：图中没有给出来，当IO作为输入的时候，这个位用来设置IO使用上下拉还是状态保持器。当为0的时候使用状态保持器，当为1的时候使用上下拉。状态保持器在IO作为输入的时候才有用，顾名思义，就是当外部电路断电以后此IO口可以保持住以前的状态。</li>
<li>PKE(bit12)：对应图中的PKE，此为用来使能或者禁止上下拉&#x2F;状态保持器功能，为0时禁止上下拉&#x2F;状态保持器，为1时使能上下拉和状态保持器。</li>
<li>ODE(bit11)：对应图中的ODE，当IO作为输出的时候，此位用来禁止或者使能开路输出，此位为0的时候禁止开路输出，当此位为1的时候就使能开路输出功能。</li>
<li>SPEED(bit7:6)：对应图中的SPEED，当IO用作输出的时候，此位用来设置IO速度，设置如表所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9F%E5%BA%A6%E9%85%8D%E7%BD%AE.png" srcset="/img/loading.gif" lazyload alt="enter description here"></li>
<li>DSE(bit5:3)：对应图中的DSE，当IO用作输出的时候用来设置IO的驱动能力，总共有8个可选选项，如表所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%B1%E5%8A%A8%E8%83%BD%E5%8A%9B%E8%AE%BE%E7%BD%AE.png" srcset="/img/loading.gif" lazyload alt="enter description here"></li>
<li>SRE(bit0)：对应图中的SRE，设置压摆率，当此位为0的时候是低压摆率，当为1的时候是高压摆率。这里的压摆率就是IO电平跳变所需要的时间，比如从0到1需要多少时间，时间越小波形就越陡，说明压摆率越高；反之，时间越多波形就越缓，压摆率就越低。如果你的产品要过EMC的话那就可以使用小的压摆率，因为波形缓和，如果你当前所使用的IO做高速通信的话就可以使用高压摆率。</li>
</ul>
<h3 id="I-MX6U-GPIO配置"><a href="#I-MX6U-GPIO配置" class="headerlink" title="I.MX6U GPIO配置"></a>I.MX6U GPIO配置</h3><p><code>IOMUXC_SW_MUX_CTL_PAD_XX_XX</code>和<code>IOMUXC_SW_PAD_CTL_PAD_XX_XX</code>这两种寄存器都是配置IO的，注意是IO！不是GPIO，GPIO是一个IO众多复用功能中的一种。</p>
<p>关于I.MX6U的GPIO请参考《IMX6UL参考手册》的第28章“Chapter 28 General Purpose Input&#x2F;Ouput(GPIO)”，GPIO结构如图所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/GPIO%E7%BB%93%E6%9E%84%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>左下角 的IOMUXC框图里SW_MUX_CTL_PAD_*和SW_PAD_CTL_PAD_*两种寄存器，用来设置IO的复用功能和IO属性配置。左上角部分的GPIO框图就是当IO用作GPIO的时候需要设置的寄存器，一共有八个：DR、GDIR、PSR、ICR1、ICR2、EDGE_SEL、IMR和ISR。</p>
<ul>
<li><p>DR数据寄存器</p>
<ul>
<li>此寄存器是32位的，每个位都对应一个GPIO。</li>
<li>当GPIO被配置为输出功能以后，此寄存器设置相应的IO输出高低电平</li>
<li>当GPIO被配置为输入模式以后，此寄存器就保存着对应IO的电平值。</li>
</ul>
</li>
<li><p>DR方向寄存器</p>
<ul>
<li>GDIR寄存器也是32位的，同样的，每个IO对应一个位，</li>
<li>此寄存器用来设置某个IO的工作方向，是输入还是输出。</li>
<li>输入为0，输出为1。</li>
</ul>
</li>
<li><p>PSR状态寄存器</p>
<ul>
<li>同样的PSR寄存器也是一个GPIO对应一个位，</li>
<li>读取相应的位即可获取对应的GPIO的状态，也就是GPIO的高低电平值。</li>
<li>功能和输入状态下的DR寄存器一样。</li>
</ul>
</li>
<li><p>ICR1和ICR2中断控制寄存器</p>
<ul>
<li>ICR1用于IO0~15的配置，ICR2用于IO16~31的配置。</li>
<li>ICR寄存器中一个GPIO用两个位，这两个位用来配置中断的触发方式，如表所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%AD%E6%96%AD%E8%A7%A6%E5%8F%91%E9%85%8D%E7%BD%AE.png" srcset="/img/loading.gif" lazyload alt="enter description here"></li>
</ul>
</li>
<li><p>IMR中断屏蔽寄存器</p>
<ul>
<li>一个GPIO对应一个位，</li>
<li>控制GPIO的中断禁止和使能，使能设为1；禁止中断，就设为0。</li>
</ul>
</li>
<li><p>ISR中断状态寄存器</p>
<ul>
<li>一个GPIO对应一个位</li>
<li>只要某个GPIO的中断发生，那么ISR中相应的位就会被置1。</li>
<li>处理完中断以后，必须清除中断标志位，清除方法就是向ISR中相应的位写1，也就是写1清零。</li>
</ul>
</li>
<li><p>EDGE_SEL边沿选择寄存器</p>
<ul>
<li>E设置边沿中断，这个寄存器会覆盖ICR1和ICR2的设置，同样是一个GPIO对应一个位。</li>
<li>如果相应的位被置1，那么就相当与设置了对应的GPIO是上升沿和下降沿(双边沿)触发</li>
</ul>
</li>
</ul>
<h4 id="I-MX6U-GPIO时钟使能"><a href="#I-MX6U-GPIO时钟使能" class="headerlink" title="I.MX6U GPIO时钟使能"></a>I.MX6U GPIO时钟使能</h4><p>I.MX6UL 参考手册的第 18 章“Chapter 18: Clock Controller Module(CCM)”<br>我们只看一下CCM里面的外设时钟使能寄存器。CMM 有 CCM_CCGR0~CCM_CCGR6 这 7 个寄存器，这 7 个寄存器控制着 I.MX6U 的所有外设时钟开关<br>以CCM_CCGR0为例：</p>
<ul>
<li>CCM_CCGR0 是个 32 位寄存器，其中每 2 位控制一个外设的时钟，比如 bit31:30 控制着-GPIO2 的外设时钟，两个位就有 4 种操作方式。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%96%E8%AE%BE%E6%97%B6%E9%92%9F%E6%8E%A7%E5%88%B6.png" srcset="/img/loading.gif" lazyload alt="enter description here"></li>
</ul>
<p>为了方便开发，本教程后面所有的例程将 I.MX6U 的所有外设时钟都打开了</p>
<h3 id="硬件原理图"><a href="#硬件原理图" class="headerlink" title="硬件原理图"></a>硬件原理图</h3><p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/LED%E5%8E%9F%E7%90%86%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>LED0接到了GPIO_3上，GPIO_3就是GPIO1_IO03</p>
<h3 id="实验程序编写"><a href="#实验程序编写" class="headerlink" title="实验程序编写"></a>实验程序编写</h3><p><strong>所有的裸机实验我们都在Ubuntu下完成，使用VSCode编辑器！</strong></p>
<p>在 <code>linux/driver/board_driver</code> 文件夹下新建本次的工程文件夹 <code>1_led</code>，并在这个目录下新建一个名为“led.s”的汇编文件和一个名为“.vscode”的目录，创建好以后“1_led” 如下所示</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">lonly@lonly-VirtualBox:~<span class="hljs-regexp">/linux/</span>driver<span class="hljs-regexp">/board_driver/</span><span class="hljs-number">1</span>_led$ touch led.s<br>lonly@lonly-VirtualBox:~<span class="hljs-regexp">/linux/</span>driver<span class="hljs-regexp">/board_driver/</span><span class="hljs-number">1</span>_led$ mkdir .vscode<br>lonly@lonly-VirtualBox:~<span class="hljs-regexp">/linux/</span>driver<span class="hljs-regexp">/board_driver/</span><span class="hljs-number">1</span>_led$ ls -a<br>.  ..  led.s  .vscode<br></code></pre></td></tr></table></figure>

<p>.vscode文件夹里面存放VSCode的工程文件，led.s就是我们新建的汇编文件，我们稍后会在led.s这个文件中编写汇编程序。使用VSCode打开1_leds这个文件夹，在led.s中输入如下代码：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Copyright (c)   LonlyPan . 1998-2020.  All rights reserved.</span><br><span class="hljs-comment">  * @file:    led.s</span><br><span class="hljs-comment">  * @author:  LonlyPan</span><br><span class="hljs-comment">  * @version: V1.0</span><br><span class="hljs-comment">  * @date:    2020-11-29</span><br><span class="hljs-comment">  * @brief:   裸机实验1 汇编点灯</span><br><span class="hljs-comment">              使用汇编来点亮开发板上的LED灯，学习和掌握如何用汇编语言来完成对I.MX6U处理器的GPIO初始化和控制。</span><br><span class="hljs-comment">  * @attentio: </span><br><span class="hljs-comment">  * @Modification: </span><br><span class="hljs-comment">  * @History:</span><br><span class="hljs-comment">  *   1.Version: V1.0</span><br><span class="hljs-comment">  *   Author: LonlyPan</span><br><span class="hljs-comment">  *     date: 2020-11-29</span><br><span class="hljs-comment">  *     Modification: 初版</span><br><span class="hljs-comment">  */</span><br><br><span class="hljs-symbol">.global</span> _start <span class="hljs-comment">/* 全局标号 */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief  _start函数，程序从此函数开始执行此函数完成时钟使能、GPIO初始化、最终控制GPIO输出低电平来点亮LED灯</span><br><span class="hljs-comment"> * @note    </span><br><span class="hljs-comment"> * @param </span><br><span class="hljs-comment"> * @retval  </span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-symbol">_start:</span>   <br> <br><span class="hljs-comment">/* 使能所有的IO 时钟 */</span><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, <span class="hljs-number">=0X020C4068</span>  <span class="hljs-comment">/* 寄存器CCGR0 */</span><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R1</span>, <span class="hljs-number">=0XFFFFFFFF</span><br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">R1</span>, [<span class="hljs-built_in">R0</span>]<br><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, <span class="hljs-number">=0X020C406C</span>  <span class="hljs-comment">/* 寄存器CCGR1 */</span><br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">R1</span>, [<span class="hljs-built_in">R0</span>]<br><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, <span class="hljs-number">=0X020C4070</span>  <span class="hljs-comment">/* 寄存器CCGR2 */</span><br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">R1</span>, [<span class="hljs-built_in">R0</span>]<br><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, <span class="hljs-number">=0X020C4074</span>  <span class="hljs-comment">/* 寄存器CCGR3 */</span><br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">R1</span>, [<span class="hljs-built_in">R0</span>]<br><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, <span class="hljs-number">=0X020C4078</span>  <span class="hljs-comment">/* 寄存器CCGR4 */</span><br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">R1</span>, [<span class="hljs-built_in">R0</span>]<br><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, <span class="hljs-number">=0X020C407C</span>  <span class="hljs-comment">/* 寄存器CCGR5 */</span><br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">R1</span>, [<span class="hljs-built_in">R0</span>]<br><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, <span class="hljs-number">=0X020C4080</span>  <span class="hljs-comment">/* 寄存器CCGR6 */</span><br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">R1</span>, [<span class="hljs-built_in">R0</span>]<br><br><span class="hljs-comment">/* 2、设置GPIO1_IO03复用为GPIO1_IO03 */</span><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, <span class="hljs-number">=0x020E0068</span>  <span class="hljs-comment">/* 将寄存器 SW_MUX_GPIO1_IO3_BASE加载到r0中 */</span><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R1</span>, <span class="hljs-number">=0x5</span> <span class="hljs-comment">/* 设置寄存器 SW_MUX_GPIO1_IO3_BASE 的 MUX_MODE 为 5 也就是 GPIO 模式 */</span><br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">R1</span>, [<span class="hljs-built_in">R0</span>]<br><br><span class="hljs-comment">/* 配置 GPIO_IO03 的 IO 属性 </span><br><span class="hljs-comment"> * bit [16]: 0 HYS 关闭</span><br><span class="hljs-comment"> * bit [15&quot;14]: 00 默认下拉</span><br><span class="hljs-comment"> * bit [13]: 0 keeper功能</span><br><span class="hljs-comment"> * bit [12]: 1 pull/keeper 使能</span><br><span class="hljs-comment"> * bit [11]: 0 关闭开路输出</span><br><span class="hljs-comment"> * bit [7:6]: 10 速度 100MHz</span><br><span class="hljs-comment"> * bit [5:3]: 110 R0/6 驱动能力</span><br><span class="hljs-comment"> * bit [0]: 0 低压摆率*/</span><br> <span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, <span class="hljs-number">=0x020E02F4</span> <span class="hljs-comment">/* 寄存器 SW_PAD_GPIO1_IO03_BASE */</span><br> <span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R1</span>, <span class="hljs-number">=0x10B0</span>  <span class="hljs-comment">/* 0001 0000 1011 0000arm-linux-gnueabihf-gcc -g -c led.s -0 led.o</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">/* 设置 GPIO_IO03 为输出 */</span><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, <span class="hljs-number">=0x0209C004</span> <span class="hljs-comment">/* 寄存器 GPIO_GDIR*/</span><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R1</span>, <span class="hljs-number">=0x00000008</span><br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">R1</span>, [<span class="hljs-built_in">R0</span>]<br><br><span class="hljs-comment">/* 打开 LED0 设置 GPIO_IO03 输出低电平*/</span><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, <span class="hljs-number">=0x0209C000</span><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R1</span>, <span class="hljs-number">=0</span><br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">R1</span>, [<span class="hljs-built_in">R0</span>]<br><br><span class="hljs-comment">/* 死循环 */</span><br><span class="hljs-symbol">loop:</span><br>  <span class="hljs-keyword">b</span> loop<br><br></code></pre></td></tr></table></figure>

<h3 id="编译下载验证"><a href="#编译下载验证" class="headerlink" title="编译下载验证"></a>编译下载验证</h3><p>创建Makefile文件</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">lonly@lonly-VirtualBox:~<span class="hljs-regexp">/linux/</span>driver<span class="hljs-regexp">/board_driver/</span><span class="hljs-number">1</span>_led$ ls<br>led.s  Makefile<br></code></pre></td></tr></table></figure>
<p>输入如下内容：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">led<span class="hljs-selector-class">.bin</span>:led<span class="hljs-selector-class">.s</span><br>	arm-linux-gnueabihf-gcc -g -c led<span class="hljs-selector-class">.s</span> -o led<span class="hljs-selector-class">.o</span>  @编译文件，只编译不链接。-g 产生调试信息。-c 编译源文件但不链接<br>	arm-linux-gnueabihf-ld -Ttext <span class="hljs-number">0</span>X87800000 led<span class="hljs-selector-class">.o</span> -o led<span class="hljs-selector-class">.elf</span> @链接文件，将 <span class="hljs-selector-class">.o</span> 文件链接到指定链接位置<br>	arm-linux-gnueabihf-objcopy -O binary -S -g led<span class="hljs-selector-class">.elf</span> led<span class="hljs-selector-class">.bin</span> @led.elf文件转换为led.bin文件 -O 指定格式输出 -S 不复制源文件中的重定位信息和符号信息 -g 不复制源文件调试信息<br>	arm-linux-gnueabihf-objdump -D led<span class="hljs-selector-class">.elf</span> &gt; led<span class="hljs-selector-class">.dis</span> @反汇编  -D 反汇编所有段<br>	<br>clean:<br>	rm -rf *<span class="hljs-selector-class">.o</span> led<span class="hljs-selector-class">.bin</span> led<span class="hljs-selector-class">.elf</span> led<span class="hljs-selector-class">.dis</span><br><br></code></pre></td></tr></table></figure>

<p>编写执行 <code>make</code> 完成编译</p>
<p>运行地址 <code>&lt;---&gt;</code>链接地址：他们两个是等价的，只是两种不同的说法。<br>加载地址 <code>&lt;---&gt;</code>存储地址：他们两个是等价的，也是两种不同的说法。</p>
<p>运行地址：程序在SRAM、SDRAM中执行时的地址。就是执行这条指令时，PC应该等于这个地址，换句话说，PC等于这个地址时，这条指令应该保存在这个地址内。</p>
<p>加载地址：程序保存在Nand flash中的地址。</p>
<p>位置无关码：B、BL、MOV都是位置位置无关码。<br>位置有关码：LDR PC,&#x3D;LABEL等类似的代码都是位置有关码。</p>
<h4 id="代码烧写"><a href="#代码烧写" class="headerlink" title="代码烧写"></a>代码烧写</h4><p>将正点原子的软件“imxdownload”，拷贝到工程根目录下，也就是和led.bin处于同一个文件夹下</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">lonly@lonly-VirtualBox:~/linux/driver/board_driver/<span class="hljs-number">1</span>_led$ ls<br>imxdownload  led<span class="hljs-selector-class">.bin</span>  led<span class="hljs-selector-class">.dis</span>  led<span class="hljs-selector-class">.elf</span>  led<span class="hljs-selector-class">.o</span>  led<span class="hljs-selector-class">.s</span>  load<span class="hljs-selector-class">.imx</span>  Makefile<br></code></pre></td></tr></table></figure>
<p>给该软件赋予执行权限</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">lonly@lonly-VirtualBox:~<span class="hljs-regexp">/linux/</span>driver<span class="hljs-regexp">/board_driver/</span><span class="hljs-number">1</span>_led$ chmod <span class="hljs-number">777</span> imxdownload <br></code></pre></td></tr></table></figure>
<p>使用imxdownload向SD卡烧写led.bin文件，命令格式如下：</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">./imxdownload   <span class="hljs-attribute">&lt;.bin file&gt;</span>    <span class="hljs-attribute">&lt;SDCard&gt;</span><br></code></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/imxdownload led.bin /</span>dev/sdd<br></code></pre></td></tr></table></figure>
<p>最后会生成一个 <code>load.imx</code> 文件。这个文件就是软件imxdownload根据NXP官方启动方式介绍的内容，在led.bin文件前面添加了一些数据头以后生成的。最终烧写到SD卡里面的就是这个load.imx文件，而非led.bin。</p>
<blockquote>
<p>烧写速度是201KB&#x2F;s。注意这个烧写速度，如果这个烧写速度在几百KB&#x2F;s以下那么就是正常烧写。如果这个烧写速度大于几十MB&#x2F;s、甚至几百MB&#x2F;s那么肯定是烧写失败了！<br>解决方法就是重新插拔SD卡，但一般出现这种情况，重新插拔SD卡基本没啥用，只有重启Ubuntu，原因不清楚。</p>
</blockquote>
<p>最后设置拨码开关为SD卡启动。设置好以后按一下开发板的复位键，如果代码运行正常的话LED0就会被点亮。为了验证，可以把SD卡拔了再重启，会发现led是熄灭的。说明sd卡起作用了，即程序执行了。<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8B%A8%E7%A0%81%E5%BC%80%E5%85%B3SD%E5%8D%A1%E5%90%AF%E5%8A%A8%E8%AE%BE%E7%BD%AE.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<h2 id="I-MX6U启动方式详解"><a href="#I-MX6U启动方式详解" class="headerlink" title="I.MX6U启动方式详解"></a>I.MX6U启动方式详解</h2><p>STM32 也有 boot 选择，一般我们的程序是直接下载到内部flash的，然后stm32从flash中读取程序运行。<br>而I.MX6U是没有flash的，它需要外挂存储器，开发版挂载的就是 DDR3 外部存储器，代码最终会存储到其中，然后运行。</p>
<blockquote>
<p>DDR 是掉电不保存的，我们的基本都是通过sd拷贝到DDR中运行的<br>NAND 是掉电保存的</p>
</blockquote>
<h3 id="启动方式选择"><a href="#启动方式选择" class="headerlink" title="启动方式选择"></a>启动方式选择</h3><table>
<thead>
<tr>
<th>BOOT_MODE[1:0]</th>
<th>BOOT类型</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>从FUSE启动</td>
</tr>
<tr>
<td>01</td>
<td>串行下载</td>
</tr>
<tr>
<td>10</td>
<td>内部BOOT模式</td>
</tr>
<tr>
<td>11</td>
<td>保留</td>
</tr>
</tbody></table>
<p>我们一般用到的只有第二和第三种BOOT方式。</p>
<h4 id="串行下载"><a href="#串行下载" class="headerlink" title="串行下载"></a>串行下载</h4><p>串行下载的意思就是可以通过USB或者UART将代码下载到板子上的外置存储设备中，我们可以使用OTG1这个USB口向开发板上的SD&#x2F;EMMC、NAND等存储设备下载代码。这个下载是需要用到NXP提供的一个软件，一般用来最终量产的时候将代码烧写到外置存储设备中的，我们后面讲解如何使用。</p>
<h4 id="内部BOOT模式"><a href="#内部BOOT模式" class="headerlink" title="内部BOOT模式"></a>内部BOOT模式</h4><p>在此模式下，芯片会执行内部的bootROM代码，这段boot ROM代码会进行硬件初始化(一部分外设)，然后从boot设备(就是存放代码的设备、比如SD&#x2F;EMMC、NAND)中将代码拷贝出来复制到指定的RAM中，一般是DDR。</p>
<p>然后我们还需要指定从什么样的 boot 复制代码。通过开发版上的拨码开关选择，具体原理这里不复制赘述。</p>
<blockquote>
<p>实际开始时是不需要拨码开关设置的，我们一般都是硬件电路设计直接默认选择一种启动方式（NAND），省去硬件设计</p>
</blockquote>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>启动设备</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>串行下载，可以通过USB烧写镜像文件。</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>SD卡启动。</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>EMMC启动。</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>NAND FLASH启动</td>
</tr>
</tbody></table>
<blockquote>
<p>SD卡启动实际是执行SD卡中存放的 bootROM 代码初始化设备，然后运行从SD卡复制到DDR中的实际程序代码。也就是我们最终运行的程序时存放在DDR中的，SD卡只负责初始化配置和暂时存放代码（代码 &#x3D; bootROM + 运行代码 ）</p>
</blockquote>
<p>总结一下，我们编译出来的.bin文件不能直接烧写到SD卡中，需要在.bin文件前面加上IVT、BootData和DCD这三个数据块( <strong>bootROM</strong>)。这三个数据块是有指定格式的，我们必须按照格式填写，然后将其放到.bin文件前面，最终合成的才是可以直接烧写到SD卡中的文件。</p>
<h2 id="C语言版LED灯"><a href="#C语言版LED灯" class="headerlink" title="C语言版LED灯"></a>C语言版LED灯</h2><p>我们有两部分文件要做：</p>
<ol>
<li>汇编文件：汇编文件只是用来完成C语言环境搭建。（初始化DDR、设置堆栈指针SP等等）</li>
<li>C语言文件：C语言文件就是完成我们的业务层代码的，其实就是我们实际例程要完成的功能。</li>
</ol>
<p> 以STM32F103为例，其启动文件startup_stm32f10x_hd.s这个汇编文件就是完成C语言环境搭建的，当然还有一些其他的处理，比如中断向量表等等。当startup_stm32f10x_hd.s把C语言环境初始化完成以后就会进入C语言环境。</p>
<h3 id="实验程序编写-1"><a href="#实验程序编写-1" class="headerlink" title="实验程序编写"></a>实验程序编写</h3><p>新建VScode工程，工程名字为“ledc”，新建三个文件：start.S、main.c和main.h。其中start.S是汇编文件，main.c和main.h是C语言相关文件。</p>
<p> 在前面创建的start.s中输入如下代码：<br> <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs armasm"> <span class="hljs-meta">.global</span> _start<br><br><span class="hljs-symbol">_start:</span><br>    <br>    <span class="hljs-comment">/* 进入 SVC 模式 */</span><br>    <span class="hljs-keyword">MRS</span> <span class="hljs-built_in">R0</span>, <span class="hljs-keyword">CPSR</span><br>    <span class="hljs-keyword">BIC</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-number">#0x1f</span>  <span class="hljs-comment">/* 将R0 的低五位清零，也就是 cpsr 的 M0-4 */</span><br>    <span class="hljs-keyword">ORR</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R0</span>, <span class="hljs-number">#0x13</span>  <span class="hljs-comment">/* 或0x13 使用 SVC 模式 */</span><br><br>    <span class="hljs-keyword">MSR</span> CPSR, <span class="hljs-built_in">R0</span>  <span class="hljs-comment">/* 将R0 写入到 cpsr 中 */</span><br><br>    <span class="hljs-keyword">LDR</span> <span class="hljs-built_in">SP</span>, <span class="hljs-number">=0x80200000</span>  <span class="hljs-comment">/* 设置栈指针 */</span><br>    <span class="hljs-keyword">B</span> main  <span class="hljs-comment">/* 跳转到main函数 */</span><br></code></pre></td></tr></table></figure><br>这里我们设置处理器运行在SVC模式下。处理器模式的设置是通过修改CPSR(程序状态)寄存器来中M<a href="CPSR%E7%9A%84bit%5B4:0%5D">4:0</a>设置处理器运行模式的。如果要将处理器设置为SVC模式，那么M[4:0]就要等于0X13。  这里先使用MRS读取寄存器值经过修改再再使用指令MSR将修改后的R0重新写入到CPSR中。</p>
<blockquote>
<p><strong>为什么是 SVC 模式</strong></p>
<p>先简单的来分析一下那7种模式：</p>
<ul>
<li><p>中止abt和未定义und模式<br>首先可以排除的是，中止abt和未定义und模式，那都是不太正常的模式，此处程序是正常运行的，所以不应该设置CPU为其中任何一种模式，所以可以排除。</p>
</li>
<li><p>快中断fiq和中断irq模式<br>其次，对于快中断fiq和中断irq来说，此处uboot初始化的时候，也还没啥中断要处理和能够处理，而且即使是注册了终端服务程序后，能够处理中断，那么这两种模式，也是自动切换过去的，所以，此处也不应该设置为其中任何一种模式。</p>
</li>
<li><p>用户usr模式<br>虽然从理论上来说，可以设置CPU为用户usr模式，但是由于此模式无法直接访问很多的硬件资源，而uboot初始化，就必须要去访问这类资源，所以此处可以排除，不能设置为用户usr模式。</p>
</li>
<li><p>系统sys模式 vs 管理svc模式<br>首先，sys模式和usr模式相比，所用的寄存器组，都是一样的，但是增加了一些访问一些在usr模式下不能访问的资源。</p>
<p>而svc模式本身就属于特权模式，本身就可以访问那些受控资源，而且，比sys模式还多了些自己模式下的影子寄存器，所以，相对sys模式来说，可以访问资源的能力相同，但是拥有更多的硬件资源。</p>
<p>所以，从理论上来说，虽然可以设置为sys和svc模式的任一种，但是从uboot方面考虑，其要做的事情是初始化系统相关硬件资源，需要获取尽量多的权限，以方便操作硬件，初始化硬件。</p>
</li>
</ul>
<p>从uboot的目的是初始化硬件的角度来说，设置为svc模式，更有利于其工作。</p>
<p>因此，此处将CPU设置为SVC模式。另外这里设置为 sys 模式，也是可以正常运行的。但不保证后面的例程也可以。</p>
</blockquote>
<p>SP指针&#x3D;0X80200000，因为I.MX6U-ALPHA开发板 上 的DDR3地址范围  是0X80000000<del>0XA0000000(512MB)或者0X80000000</del>0X90000000(256MB)，不管是512MB版本还是256MB版本的，其DDR3起始地址都是0X80000000。由于Cortex-A7的堆栈是向下增长的，所以将SP指针设置为0X80200000，因此SVC模式的栈大小0X80200000-0X80000000&#x3D;0X200000&#x3D;2MB，2MB的栈空间已经很大了，如果做裸机开发的话绰绰有余。</p>
<blockquote>
<p>这里需要将 start.S 和 后面的main.c 看成同一个文件，main 其实就是指代用C写称的main函数，这里.c文件再编译时会转为main函数，并且我们通过 Makefile 使得 start.S 文件在 main.c 文件之前，并合并成一个 <code>.o</code> 文件，这样在 <code>.o</code> 文件中 srat.S 中的内容排在 main.c 内容前面，则系统会先运行 start.S 的内容，然后通过 <code>B main</code> 跳转到main函数，继续执行。</p>
</blockquote>
<p>在main.h里面输入代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">#ifndef __MAIN_H<br>#define __MAIN_H<br><br><span class="hljs-comment">/* CCM 相关寄存器地址 */</span><br>#define CCM_CCGR0 *((<span class="hljs-keyword">volatile</span> unsigned <span class="hljs-type">int</span> *)<span class="hljs-number">0x020C4068</span>)<br>#define CCM_CCGR1 *((<span class="hljs-keyword">volatile</span> unsigned <span class="hljs-type">int</span> *)<span class="hljs-number">0x020C406C</span>)<br>#define CCM_CCGR2 *((<span class="hljs-keyword">volatile</span> unsigned <span class="hljs-type">int</span> *)<span class="hljs-number">0x020C4070</span>)<br>#define CCM_CCGR3 *((<span class="hljs-keyword">volatile</span> unsigned <span class="hljs-type">int</span> *)<span class="hljs-number">0x020C4074</span>)<br>#define CCM_CCGR4 *((<span class="hljs-keyword">volatile</span> unsigned <span class="hljs-type">int</span> *)<span class="hljs-number">0x020C4078</span>)<br>#define CCM_CCGR5 *((<span class="hljs-keyword">volatile</span> unsigned <span class="hljs-type">int</span> *)<span class="hljs-number">0x020C407C</span>)<br>#define CCM_CCGR6 *((<span class="hljs-keyword">volatile</span> unsigned <span class="hljs-type">int</span> *)<span class="hljs-number">0x020C4080</span>)<br><br>#define SW_MUX_GPIO1_IO03 *((<span class="hljs-keyword">volatile</span> unsigned <span class="hljs-type">int</span> *)<span class="hljs-number">0x020E0068</span>)<br>#define SW_PAD_GPIO1_IO03 *((<span class="hljs-keyword">volatile</span> unsigned <span class="hljs-type">int</span> *)<span class="hljs-number">0x020E02F4</span>)<br><br><span class="hljs-comment">/* GPIO1相关寄存器地址 */</span><br>#define GPIO1_DR *((<span class="hljs-keyword">volatile</span> unsigned <span class="hljs-type">int</span> *)<span class="hljs-number">0x0209C000</span>)<br>#define GPIO1_GDIR *((<span class="hljs-keyword">volatile</span> unsigned <span class="hljs-type">int</span> *)<span class="hljs-number">0x0209C004</span>)<br>#define GPIO1_PSR *((<span class="hljs-keyword">volatile</span> unsigned <span class="hljs-type">int</span> *)<span class="hljs-number">0x0209C008</span>)<br>#define GPIO1_ICR1 *((<span class="hljs-keyword">volatile</span> unsigned <span class="hljs-type">int</span> *)<span class="hljs-number">0x0209C00C</span>)<br>#define GPIO1_ICR2 *((<span class="hljs-keyword">volatile</span> unsigned <span class="hljs-type">int</span> *)<span class="hljs-number">0x0209C010</span>)<br>#define GPIO1_IMR *((<span class="hljs-keyword">volatile</span> unsigned <span class="hljs-type">int</span> *)<span class="hljs-number">0x0209C014</span>)<br>#define GPIO1_ISR *((<span class="hljs-keyword">volatile</span> unsigned <span class="hljs-type">int</span> *)<span class="hljs-number">0x0209C018</span>)<br>#define GPIO1_EDGE_SEL *((<span class="hljs-keyword">volatile</span> unsigned <span class="hljs-type">int</span> *)<span class="hljs-number">0x0209C01C</span>)<br><br>#endif<br><br></code></pre></td></tr></table></figure>

<p>在main.c里面输入如下所示代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java">#include <span class="hljs-string">&quot;main.h&quot;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@brief</span> 使能I.MX6U所有外设时钟</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@note</span>  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@retval</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">clk_enable</span><span class="hljs-params">()</span><br>&#123;<br>    CCM_CCGR0 = <span class="hljs-number">0xffffffff</span>;<br>    CCM_CCGR1 = <span class="hljs-number">0xffffffff</span>;<br>    CCM_CCGR2 = <span class="hljs-number">0xffffffff</span>;<br>    CCM_CCGR3 = <span class="hljs-number">0xffffffff</span>;<br>    CCM_CCGR4 = <span class="hljs-number">0xffffffff</span>;<br>    CCM_CCGR5 = <span class="hljs-number">0xffffffff</span>;<br>    CCM_CCGR6 = <span class="hljs-number">0xffffffff</span>;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@brief</span> 初始化LED对应的GPIO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@note</span>  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@retval</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">led_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 1、初始化IO复用,复用为GPIO1_IO03 */</span><br>    SW_MUX_GPIO1_IO03 = <span class="hljs-number">0x5</span>;<br>    <span class="hljs-comment">/* 2、配置GPIO1_IO03的IO属性</span><br><span class="hljs-comment">     *bit 16:0 HYS关闭</span><br><span class="hljs-comment">     *bit [15:14]: 00 默认下拉</span><br><span class="hljs-comment">     *bit [13]: 0 kepper功能 </span><br><span class="hljs-comment">     *bit [12]: 1 pull/keeper使能</span><br><span class="hljs-comment">     *bit [11]: 0 关闭开路输出</span><br><span class="hljs-comment">     *bit [7:6]: 10 速度100Mhz</span><br><span class="hljs-comment">     *bit [5:3]: 110 R0/6驱动能力</span><br><span class="hljs-comment">     *bit [0]: 0 低转换率</span><br><span class="hljs-comment">     */</span><br>    SW_PAD_GPIO1_IO03 = <span class="hljs-number">0x10B0</span>;<br>    <span class="hljs-comment">/* 3、初始化GPIO, GPIO1_IO03设置为输出*/</span><br>    GPIO1_GDIR = <span class="hljs-number">0x00000008</span>;<br>    <span class="hljs-comment">/* 4、设置GPIO1_IO03输出低电平，打开LED0 */</span><br>    GPIO1_DR = <span class="hljs-number">0x0</span>;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@brief</span> 打开LED灯</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@note</span>  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@retval</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">led_on</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span><br>&#123;<br>    GPIO1_DR &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>); <span class="hljs-comment">/* 将GPIO1_DR的bit3清零 */</span><br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@brief</span> 关闭LED灯</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@note</span>  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@retval</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">led_off</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span><br>&#123;<br>    GPIO1_DR |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>); <span class="hljs-comment">/* 将GPIO1_DR的bit3置1 */</span><br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@brief</span> 短时间延时函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@note</span>  n: 要延时循环次数(空操作循环次数，模式延时)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@retval</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">delay_short</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> unsigned <span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(n--)&#123;&#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@brief</span> 延时函数,在396Mhz的主频下延时时间大约为1ms</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@note</span>  n: 要延时的ms数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@retval</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">delay_ms</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> unsigned <span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (n--)<br>    &#123;<br>        delay_short(<span class="hljs-number">0x7ff</span>);<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span><br>&#123;<br>    clk_enable();  <span class="hljs-comment">/* 使能所有的时钟*/</span><br>    led_init();    <span class="hljs-comment">/* 初始化led         */</span><br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        led_off();<br>        delay_ms(<span class="hljs-number">1000</span>);<br><br>        led_on();<br>        delay_ms(<span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="编译下载验证-1"><a href="#编译下载验证-1" class="headerlink" title="编译下载验证"></a>编译下载验证</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">objs:=start.o main.o<br><br>ledc.bin:$(objs)<br>	arm-linux-gnueabihf-ld -Ttext <span class="hljs-number">0X87800000</span> -o ledc.elf $^<br>	arm-linux-gnueabihf-objcopy -O binary -S ledc.elf $@<br>	arm-linux-gnueabihf-objdump -D -m arm ledc.elf &gt; ledc.dis<br><br>%.o:%.s<br>	arm-linux-gnueabihf-gcc -Wall -nostdlib -c  -o $@ $&lt;<br><br>%.o:%.S<br>	arm-linux-gnueabihf-gcc -Wall -nostdlib -c  -o $@ $&lt;<br><br>%.o:%.c<br>	arm-linux-gnueabihf-gcc -Wall -nostdlib -c  -o $@ $&lt;<br><br>clean:<br>	rm -rf *.o ledc.bin ledc.elf ledc.dis<br></code></pre></td></tr></table></figure>

<p>上述的MakefileMakefile要复杂一点了，里面用到了Makefile变量和自动变量。</p>
<p>第1行定义了一个变量objs，objs包含着要生成ledc.bin所需的材料：start.o和main.o，这里要注意start.o一定要放到最前面！因为在后面链接的时候start.o要在最前面，因为start.o是最先要执行的文件！</p>
<p>第3行就是默认目标，目的是生成最终的可执行文件ledc.bin，ledc.bin依赖start.o和main.o如果当前工程没有start.o和main.o的时候就会找到相应的规则去生成start.o和main.o。比如start.o是start.s文件编译生成的，因此会执行第8行的规则。</p>
<p>第4行是使用arm-linux-gnueabihf-ld进行链接，链接起始地址是0X87800000，但是这一行用到了自动变量“$^”，“$^”的意思是所有依赖文件的集合，在这里就是objs这个变量的值：start.o和main.o。链接的时候start.o要链接到最前面，因为第一行代码就是start.o里面的，因此这一行就相当于：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">arm-linux-gnueabihf-ld -Ttext0X87800000 -o ledc<span class="hljs-selector-class">.elf</span> start<span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">main</span>.o<br></code></pre></td></tr></table></figure>
<p>第5行使用arm-linux-gnueabihf-objcopy来将ledc.elf文件转为ledc.bin，本行也用到了自动变量“$@”，“$@”的意思是目标集合，在这里就是“ledc.bin”，那么本行就相当于：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">arm-linux-gnueabihf-objcopy -O <span class="hljs-built_in">binary</span> -S ledc.elf ledc.bin<br></code></pre></td></tr></table></figure>
<p>第6行使用arm-linux-gnueabihf-objdump来反汇编，生成ledc.dis文件。</p>
<p>第8~15行就是针对不同的文件类型将其编译成对应的.o文件，其实就是汇编.s(.S)和.c文件，比如start.s就会使用第8行的规则来生成对应的start.o文件。  </p>
<p>编译完成以后可以使用软件imxdownload将其下载到SD卡中，命令如下：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">chmod777 imxdownload<span class="hljs-regexp">//</span>给予imxdownoad可执行权限，一次即可.<br><span class="hljs-regexp">/imxdownload ledc.bin /</span>dev<span class="hljs-regexp">/sdd/</span><span class="hljs-regexp">/下载到SD卡中</span><br></code></pre></td></tr></table></figure>

<h3 id="链接脚本"><a href="#链接脚本" class="headerlink" title="链接脚本"></a>链接脚本</h3><p>在上面的Makefile中我们链接代码的时候使用如下语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">arm-linux-gnueabihf-ld -Ttext0X87800000 -o ledc.elf $^<br></code></pre></td></tr></table></figure>
<p>上面语句中我们是通过“-Ttext”来指定链接地址是0X87800000的，这样的话所有的文件都会链接到以0X87800000为起始地址的区域。但是有时候我们很多文件需要链接到指定的区域，或者叫做段里面，比如在Linux里面初始化函数就会放到init段里面。因此我们需要能够自定义一些段，这些段的起始地址我们可以自由指定，同样的我们也可以指定一个文件或者函数应该存放到哪个段里面去。要完成这个功能我们就需要使用到链接脚本，用于描述文件应该如何被链接在一起形成最终的可执行文件。</p>
<p>其主要目的是描述输入文件中的段如何被映射到输出文件中，并且控制输出文件中的内存排布。比如我们编译生成的文件一般都包含text段、data段等等。链接脚本的语法很简单，就是编写一系列的命令，这些命令组成了链接脚本，每个命令是一个带有参数的关键字或者一个对符号的赋值，可以使用分号分隔命令。像文件名之类的字符串可以直接键入，也可以使用通配符“*”。最简单的链接脚本可以只包含一个命令“SECTIONS”,我们可以在这一个“SECTIONS”里面来描述输出文件的内存布局。我们一般编译出来的代码都包含在text、data、bss和rodata这四个段内，假设现在的代码要被链接到0X10000000这个地址，数据要被链接到0X30000000这个地方，下面就是完成此功能的最简单的链接脚本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">SECTIONS&#123;<br>	. = <span class="hljs-number">0X10000000</span>;<br>	.text : &#123;*(.text)&#125;<br>	. = <span class="hljs-number">0X30000000</span>;<br>	.data <span class="hljs-title function_">ALIGN</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span> : &#123;*(.data)&#125;<br>	.bss <span class="hljs-title function_">ALIGN</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span> : &#123;*(.bss)&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第1行我们先写了一个关键字“SECTIONS”，后面跟了一个大括号，这个大括号和第7行的大括号是一对，这是必须的。看起来就跟C语言里面的函数一样。<br>第2行对一个特殊符号“.”进行赋值，“.”在链接脚本里面叫做定位计数器，默认的定位计数器为0。我们要求代码链接到以0X10000000为起始地址的地方，因此这一行给“.”赋值0X10000000，表示以0X10000000开始，后面的文件或者段都会以0X10000000为起始地址开始链接。<br>第3行的“.text”是段名，后面的冒号是语法要求，冒号后面的大括号里面可以填上要链接到“.text”这个段里面的所有文件，“*(.text)”中的“*”是通配符，表示所有输入文件的.text段都放到“.text”中。<br>第4行，我们的要求是数据放到0X30000000开始的地方，所以我们需要重新设置定位计数器“.”，将其改为0X30000000。<br>第5行跟第3行一样，定义了一个名为“.data”的段，然后所有文件的“.data”段都放到这里面。ALIGN(4)表示4字节对齐。也就是说段“.data”的起始地址要能被4整除，一般常见的都是ALIGN(4)或者ALIGN(8)，也就是4字节或者8字节对齐。<br>第6行定义了一个“.bss”段，所有文件中的“.bss”数据都会被放到这个里面，“.bss”数据就是那些定义了但是没有被初始化的变量。</p>
<p>我们接下来就按照这个基本的语法格式来编写我们本试验的链接脚本，我们本试验的链接脚本要求如下：</p>
<ul>
<li>链接起始地址为0X87800000</li>
<li>start.o要被链接到最开始的地方，因为start.o里面包含这第一个要执行的命令。</li>
</ul>
<p>根据要求，在Makefile同目录下新建一个名为“imx6ul.lds”的文件，然后在此文件里面输入如下所示代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">SECTIONS&#123;<br>    . = <span class="hljs-number">0X87800000</span>;<br>    .text :<br>    &#123;<br>        start.o<br>        main.o<br>        *(.text)<br>    &#125;<br>    .rodata <span class="hljs-title function_">ALIGN</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span> : &#123;*(.rodata*)&#125;<br>    .data <span class="hljs-title function_">ALIGN</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span> : &#123;*(data*)&#125;<br>    __bss_start = .;<br>    .bss <span class="hljs-title function_">ALIGN</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span> : &#123;*(.bss) *(COMMON)&#125;<br>    __bss_end = .;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第2行设置定位计数器为0X87800000。<br>第5行设置链接到开始位置的文件为start.o，因为start.o里面包含着第一个要执行的指令，所以一定要链接到最开始的地方。<br>第6行是main.o这个文件，其实可以不用写出来，因为main.o的位置就无所谓了，可以由编译器自行决定链接位置。<br>在第11、13行有“__bss_start”和“__bss_end”符号，对这两个符号进行赋值，其值为定位符“.”，这两个符号用来保存.bss段的起始地址和结束地址。前面说了.bss段是定义了但是没有被初始化的变量，我们需要手动对.bss段的变量清零的，因此我们需要知道.bss段的起始和结束地址，这样我们直接对这段内存赋0即可完成清零。通过第11、13行代码，.bss段的起始地址和结束地址就保存在了“__bss_start”和“__bss_end”中，我们就可以直接在汇编或者C文件里面使用这两个符号。</p>
<h4 id="修改Makefile"><a href="#修改Makefile" class="headerlink" title="修改Makefile"></a>修改Makefile</h4><p>将Makefile中的如下一行代码：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">arm-linux-gnueabihf-ld -Ttext0X87800000-o ledc.elf $^<br></code></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">arm-linux-gnueabihf-ld -Timx6ul<span class="hljs-selector-class">.lds</span> -o ledc<span class="hljs-selector-class">.elf</span> $^<br></code></pre></td></tr></table></figure>
<p>其实就是将-T后面的0X87800000改为imx6ul.lds，表示使用imx6ul.lds这个链接脚本文件。修改完成以后使用新的Makefile和链接脚本文件重新编译工程，编译成功以后就可以烧写到SD卡中验证了。</p>
<h3 id="arm-linux-gcc-x2F-ld-x2F-objcopy-x2F-objdump参数总结"><a href="#arm-linux-gcc-x2F-ld-x2F-objcopy-x2F-objdump参数总结" class="headerlink" title="arm-linux-gcc&#x2F;ld&#x2F;objcopy&#x2F;objdump参数总结"></a>arm-linux-gcc&#x2F;ld&#x2F;objcopy&#x2F;objdump参数总结</h3><p><strong>arm-linux-gcc -wall -O2 -c -o $@ $&lt;</strong></p>
<ul>
<li>-o 只激活预处理,编译,和汇编,也就是他只把程序做成obj文件</li>
<li>-Wall 指定产生全部的警告信息</li>
<li>-O2 编译器对程序提供的编译优化选项，在编译的时候使用该选项，可以使生成的执行文件的执行效率提高</li>
<li>-c 表示只要求编译器进行编译，而不要进行链接，生成以源文件的文件名命名但把其后缀由 .c 或 .cc 变成 .o 的目标文件</li>
<li>-S 只激活预处理和编译，就是指把文件编译成为汇编代码</li>
</ul>
<p><strong>arm-linux-ld</strong><br>直接指定代码段,数据段,BSS段的起始地址</p>
<ul>
<li>-Ttest startaddr</li>
<li>-Tdata startaddr</li>
<li>-Tbss startaddr</li>
</ul>
<p>示例:<br><code>Arm-linux-ld –Ttext 0x0000000 –g led.o –o led_elf</code></p>
<p>使用连接脚本设置地址:<br><code>Arm-linux-ld –Ttimer.lds –o timer_elf  $^</code><br>其中timer.lds 为连接脚本，完整的连接脚本格式:  </p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">SECTIONS&#123;<br>	…<br>	Secname start <span class="hljs-built_in">ALING</span>(aling) (NOLOAD):AT(ldaddr)<br>	&#123;contents&#125; &gt; region:phdr=fill<br>	…..<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>arm-linux-objcopy</strong><br>被用来复制一个目标文件的内容到另一个文件中,可用于不同源文件的之间的格式转换<br>示例:<br><code>Arm-linux-objcopy –o binary –S elf_file bin_file</code><br>常用的选项:</p>
<ul>
<li>input-file , outflie</li>
<li>输入和输出文件,如果没有outfile,则输出文件名为输入文件名</li>
<li>2.-l bfdname或—input-target&#x3D;bfdname</li>
<li>用来指明源文件的格式,bfdname是BFD库中描述的标准格式名,如果没指明,则arm-linux-objcopy自己分析</li>
<li>3.-O bfdname 输出的格式</li>
<li>4.-F bfdname 同时指明源文件,目的文件的格式</li>
<li>5.-R sectionname 从输出文件中删除掉所有名为sectionname的段</li>
<li>6.-S 不从源文件中复制重定位信息和符号信息到目标文件中</li>
<li>7.-g 不从源文件中复制调试符号到目标文件中</li>
</ul>
<p><strong>arm-linux-objdump</strong><br>查看目标文件（.o文件）和库文件(.a文件）信息。<br>示例：<br><code>arm-linux-objdump -D -m arm led_elf &gt; led.dis</code><br><strong>相关参数</strong></p>
<ul>
<li>-D 显示文件中所有汇编信息</li>
<li>-m machine</li>
</ul>
<p>指定反汇编目标文件时使用的架构，当待反汇编文件本身没有描述架构信息的时候(比如S-records)，这个选项很有用。可以用-i选项列出这里能够指定的架构.这里例子中指定反汇编得到的目标文件使用ARM架构。</p>
<ul>
<li>-b bfdname 指定目标码格式</li>
<li>-disassemble或者-d 反汇编可执行段</li>
<li>-dissassemble-all或者-D 反汇编所有段</li>
<li>-EB,-EL指定字节序</li>
<li>-file-headers或者-f 显示文件的整体头部摘要信息</li>
<li>-section-headers,–headers或者-h 显示目标文件中各个段的头部摘要信息</li>
<li>-info 或者-I 显示支持的目标文件格式和CPU架构</li>
<li>-section&#x3D;name或者-j name显示指定section 的信息</li>
<li>-architecture&#x3D;machine或者-m machine 指定反汇编目标文件时使用的架构</li>
</ul>
<h3 id="参考链接-5"><a href="#参考链接-5" class="headerlink" title="参考链接"></a>参考链接</h3><p><a target="_blank" rel="noopener" href="https://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/htmls/index.html">Uboot中start.S源码的指令级的详尽解析</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/muyuyuzhong/article/details/7755291">arm-linux-gcc&#x2F;ld&#x2F;objcopy&#x2F;objdump参数总结</a></p>
<h2 id="模仿STM32驱动开发格式实验"><a href="#模仿STM32驱动开发格式实验" class="headerlink" title="模仿STM32驱动开发格式实验"></a>模仿STM32驱动开发格式实验</h2><p>创建VSCode工程，工作区名字为“ledc_stm32”，新建三个文件：start.S、main.c和imx6ul.h。其中start.S是汇编文件，start.S文件的内容和第十章的start.S一样，直接复制过来就可以。main.c 和imx6ul.h是C文件。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * 外设寄存器组的基地址 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CCM_BASE					(0X020C4000)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CCM_ANALOG_BASE				(0X020C8000)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IOMUX_SW_MUX_BASE			(0X020E0014)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IOMUX_SW_PAD_BASE			(0X020E0204)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO1_BASE                  (0x0209C000)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO2_BASE                  (0x020A0000)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO3_BASE                  (0x020A4000)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO4_BASE                  (0x020A8000)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO5_BASE                  (0x020AC000)</span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * CCM寄存器结构体定义，分为CCM和CCM_ANALOG </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <br>&#123;<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> CCR;<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> CCDR;<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> CSR;<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> CCSR;<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">CACRR</span>;<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> CBCDR;<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> CBCMR;<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> CSCMR1;<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> CSCMR2;<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> CSCDR1;<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> CS1CDR;<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> CS2CDR;<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> CDCDR;<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> CHSCCDR;<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> CSCDR2;<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> CSCDR3;	<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> RESERVED_1[<span class="hljs-number">2</span>];<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> CDHIPR;  <br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> RESERVED_2[<span class="hljs-number">2</span>];<br>	<br>	... 此处省略部分代码<br>	<br>	<br>	<span class="hljs-comment">/* </span><br><span class="hljs-comment">	* 外设指针 </span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">define</span> CCM					((CCM_Type *)CCM_BASE)</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">define</span> CCM_ANALOG			((CCM_ANALOG_Type *)CCM_ANALOG_BASE)</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">define</span> IOMUX_SW_MUX		((IOMUX_SW_MUX_Type *)IOMUX_SW_MUX_BASE)</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">define</span> IOMUX_SW_PAD		((IOMUX_SW_PAD_Type *)IOMUX_SW_PAD_BASE)</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO1				((GPIO_Type *)GPIO1_BASE)</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO2				((GPIO_Type *)GPIO2_BASE)</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO3				((GPIO_Type *)GPIO3_BASE)</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO4				((GPIO_Type *)GPIO4_BASE)</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO5				((GPIO_Type *)GPIO5_BASE)</span><br></code></pre></td></tr></table></figure>
<p>在编写寄存器组结构体的时候注意寄存器的地址是否连续，有些外设的寄存器地址可能不是连续的，会有一些保留地址，因此我们需要在结构体中留出这些保留的寄存器。  </p>
<p>比如CCM的CCGR6寄存器地址为0X020C4080，而寄存器CMEOR的地址为0X020C4088。按照地址顺序递增的原理，寄存器CMEOR的地址应该是0X020C4084，但是实际上CMEOR的地址是0X020C4088，相当于中间跳过了0X020C4088-0X020C4080&#x3D;8个字节，如果寄存器地址连续的话应该只差4个字节(32位)，但是现在差了8个字节，所以需要在寄存器CCGR6和CMEOR直接加入一个保留寄存器，这个就是“示例代码”中第47行RESERVED_3[1]的来源。如果不添加保留为来占位的话就会导致寄存器地址错位！</p>
<p>main.c文件中输入如下所示内容：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs zephir">#include <span class="hljs-string">&quot;imx6ul.h&quot;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>	: 使能I.MX6U所有外设时钟</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 		: 无</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 		: 无</span><br><span class="hljs-comment"> */</span><br>void clk_enable(void)<br>&#123;<br>	CCM-&gt;CCGR0 = <span class="hljs-number">0XFFFFFFFF</span>;<br>	CCM-&gt;CCGR1 = <span class="hljs-number">0XFFFFFFFF</span>;<br><br>	CCM-&gt;CCGR2 = <span class="hljs-number">0XFFFFFFFF</span>;<br>	CCM-&gt;CCGR3 = <span class="hljs-number">0XFFFFFFFF</span>;<br>	CCM-&gt;CCGR4 = <span class="hljs-number">0XFFFFFFFF</span>;<br>	CCM-&gt;CCGR5 = <span class="hljs-number">0XFFFFFFFF</span>;<br>	CCM-&gt;CCGR6 = <span class="hljs-number">0XFFFFFFFF</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>	: 初始化LED对应的GPIO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 		: 无</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 		: 无</span><br><span class="hljs-comment"> */</span><br>void led_init(void)<br>&#123;<br>	<span class="hljs-comment">/* 1、初始化IO复用 */</span><br>	IOMUX_SW_MUX-&gt;GPIO1_IO03 = <span class="hljs-number">0X5</span>;		<span class="hljs-comment">/* 复用为GPIO1_IO03 */</span><br><br><br>	<span class="hljs-comment">/* 2、配置GPIO1_IO03的IO属性	</span><br><span class="hljs-comment">	 *bit 16:0 HYS关闭</span><br><span class="hljs-comment">	 *bit [15:14]: 00 默认下拉</span><br><span class="hljs-comment">     *bit [13]: 0 kepper功能</span><br><span class="hljs-comment">     *bit [12]: 1 pull/keeper使能</span><br><span class="hljs-comment">     *bit [11]: 0 关闭开路输出</span><br><span class="hljs-comment">     *bit [7:6]: 10 速度100Mhz</span><br><span class="hljs-comment">     *bit [5:3]: 110 R0/6驱动能力</span><br><span class="hljs-comment">     *bit [0]: 0 低转换率</span><br><span class="hljs-comment">     */</span><br>    IOMUX_SW_PAD-&gt;GPIO1_IO03 = <span class="hljs-number">0X10B0</span>;<br><br><br>	<span class="hljs-comment">/* 3、初始化GPIO */</span><br>	GPIO1-&gt;GDIR = <span class="hljs-number">0X0000008</span>;	<span class="hljs-comment">/* GPIO1_IO03设置为输出 */</span><br><br>	<span class="hljs-comment">/* 4、设置GPIO1_IO03输出低电平，打开LED0 */</span>	<br>	GPIO1-&gt;DR &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);	<br>	<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>	: 打开LED灯</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 		: 无</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 		: 无</span><br><span class="hljs-comment"> */</span><br>void led_on(void)<br>&#123;<br>	<span class="hljs-comment">/* 将GPIO1_DR的bit3清零 	*/</span><br>	GPIO1-&gt;DR &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>); <br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>	: 关闭LED灯</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 		: 无</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 		: 无</span><br><span class="hljs-comment"> */</span><br>void led_off(void)<br>&#123;<br>	<span class="hljs-comment">/* 将GPIO1_DR的bit3置1 */</span><br>	GPIO1-&gt;DR |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>); <br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>	: 短时间延时函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> - n	: 要延时循环次数(空操作循环次数，模式延时)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 		: 无</span><br><span class="hljs-comment"> */</span><br>void delay_short(volatile <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> n)<br>&#123;<br>	<span class="hljs-keyword">while</span>(n--)&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>	: 延时函数,在396Mhz的主频下</span><br><span class="hljs-comment"> * 			  	  延时时间大约为1ms</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> - n	: 要延时的ms数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 		: 无</span><br><span class="hljs-comment"> */</span><br>void delay(volatile <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> n)<br>&#123;<br>	<span class="hljs-keyword">while</span>(n--)<br>	&#123;<br>		delay_short(<span class="hljs-number">0x7ff</span>);<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>	: mian函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 		: 无</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 		: 无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">int</span> main(void)<br>&#123;<br>	clk_enable();		<span class="hljs-comment">/* 使能所有的时钟 			*/</span><br>	led_init();			<span class="hljs-comment">/* 初始化led 			*/</span><br><br>	<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)			<span class="hljs-comment">/* 死循环 				*/</span><br>	&#123;	<br>		led_off();		<span class="hljs-comment">/* 关闭LED 			*/</span><br>		delay(<span class="hljs-number">500</span>);		<span class="hljs-comment">/* 延时500ms 			*/</span><br><br>		led_on();		<span class="hljs-comment">/* 打开LED 			*/</span><br>		delay(<span class="hljs-number">500</span>);		<span class="hljs-comment">/* 延时500ms 			*/</span><br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>main.c中7个函数，这7个函数的含义和前面的main.c文件一样，只是函数体写法变了，寄存器的访问采用imx6ul.h中定义的外设指针。比如第27行设置GPIO1_IO03的复用功能就可以通过“IOMUX_SW_MUX-&gt;GPIO1_IO03”来给寄存SW_MUX_CTL_PAD_GPIO1_IO03赋值。</p>
<h2 id="官方SDK移植实验"><a href="#官方SDK移植实验" class="headerlink" title="官方SDK移植实验"></a>官方SDK移植实验</h2><p>在上一章中，我们参考ST官方给STM32编写的stm32f10x.h来自行编写I.MX6U的寄存器定义文件。自己编写这些寄存器定义不仅费时费力，没有任何意义，而且很容易写错，幸好NXP官方为I.MX6ULL编写了SDK包，在SDK包里面NXP已经编写好了寄存器定义文件，所以我们可以直接移植SDK包里面的文件来用。虽然NXP是为I.MX6ULL编写的SDK包，但是I.MX6UL也是可以使用的！</p>
<h3 id="I-MX6ULL官方SDK包简介"><a href="#I-MX6ULL官方SDK包简介" class="headerlink" title="I.MX6ULL官方SDK包简介"></a>I.MX6ULL官方SDK包简介</h3><p>NXP针对I.MX6ULL编写了一个SDK包，这个SDK包就类似于STM32的STD库或者HAL库，这个SDK包提供了Windows和Linux两种版本，分别针对主机系统是Windows和Linux。因为我们是在Windows下来编写代码的，因此我们使用的是Windows版本的。Windows版本SDK里面的例程提供了IAR版本。</p>
<p>不是所有的半导体厂商都会为Cortex-A架构的芯片编写裸机SDK包，我使用过那么多的Cotex-A系列芯片，也就发现了NXP给I.MX6ULL编写了裸机SDK包。而且去NXP官网看一下，会发现只有I.MX6ULL这一款Cotex-A内核的芯片有裸机SDK包，NXP的其它Cotex-A芯片都没有。说明在NXP的定位里面，I.MX6ULL就是一个Cotex-A内核的高端单片机，定位类似ST的STM32H7。</p>
<p>使用Cortex-A内核芯片的时候不要想着有类似STM32库一样的东西，I.MX6ULL是一个特例，基本所有的Cortex-A内核的芯片都不会提供裸机SDK包。</p>
<p>I.MX6ULL的SDK包在NXP<a target="_blank" rel="noopener" href="https://www.nxp.com/products/processors-and-microcontrollers/arm-processors/i-mx-applications-processors/i-mx-6-processors/i-mx-6ull-single-core-processor-with-arm-cortex-a7-core:i.MX6ULL?tab=Design_Tools_Tab">官网下载</a>，下载界面如图所示<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/I.MX6ULL_SDK%E5%8C%85%E4%B8%8B%E8%BD%BD%E7%95%8C%E9%9D%A2.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>双击SDK_2.2_MCIM6ULL_RFP_Win.exe安装SDK包，安装的时候需要记住安装位置</p>
<p>我们重点是需要SDK包里面与寄存器定义相关的文件，一共需要如下三个文件：</p>
<ul>
<li>fsl_common.h：位置为SDK_2.2_MCIM6ULL\devices\MCIMX6Y2\drivers\fsl_common.h。</li>
<li>fsl_iomuxc.h:位置为SDK_2.2_MCIM6ULL\devices\MCIMX6Y2\drivers\fsl_iomuxc.h。</li>
<li>MCIMX6Y2.h:位置为SDK_2.2_MCIM6ULL\devices\MCIMX6Y2\MCIMX6YH2.h。</li>
</ul>
<p>整个SDK包我们就需要上面这三个文件，把这三个文件准备好，我们后面移植要用。</p>
<h3 id="实验程序编写-2"><a href="#实验程序编写-2" class="headerlink" title="实验程序编写"></a>实验程序编写</h3><h4 id="SDK文件移植"><a href="#SDK文件移植" class="headerlink" title="SDK文件移植"></a>SDK文件移植</h4><p>使用VSCode新建工程，将fsl_common.h、fsl_iomuxc.h和MCIMX6Y2.h这三个文件拷贝到工程中，这三个文件直接编译的话肯定会出错的！需要对其做删减，因为这三个文件里面的代码都比较大，所以就不详细列出这三个文件删减以后的内容了。直接使用原子删减好的文件。</p>
<h4 id="cc-h-文件"><a href="#cc-h-文件" class="headerlink" title="cc.h 文件"></a>cc.h 文件</h4><p>新建一个名为cc.h的头文件，cc.h里面存放一些SDK库文件需要使用到的数据类型，在cc.h里面输入如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __CC_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __CC_H</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 自定义一些数据类型供库文件使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>     __I     volatile </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>     __O     volatile </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>     __IO    volatile</span><br><br><span class="hljs-keyword">typedef</span>   <span class="hljs-type">signed</span>          <span class="hljs-type">char</span> <span class="hljs-type">int8_t</span>;<br><span class="hljs-keyword">typedef</span>   <span class="hljs-type">signed</span> <span class="hljs-type">short</span>     <span class="hljs-type">int</span> <span class="hljs-type">int16_t</span>;<br><span class="hljs-keyword">typedef</span>   <span class="hljs-type">signed</span>           <span class="hljs-type">int</span> <span class="hljs-type">int32_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span>          <span class="hljs-type">char</span> <span class="hljs-type">uint8_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>     <span class="hljs-type">int</span> <span class="hljs-type">uint16_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span>           <span class="hljs-type">int</span> <span class="hljs-type">uint32_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>     <span class="hljs-type">long</span> <span class="hljs-type">uint64_t</span>;<br><span class="hljs-keyword">typedef</span>	  <span class="hljs-type">signed</span> <span class="hljs-type">char</span>  	 	   s8;		<br><span class="hljs-keyword">typedef</span>	  <span class="hljs-type">signed</span> <span class="hljs-type">short</span> 	  <span class="hljs-type">int</span>  s16;<br><span class="hljs-keyword">typedef</span>	  <span class="hljs-type">signed</span> <span class="hljs-type">int</span> 		   s32;<br><span class="hljs-keyword">typedef</span>	  <span class="hljs-type">signed</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> s64;<br><span class="hljs-keyword">typedef</span>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> 		   u8;<br><span class="hljs-keyword">typedef</span>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span>     u16;<br><span class="hljs-keyword">typedef</span>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> 		   u32;<br><span class="hljs-keyword">typedef</span>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> u64;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure>
<p>在cc.h文件中我们定义了很多的数据类型，因为有些第三方库会用到这些变量类型。其实就是有些第三方库包括这个 SDK 使用的数据类型名大多时简写，需要重新定义一下。</p>
<h4 id="编写实验代码"><a href="#编写实验代码" class="headerlink" title="编写实验代码"></a>编写实验代码</h4><p>start.S 和上文一样，直接复制。<br>main.c 如下：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs zephir">#include <span class="hljs-string">&quot;fsl_common.h&quot;</span><br>#include <span class="hljs-string">&quot;fsl_iomuxc.h&quot;</span><br>#include <span class="hljs-string">&quot;MCIMX6Y2.h&quot;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>	: 使能I.MX6U所有外设时钟</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 		: 无</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 		: 无</span><br><span class="hljs-comment"> */</span><br>void clk_enable(void)<br>&#123;<br>	CCM-&gt;CCGR0 = <span class="hljs-number">0XFFFFFFFF</span>;<br>	CCM-&gt;CCGR1 = <span class="hljs-number">0XFFFFFFFF</span>;<br><br>	CCM-&gt;CCGR2 = <span class="hljs-number">0XFFFFFFFF</span>;<br>	CCM-&gt;CCGR3 = <span class="hljs-number">0XFFFFFFFF</span>;<br>	CCM-&gt;CCGR4 = <span class="hljs-number">0XFFFFFFFF</span>;<br>	CCM-&gt;CCGR5 = <span class="hljs-number">0XFFFFFFFF</span>;<br>	CCM-&gt;CCGR6 = <span class="hljs-number">0XFFFFFFFF</span>;<br><br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>	: 初始化LED对应的GPIO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 		: 无</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 		: 无</span><br><span class="hljs-comment"> */</span><br>void led_init(void)<br>&#123;<br>	<span class="hljs-comment">/* 1、初始化IO复用 */</span><br>	IOMUXC_SetPinMux(IOMUXC_GPIO1_IO03_GPIO1_IO03,<span class="hljs-number">0</span>);		<span class="hljs-comment">/* 复用为GPIO1_IO0 */</span><br><br>	<span class="hljs-comment">/* 2、、配置GPIO1_IO03的IO属性	</span><br><span class="hljs-comment">	 *bit 16:0 HYS关闭</span><br><span class="hljs-comment">	 *bit [15:14]: 00 默认下拉</span><br><span class="hljs-comment">     *bit [13]: 0 kepper功能</span><br><span class="hljs-comment">     *bit [12]: 1 pull/keeper使能</span><br><span class="hljs-comment">     *bit [11]: 0 关闭开路输出</span><br><span class="hljs-comment">     *bit [7:6]: 10 速度100Mhz</span><br><span class="hljs-comment">     *bit [5:3]: 110 R0/6驱动能力</span><br><span class="hljs-comment">     *bit [0]: 0 低转换率</span><br><span class="hljs-comment">     */</span><br>	IOMUXC_SetPinConfig(IOMUXC_GPIO1_IO03_GPIO1_IO03,<span class="hljs-number">0X10B0</span>);<br><br>	<span class="hljs-comment">/* 3、初始化GPIO,设置GPIO1_IO03设置为输出  */</span><br>	GPIO1-&gt;GDIR |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);	<br>	<br>	<span class="hljs-comment">/* 4、设置GPIO1_IO03输出低电平，打开LED0 */</span><br>	GPIO1-&gt;DR &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);			<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>	: 打开LED灯</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 		: 无</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 		: 无</span><br><span class="hljs-comment"> */</span><br>void led_on(void)<br>&#123;<br>	<span class="hljs-comment">/* 将GPIO1_DR的bit3清零 	*/</span><br>	GPIO1-&gt;DR &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>); <br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>	: 关闭LED灯</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 		: 无</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 		: 无</span><br><span class="hljs-comment"> */</span><br>void led_off(void)<br>&#123;<br>	<span class="hljs-comment">/* 将GPIO1_DR的bit3置1 */</span><br>	GPIO1-&gt;DR |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>); <br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>	: 短时间延时函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> - n	: 要延时循环次数(空操作循环次数，模式延时)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 		: 无</span><br><span class="hljs-comment"> */</span><br>void delay_short(volatile <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> n)<br>&#123;<br>	<span class="hljs-keyword">while</span>(n--)&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>	: 延时函数,在396Mhz的主频下</span><br><span class="hljs-comment"> * 			  	  延时时间大约为1ms</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> - n	: 要延时的ms数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 		: 无</span><br><span class="hljs-comment"> */</span><br>void delay(volatile <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> n)<br>&#123;<br>	<span class="hljs-keyword">while</span>(n--)<br>	&#123;<br>		delay_short(<span class="hljs-number">0x7ff</span>);<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>	: mian函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 		: 无</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 		: 无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">int</span> main(void)<br>&#123;<br>	clk_enable();		<span class="hljs-comment">/* 使能所有的时钟 			*/</span><br>	led_init();			<span class="hljs-comment">/* 初始化led 			*/</span><br><br>	<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)			<span class="hljs-comment">/* 死循环 				*/</span><br>	&#123;	<br>		led_off();		<span class="hljs-comment">/* 关闭LED 			*/</span><br>		delay(<span class="hljs-number">500</span>);		<span class="hljs-comment">/* 延时500ms 			*/</span><br><br>		led_on();		<span class="hljs-comment">/* 打开LED 			*/</span><br>		delay(<span class="hljs-number">500</span>);		<span class="hljs-comment">/* 延时500ms 			*/</span><br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里仅在 <code>led_init(void)</code>中使用了两个 SDK 函数</p>
<ul>
<li>IOMUXC_SetPinMux</li>
<li>IOMUXC_SetPinConfig</li>
</ul>
<p>其 中 函 数IOMUXC_SetPinMux是 用 来 设 置IO复 用 功 能 的 ， 最 终 肯 定 设 置 的 是 寄 存 器“IOMUXC_SW_MUX_CTL_PAD_XX”。<br>函数IOMUXC_SetPinConfig设置的是IO的上下拉、速度等的，也就是寄存器“IOMUXC_SW_PAD_CTL_PAD_XX”，所以上面两个函数其实就是上一章中的：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">IOMUX_SW_MUX-&gt;GPIO1_IO03 <span class="hljs-operator">=</span> <span class="hljs-number">0</span>X5<span class="hljs-comment">;</span><br>IOMUX_SW_PAD-&gt;GPIO1_IO03 <span class="hljs-operator">=</span> <span class="hljs-number">0</span>X10B0<span class="hljs-comment">;`</span><br></code></pre></td></tr></table></figure>

<p>其余部分则是使用的 SDK 内部寄存器定义，替代前面我们自己写的寄存器定义。</p>
<h4 id="编译下载验证-2"><a href="#编译下载验证-2" class="headerlink" title="编译下载验证"></a>编译下载验证</h4><p>Makefile文件内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CROSS_COMPILE ?= arm-linux-gnueabihf-<br>NAME		  ?= ledc<br><br>CC 		:= <span class="hljs-variable">$(CROSS_COMPILE)</span>gcc<br>LD		:= <span class="hljs-variable">$(CROSS_COMPILE)</span>ld<br>OBJCOPY := <span class="hljs-variable">$(CROSS_COMPILE)</span>objcopy<br>OBJDUMP := <span class="hljs-variable">$(CROSS_COMPILE)</span>objdump<br><br>OBJS 	:= start.o main.o<br><br><span class="hljs-variable">$(NAME)</span>.bin:<span class="hljs-variable">$(OBJS)</span><br>	<span class="hljs-variable">$(LD)</span> -Timx6ul.lds -o <span class="hljs-variable">$(NAME)</span>.elf <span class="hljs-variable">$^</span><br>	<span class="hljs-variable">$(OBJCOPY)</span> -O binary -S <span class="hljs-variable">$(NAME)</span>.elf <span class="hljs-variable">$@</span><br>	<span class="hljs-variable">$(OBJDUMP)</span> -D -m arm <span class="hljs-variable">$(NAME)</span>.elf &gt; <span class="hljs-variable">$(NAME)</span>.dis<br><br><span class="hljs-section">%.o:%.s</span><br>	<span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br>	<br><span class="hljs-section">%.o:%.S</span><br>	<span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br>	<br><span class="hljs-section">%.o:%.c</span><br>	<span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2 -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br>	<br><span class="hljs-section">clean:</span><br>	rm -rf *.o <span class="hljs-variable">$(NAME)</span>.bin <span class="hljs-variable">$(NAME)</span>.elf <span class="hljs-variable">$(NAME)</span>.dis<br></code></pre></td></tr></table></figure>

<p>Makefile文件是在前面的Makefile上修改的，只是使用到了变量替代一些文本，更懒了。。。效果实际是一样的。链接脚本imx6ul.lds的内容和前面一样，直接使用。</p>
<h2 id="BSP工程管理实验"><a href="#BSP工程管理实验" class="headerlink" title="BSP工程管理实验"></a>BSP工程管理实验</h2><p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1607522806467.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>嵌入式硬件工程师主要职责是负责设计嵌入式系统的硬件原理图，使用相应的工具画出PCB图，后期配合嵌入式软件工程师调试系统。<br>嵌入式软件工程师从系统软件上又可以分为两种：</p>
<ul>
<li>BSP工程师</li>
<li>嵌入式应用软件工程师。</li>
</ul>
<p>嵌入式应用软件工程师主要是负责编写基于嵌入式系统的应用软件。类似于基于windows上的QQ， word。</p>
<p>BSP工程师，顾名思义就是负责板级支持包的开发、调试和维护工作。那么什么是板级支持包呢？前面我们讲过，嵌入式硬件工程师负责设计硬件，画出PCB图，工厂会根据PCB图生产出对应的电路板。一个嵌入式系统光有电路板是不够的，还要有对应的软件支持，软件开发的前提是首先使板子正常稳定的工作，然后再在其上编写对应的应用软件以实现其特有的功能。其中使板子正常稳定的工作的代码就属于板级支持包。 那么BSP工程师的具体工作有哪些呢？</p>
<p>对于不跑操作系统的设备来讲，其功能相对简单一点，使用的主控芯片一般也比较简单，比如风靡一时的51系列单片机、stm系列的单片机。对于这些简单系统来讲，它对软件开发人员要求相对比较低，当然也就没有我前面所说的分工那么详细，有时候甚至从画板、点亮、开发都是由一个人来完成的。对于跑操作系统来讲的设备，就不一样了。一般来讲，跑操作系统的设备其软件开发分三个阶段：</p>
<ol>
<li><p>点亮板子<br>第一批板子出厂时是不包含任何软件的。BSP工程师需要结合硬件原理图修改从芯片厂商拿到的参考代码，调试板子，使板子上的操作系统能够正常稳定工作，从而提供一个稳定的开发调试环境，这个过程叫做点亮板子，行话叫做Bringup。这属于BSP工程师最具有价值含量的工作之一，因为它对BSP工程师所掌握的知识的广度和深度都有一定要求。其中会涉及到计算机原理、操作系统，处理器架构等，还包括硬件方面的一些知识。综合起来其最核心的工作就是对内核的移植、裁剪。</p>
</li>
<li><p>使能板子上所有设备<br>上个阶段中，板子的CPU和基本的器件已经能正常工作，这个阶段中将使能所有的外设，并为后面要开发的应用程序提供对应的软件控制接口。这个过程的实质是对应的操作系统下驱动开发的过程，需要掌握硬件工作的原理，操作系统的相关知识。</p>
</li>
<li><p>为板子开发应用程序<br>如前文所述，嵌入式系统是一个具有专一功能的系统，其上所有的硬件，软件都应该为这一功能服务。第二个阶段结束的时候，板子上所有的设备都已经可以正常使用了。这个阶段的任务就是开发应用程序来实现某种特定的功能，应用程序中会使用第二阶段提供的软件接口控制板子上的设备来完成这一功能。</p>
</li>
</ol>
<p>上述前两个阶段属于BSP开发的内容，第三个阶段属于嵌入式应用软件开发的过程。综上所述，BSP工程师主要应该具备的能力主要有：</p>
<ul>
<li>掌握计算机原理方面的知识；</li>
<li>掌握操作系统的相关知识，深入研究某种操作系统，目前来讲，研究linux操作系统应该是大部分人的选择；</li>
<li>精湛的C语言功底和一定的C++&#x2F;汇编的知识。</li>
<li>掌握一定的硬件和电路原理方面的知识；</li>
<li>熟悉常见的接口协议，如I2C, SPI, UART, USB等。</li>
</ul>
<blockquote>
<p>我的理解：BSP 其实就是底层驱动开发，写些程序能够控制芯片以及外设、并准备发操作系统运行环境，然后留出 API 接口供后面的软件开发人员使用。而软件开发人员是不需要关心底层硬件的。简单来世就是链接硬件和软件的桥梁。所以就需要既懂硬件（驱动开发）也懂软件（API接口）。</p>
</blockquote>
<p>标题的 BSP 工程管理，其实就是将所有编写的底层驱动程序归类整理到一个文件夹，对程序分功能管理。不至于混乱。</p>
<p>新建名为“5_ledc_bsp”的文件夹，在里面新建bsp、imx6ul、obj和project这4个文件夹</p>
<ul>
<li>bsp用来存放驱动文件</li>
<li>imx6ul用来存放跟芯片有关的文件，比如NXP官方的SDK库文件；</li>
<li>obj用来存放编译生成的.o文件；</li>
<li>project存放start.S和main.c文件，也就是应用文件；</li>
</ul>
<p>将cc.h、fsl_common.h、fsl_iomuxc.h和MCIMX6Y2.h这四个文件拷贝到文件夹imx6ul中；<br>将start.S和main.c这两个文件拷贝到文件夹project中。</p>
<p>我们前面的实验中所有的驱动相关的函数都写到了main.c文件中，比如函数clk_enable、led_init和delay，这三个函数可以分为三类：</p>
<ul>
<li>时钟驱动、</li>
<li>LED驱动</li>
<li>延时驱动。</li>
</ul>
<p>因此我们可以在bsp文件夹下创建三个子文件夹：clk、delay和led，分别用来存放时钟驱动文件、延时驱动文件和LED驱动文件，这样main.c函数就会清爽很多，程序功能模块清晰。工程文件夹都创建好了，接下来就是将时钟驱动、LED驱动和延时驱动相关的函数从main.c中提取出来做成一个独立的驱动文件。</p>
<h3 id="实验程序编写-3"><a href="#实验程序编写-3" class="headerlink" title="实验程序编写"></a>实验程序编写</h3><p>新建文件imx6ul.h，然后保存到文件夹imx6ul中，就是引用了一些头文件，以后我们就可以在其他文件中需要引用imx6ul.h就可以了。</p>
<p>编写led驱动代码</p>
<p>编写时钟驱动代码</p>
<p>编写延时驱动代码</p>
<p>修改main.c文件</p>
<p>编写Makefile和链接脚本</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CROSS_COMPILE 	?= arm-linux-gnueabihf-<br>TARGET		  	?= bsp<br><br>CC 				:= <span class="hljs-variable">$(CROSS_COMPILE)</span>gcc<br>LD				:= <span class="hljs-variable">$(CROSS_COMPILE)</span>ld<br>OBJCOPY 		:= <span class="hljs-variable">$(CROSS_COMPILE)</span>objcopy<br>OBJDUMP 		:= <span class="hljs-variable">$(CROSS_COMPILE)</span>objdump<br><br>INCDIRS 		:= imx6ul \<br>				   bsp/clk \<br>				   bsp/led \<br>				   bsp/delay <br>				   			   <br>SRCDIRS			:= project \<br>				   bsp/clk \<br>				   bsp/led \<br>				   bsp/delay <br>				   <br>				   <br>INCLUDE			:= <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, -I %, <span class="hljs-variable">$(INCDIRS)</span>)</span><br><br>SFILES			:= <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>, <span class="hljs-variable">$(SRCDIRS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.S)</span>)<br>CFILES			:= <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>, <span class="hljs-variable">$(SRCDIRS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.c)</span>)<br><br>SFILENDIR		:= <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span>  <span class="hljs-variable">$(SFILES)</span>)</span><br>CFILENDIR		:= <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span>  <span class="hljs-variable">$(CFILES)</span>)</span><br><br>SOBJS			:= <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, obj/%, $(SFILENDIR:.S=.o)</span>)<br>COBJS			:= <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, obj/%, $(CFILENDIR:.c=.o)</span>)<br>OBJS			:= <span class="hljs-variable">$(SOBJS)</span> <span class="hljs-variable">$(COBJS)</span><br><br>VPATH			:= <span class="hljs-variable">$(SRCDIRS)</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br>	<br><span class="hljs-variable">$(TARGET)</span>.bin : <span class="hljs-variable">$(OBJS)</span><br>	<span class="hljs-variable">$(LD)</span> -Timx6ul.lds -o <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$^</span><br>	<span class="hljs-variable">$(OBJCOPY)</span> -O binary -S <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$@</span><br>	<span class="hljs-variable">$(OBJDUMP)</span> -D -m arm <span class="hljs-variable">$(TARGET)</span>.elf &gt; <span class="hljs-variable">$(TARGET)</span>.dis<br><br><span class="hljs-variable">$(SOBJS)</span> : obj/%.o : %.S<br>	<span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2  <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-variable">$(COBJS)</span> : obj/%.o : %.c<br>	<span class="hljs-variable">$(CC)</span> -Wall -nostdlib -c -O2  <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br>	<br><span class="hljs-section">clean:</span><br>	rm -rf <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$(TARGET)</span>.dis <span class="hljs-variable">$(TARGET)</span>.bin <span class="hljs-variable">$(COBJS)</span> <span class="hljs-variable">$(SOBJS)</span><br><br></code></pre></td></tr></table></figure>

<p>该Makefile代码是一个通用Makefile，我们以后所有的裸机例程都使用这个Makefile。使用时候只要将所需要编译的源文件所在的目录添加到Makefile中即可。</p>
<p>我们接下来详细分析一下Makefile源码：</p>
<ul>
<li>第1~7行定义了一些变量，除了第2行以外其它的都是跟编译器有关的，如果使用其它编译器的话只需要修改第1行即可。</li>
<li>第2行的变量TARGET目标名字，不同的例程肯定名字不一一样。</li>
<li>第9行的变量INCDIRS包含整个工程的.h头文件目录，文件中的所有头文件目录都要添加到变量INCDIRS中。比如本例程中包含.h头文件的目录有imx6ul、bsp&#x2F;clk、bsp&#x2F;delay和bsp&#x2F;led，所以就需要在变量INCDIRS中添加这些目录，即: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">INCDIRS := imx6ul bsp/clk bsp/led bsp/delay<br></code></pre></td></tr></table></figure>
符号“\”，相当于“换行符”，表示本行和下一行属于同一行，一般一行写不下的时候就用符号“\”来换行。<br>在后面的裸机例程中我们会根据实际情况来在变量INCDIRS中添加头文件目录。</li>
<li>第14行是变量SRCDIRS，和变量INCDIRS一样，只是SRCDIRS包含的是整个工程的所有.c和.S文件目录。比如本例程包含有.c和.S的目录有bsp&#x2F;clk、bsp&#x2F;delay、bsp&#x2F;led和project，即：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">SRCDIRS := projectbsp/clk bsp/led bsp/delay<br></code></pre></td></tr></table></figure>
同样的，后面的裸机例程中我们也要根据实际情况在变量SRCDIRS中添加相应的文件目录。</li>
<li>第19行的变量INCLUDE是用到了函数patsubst，通过函数patsubst给变量INCDIRS添加一个“-I”，即： <figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">INCLUDE</span> <span class="hljs-operator">:=</span> <span class="hljs-operator">-</span><span class="hljs-built_in">I</span> <span class="hljs-variable">imx6ul</span> <span class="hljs-operator">-</span><span class="hljs-built_in">I</span> <span class="hljs-variable">bsp</span><span class="hljs-operator">/</span><span class="hljs-variable">clk</span> <span class="hljs-operator">-</span><span class="hljs-built_in">I</span> <span class="hljs-variable">bsp</span><span class="hljs-operator">/</span><span class="hljs-variable">led</span> <span class="hljs-operator">-</span><span class="hljs-built_in">I</span> <span class="hljs-variable">bsp</span><span class="hljs-operator">/</span><span class="hljs-variable">delay</span><br></code></pre></td></tr></table></figure>
加“-I”的目的是因为Makefile语法要求指明头文件目录的时候需要加上“-I”。</li>
<li>第21行变量SFILES保存工程中所有的.s汇编文件(包含绝对路径)，变量SRCDIRS已经存放了工程中所有的.c和.S文件，所以我们只需要从里面挑出所有的.S汇编文件即可，这里借助了函数foreach和函数wildcard，最终SFILES如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">SFILES := project/start.S<br></code></pre></td></tr></table></figure></li>
<li>第22行变量CFILES和变量SFILES一样，只是CFILES保存工程中所有的.c文件(包含绝对路径)，最终CFILES如下：<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">CFILES = <span class="hljs-keyword">project</span><span class="hljs-regexp">/main.c bsp/</span>clk<span class="hljs-regexp">/bsp_clk.c bsp/</span>led<span class="hljs-regexp">/bsp_led.c bsp/</span>delay/bsp_delay.c<br></code></pre></td></tr></table></figure></li>
<li>第24和25行的变量SFILENDIR和CFILENDIR包含所有的.S汇编文件和.c文件，相比变量SFILES和CFILES，SFILENDIR和CFILNDIR只是文件名，不包含文件的绝对路径。使用函数notdir将SFILES和CFILES中的路径去掉即可，SFILENDIR和CFILENDIR如下：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">SFILENDIR = start<span class="hljs-selector-class">.S</span><br>CFILENDIR = <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> bsp_clk<span class="hljs-selector-class">.c</span> bsp_led<span class="hljs-selector-class">.c</span> bsp_delay.c<br></code></pre></td></tr></table></figure></li>
<li>第27和28行的变量SOBJS和COBJS是.S和.c文件编译以后对应的.o文件目录，默认所有的文件编译出来的.o文件和源文件在同一个目录中，这里我们将所有的.o文件都放到obj文件夹下，SOBJS和COBJS内容如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">SOBJS = obj/start.o<br>COBJS = obj/main.o obj/bsp_clk.o obj/bsp_led.o obj/bsp_delay.o<br></code></pre></td></tr></table></figure></li>
<li>第29行变量OBJS是变量SOBJS和COBJS的集合，如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">OBJS = obj/start.o obj/main.o obj/bsp_clk.o obj/bsp_led.o obj/bsp_delay.o<br></code></pre></td></tr></table></figure></li>
<li>第31行的VPATH是指定搜索目录的，这里指定的搜素目录就是变量SRCDIRS所保存的目录，这样当编译的时候所需的.S和.c文件就会在SRCDIRS中指定的目录中查找。</li>
<li>第33行指定了一个伪目标clean，伪目标前面讲解Makefile的时候已经讲解过了。</li>
<li>第35~47行就很熟悉了，</li>
</ul>
<p>的Makefile文件内容重点工作是找到要编译哪些文件？编译的.o文件存放到哪里？使用到的编译命令和前面实验使用的一样，其实Makefile的重点工作就是解决“从哪里来到哪里去的”问题，也就是找到要编译的源文件、编译结果存放到哪里？真正的编译命令很简洁。</p>
<p>链接脚本imx6ul.lds的内容基本和上一章一样，主要是start.o文件路径不同，且删除了main.o 路径</p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs roboconf">SECTIONS&#123;<br>	. = 0<span class="hljs-attribute">X87800000;</span><br><span class="hljs-attribute">	.text</span> :<br>	&#123;<br>		obj/start<span class="hljs-variable">.o</span> <br>		*(<span class="hljs-variable">.text</span>)<br>	&#125;<br>	<span class="hljs-variable">.rodata</span> ALIGN(4) : &#123;*(<span class="hljs-variable">.rodata</span>*)&#125;     <br>	<span class="hljs-variable">.data</span> ALIGN(4)   : &#123; *(<span class="hljs-variable">.data</span>) &#125;    <br>	__bss_start = .;    <br>	.<span class="hljs-attribute">bss ALIGN(4)</span>  : &#123; *(<span class="hljs-variable">.bss</span>)  *(COMMON) &#125;    <br>	__bss_end = .;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="编译下载"><a href="#编译下载" class="headerlink" title="编译下载"></a>编译下载</h3><p>这里下载遇到了问题，sd卡插入，能够识别，使用命令下载也正常。但是接到板子，程序并不能读取运行。尝试了弹出sd卡再下载，都不行。最后重启了 Ubuntu 问题解决了。<br>其实这个问题在第一个例程下载时有说过。</p>
<h2 id="蜂鸣器实验"><a href="#蜂鸣器实验" class="headerlink" title="蜂鸣器实验"></a>蜂鸣器实验</h2><h3 id="硬件原理分析"><a href="#硬件原理分析" class="headerlink" title="硬件原理分析"></a>硬件原理分析</h3><p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1607528528485.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>当SNVS_TAMPER1输出低电平的时候Q1导通，相当于蜂鸣器的正极连接到DCDC_3V3，蜂鸣器形成一个通路，因此蜂鸣器会鸣叫。同理，当SNVS_TAMPER1输出高电平的时候Q2不导通，那么蜂鸣器就没有形成一个通路，因此蜂鸣器也就不会鸣叫。</p>
<h3 id="试验程序编写"><a href="#试验程序编写" class="headerlink" title="试验程序编写"></a>试验程序编写</h3><p>新建文件夹“6_beep”，然后将上一章试验中的所有内容拷贝到刚刚新建的“6_beep”里面。</p>
<p>新建VSCode工程，工程创建完成以后在bsp文件夹下新建名为“beep”的文件夹，蜂鸣器驱动文件都放到“beep”文件夹里面。新建bsp_beep.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __BSP_BEEP_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __BSP_BEEP_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;imx6ul.h&quot;</span></span><br><br><br><span class="hljs-comment">/* 函数声明 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">beep_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">beep_switch</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br></code></pre></td></tr></table></figure>
<p>新建文件bsp_beep.c</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs zephir">#include <span class="hljs-string">&quot;bsp_beep.h&quot;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>	: 初始化蜂鸣器对应的IO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 		: 无</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 		: 无</span><br><span class="hljs-comment"> */</span><br>void beep_init(void)<br>&#123;<br>	<span class="hljs-comment">/* 1、初始化IO复用，复用为GPIO5_IO01 */</span><br>	IOMUXC_SetPinMux(IOMUXC_SNVS_SNVS_TAMPER1_GPIO5_IO01,<span class="hljs-number">0</span>);		<br>	<br>	<br>	<span class="hljs-comment">/* 2、、配置GPIO1_IO03的IO属性	</span><br><span class="hljs-comment">	 *bit 16:0 HYS关闭</span><br><span class="hljs-comment">	 *bit [15:14]: 00 默认下拉</span><br><span class="hljs-comment">	 *bit [13]: 0 kepper功能</span><br><span class="hljs-comment">	 *bit [12]: 1 pull/keeper使能</span><br><span class="hljs-comment">	 *bit [11]: 0 关闭开路输出</span><br><span class="hljs-comment">	 *bit [7:6]: 10 速度100Mhz</span><br><span class="hljs-comment">	 *bit [5:3]: 110 R0/6驱动能力</span><br><span class="hljs-comment">	 *bit [0]: 0 低转换率</span><br><span class="hljs-comment">	 */</span><br>	IOMUXC_SetPinConfig(IOMUXC_SNVS_SNVS_TAMPER1_GPIO5_IO01,<span class="hljs-number">0X10B0</span>);<br>	<br>	<span class="hljs-comment">/* 3、初始化GPIO,GPIO5_IO01设置为输出 */</span><br>	GPIO5-&gt;GDIR |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>);	 <br><br>	<span class="hljs-comment">/* 4、设置GPIO5_IO01输出高电平，关闭蜂鸣器 */</span><br>	GPIO5-&gt;DR |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>);		<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>		: 蜂鸣器控制函数，控制蜂鸣器打开还是关闭</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> - status	: 0，关闭蜂鸣器，1 打开蜂鸣器</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 			: 无</span><br><span class="hljs-comment"> */</span><br>void beep_switch(<span class="hljs-keyword">int</span> status)<br>&#123;	<br>	<span class="hljs-keyword">if</span>(status == ON)<br>		GPIO5-&gt;DR &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>);	<span class="hljs-comment">/* 打开蜂鸣器 */</span><br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(status == OFF)<br>		GPIO5-&gt;DR |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>);	<span class="hljs-comment">/* 关闭蜂鸣器 */</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>beep.c文件一共有两个函数：beep_init和beep_switch，其中beep_init用来初始化BEEP所使用的GPIO，也就是SNVS_TAMPER1，将其复用为GPIO5_IO01，和上一章的LED灯初始化函数一样。beep_switch函数用来控制BEEP的开关，也就是设置GPIO5_IO01的高低电平。</p>
<h3 id="编写Makefile和链接脚本"><a href="#编写Makefile和链接脚本" class="headerlink" title="编写Makefile和链接脚本"></a>编写Makefile和链接脚本</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CROSS_COMPILE 	?= arm-linux-gnueabihf-<br>TARGET		  	?= beep<br><br>CC 				:= <span class="hljs-variable">$(CROSS_COMPILE)</span>gcc<br>LD				:= <span class="hljs-variable">$(CROSS_COMPILE)</span>ld<br>OBJCOPY 		:= <span class="hljs-variable">$(CROSS_COMPILE)</span>objcopy<br>OBJDUMP 		:= <span class="hljs-variable">$(CROSS_COMPILE)</span>objdump<br><br>INCDIRS 		:= imx6ul \<br>				   bsp/clk \<br>				   bsp/led \<br>				   bsp/delay  \<br>				   bsp/beep<br>				   			   <br>SRCDIRS			:= project \<br>				   bsp/clk \<br>				   bsp/led \<br>				   bsp/delay \<br>				   bsp/beep<br>				   <br>				   <br>INCLUDE			:= <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, -I %, <span class="hljs-variable">$(INCDIRS)</span>)</span><br><br>SFILES			:= <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>, <span class="hljs-variable">$(SRCDIRS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.S)</span>)<br>CFILES			:= <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>, <span class="hljs-variable">$(SRCDIRS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.c)</span>)<br><br>SFILENDIR		:= <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span>  <span class="hljs-variable">$(SFILES)</span>)</span><br>CFILENDIR		:= <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span>  <span class="hljs-variable">$(CFILES)</span>)</span><br><br>SOBJS			:= <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, obj/%, $(SFILENDIR:.S=.o)</span>)<br>COBJS			:= <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %, obj/%, $(CFILENDIR:.c=.o)</span>)<br>OBJS			:= <span class="hljs-variable">$(SOBJS)</span> <span class="hljs-variable">$(COBJS)</span><br><br>VPATH			:= <span class="hljs-variable">$(SRCDIRS)</span><br><br>/* 省略部分代码 */<br>	<br><span class="hljs-section">clean:</span><br>	rm -rf <span class="hljs-variable">$(TARGET)</span>.elf <span class="hljs-variable">$(TARGET)</span>.dis <span class="hljs-variable">$(TARGET)</span>.bin <span class="hljs-variable">$(COBJS)</span> <span class="hljs-variable">$(SOBJS)</span><br></code></pre></td></tr></table></figure>
<ul>
<li>第2行修改目标的名称为“beep”。</li>
<li>第10行在变量INCDIRS中添加蜂鸣器驱动头文件路径，也就是文件beep.h的路径。</li>
<li>第16行在变量SRCDIRS中添加蜂鸣器驱动文件路劲，也就是文件beep.c的路径。</li>
</ul>
<p> 链接脚本就使用之前的链接脚本文件imx6ul.lds即可。</p>
<h2 id="按键输入实验"><a href="#按键输入实验" class="headerlink" title="按键输入实验"></a>按键输入实验</h2><p>本试验我们用到的硬件有：</p>
<ul>
<li>LED灯LED0。</li>
<li>蜂鸣器。</li>
<li>1个按键KEY0。</li>
</ul>
<p> 按键KEY0的原理图如图15.2.1所示</p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1607612224969.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<h3 id="实验程序编写-4"><a href="#实验程序编写-4" class="headerlink" title="实验程序编写"></a>实验程序编写</h3><p>重新创建VSCode工程，工作区名字为“key”，在工程目录的bsp文件夹中创建名为“key”和“gpio”两个文件夹。按键相关的驱动文件都放到“key”文件夹中，本章试验我们对GPIO的操作编写一个函数集合，也就是编写一个GPIO驱动文件，GPIO的驱动文件放到“gpio”文件夹里面。新建bsp_gpio.c和bsp_gpio.h这两个文件，将这两个文件都保存到刚刚创建的bsp&#x2F;gpio文件夹里面，然后在bsp_gpio.h文件夹里面输入如下内容：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _BSP_GPIO_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _BSP_GPIO_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _BSP_KEY_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;imx6ul.h&quot;</span></span><br><br><span class="hljs-comment">/* 枚举类型和结构体定义 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">_gpio_pin_direction</span><br>&#123;<br>    kGPIO_DigitalInput = <span class="hljs-number">0U</span>,  		<span class="hljs-comment">/* 输入 */</span><br>    kGPIO_DigitalOutput = <span class="hljs-number">1U</span>, 		<span class="hljs-comment">/* 输出 */</span><br>&#125; <span class="hljs-type">gpio_pin_direction_t</span>;<br>	<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_gpio_pin_config</span><br>&#123;<br>    <span class="hljs-type">gpio_pin_direction_t</span> direction; <span class="hljs-comment">/* GPIO方向:输入还是输出 */</span><br>    <span class="hljs-type">uint8_t</span> outputLogic;            <span class="hljs-comment">/* 如果是输出的话，默认输出电平 */</span><br>&#125; <span class="hljs-type">gpio_pin_config_t</span>;<br><br><br><span class="hljs-comment">/* 函数声明 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gpio_init</span><span class="hljs-params">(GPIO_Type *base, <span class="hljs-type">int</span> pin, <span class="hljs-type">gpio_pin_config_t</span> *config)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gpio_pinread</span><span class="hljs-params">(GPIO_Type *base, <span class="hljs-type">int</span> pin)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gpio_pinwrite</span><span class="hljs-params">(GPIO_Type *base, <span class="hljs-type">int</span> pin, <span class="hljs-type">int</span> value)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure>

<p>bsp_gpio.h中定义了一个枚举类型gpio_pin_direction_t和结构体gpio_pin_config_t，枚举类型gpio_pin_direction_t表示GPIO方向，输入或输出。结构体gpio_pin_config_t是GPIO的配置结构体，里面有GPIO的方向和默认输出电平两个成员变量。在bsp_gpio.c中输入如下所示内容：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs zephir">#include <span class="hljs-string">&quot;bsp_gpio.h&quot;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>		: GPIO初始化。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> - base	: 要初始化的GPIO组。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> - pin		: 要初始化GPIO在组内的编号。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> - config	: GPIO配置结构体。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 			: 无</span><br><span class="hljs-comment"> */</span><br>void gpio_init(GPIO_Type *base, <span class="hljs-keyword">int</span> pin, gpio_pin_config_t *config)<br>&#123;<br>	<span class="hljs-keyword">if</span>(config-&gt;direction == kGPIO_DigitalInput) <span class="hljs-comment">/* 输入 */</span><br>	&#123;<br>		base-&gt;GDIR &amp;= ~( <span class="hljs-number">1</span> &lt;&lt; pin);<br>	&#125;<br>	<span class="hljs-keyword">else</span>										<span class="hljs-comment">/* 输出 */</span><br>	&#123;<br>		base-&gt;GDIR |= <span class="hljs-number">1</span> &lt;&lt; pin;<br>		gpio_pinwrite(base,pin, config-&gt;outputLogic);<span class="hljs-comment">/* 设置默认输出电平 */</span><br>	&#125;<br>&#125;<br><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@description</span>	 : 读取指定GPIO的电平值 。</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> - base	 : 要读取的GPIO组。</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> - pin	 : 要读取的GPIO脚号。</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> 		 : 无</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">int</span> gpio_pinread(GPIO_Type *base, <span class="hljs-keyword">int</span> pin)<br> &#123;<br>	 <span class="hljs-keyword">return</span> (((base-&gt;DR) &gt;&gt; pin) &amp; <span class="hljs-number">0x1</span>);<br> &#125;<br><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@description</span>	 : 指定GPIO输出高或者低电平 。</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> - base	 : 要输出的的GPIO组。</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> - pin	 : 要输出的GPIO脚号。</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> - value	 : 要输出的电平，1 输出高电平， 0 输出低低电平</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> 		 : 无</span><br><span class="hljs-comment">  */</span><br>void gpio_pinwrite(GPIO_Type *base, <span class="hljs-keyword">int</span> pin, <span class="hljs-keyword">int</span> value)<br>&#123;<br>	 <span class="hljs-keyword">if</span> (value == <span class="hljs-number">0</span>U)<br>	 &#123;<br>		 base-&gt;DR &amp;= ~(<span class="hljs-number">1</span>U &lt;&lt; pin); <span class="hljs-comment">/* 输出低电平 */</span><br>	 &#125;<br>	 <span class="hljs-keyword">else</span><br>	 &#123;<br>		 base-&gt;DR |= (<span class="hljs-number">1</span>U &lt;&lt; pin); <span class="hljs-comment">/* 输出高电平 */</span><br>	 &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>base:要初始化的GPIO所属于的GPIO组，比如GPIO1_IO18就属于GPIO1组。</li>
<li>pin：要初始化GPIO在组内的标号，比如GPIO1_IO18在组内的编号就是18。</li>
<li>config:要初始化的GPIO配置结构体，用来指定GPIO配置为输出还是输入。</li>
<li>value:要设置的值，1(高电平)或者0(低电平)。</li>
</ul>
<p>我们以后就可以使用函数gpio_init设置指定GPIO为输入还是输出，使用函数gpio_pinread和gpio_pinwrite来读写指定的GPIO。</p>
<p>新建bsp_key.c和bsp_key.h这两个文件，将这两个文件都保存到刚刚创建的bsp&#x2F;key文件夹里面，然后在bsp_key.h文件夹里面输入如下内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _BSP_KEY_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _BSP_KEY_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;imx6ul.h&quot;</span></span><br><br><br><span class="hljs-comment">/* 定义按键值 */</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">keyvalue</span>&#123;<br>	KEY_NONE   = <span class="hljs-number">0</span>,<br>	KEY0_VALUE,<br>	KEY1_VALUE,<br>	KEY2_VALUE,<br>&#125;;<br><br><span class="hljs-comment">/* 函数声明 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">key_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">key_getvalue</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p>在bsp_key.c中输入如下所示内容：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_key.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_gpio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_delay.h&quot;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description	: 初始化按键</span><br><span class="hljs-comment"> * @param 		: 无</span><br><span class="hljs-comment"> * @return 		: 无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">key_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;	<br>	<span class="hljs-type">gpio_pin_config_t</span> key_config;<br>	<br>	<span class="hljs-comment">/* 1、初始化IO复用, 复用为GPIO1_IO18 */</span><br>	<span class="hljs-built_in">IOMUXC_SetPinMux</span>(IOMUXC_UART1_CTS_B_GPIO1_IO18,<span class="hljs-number">0</span>);<br><br>	<span class="hljs-comment">/* 2、、配置UART1_CTS_B的IO属性	</span><br><span class="hljs-comment">	 *bit 16:0 HYS关闭</span><br><span class="hljs-comment">	 *bit [15:14]: 11 默认22K上拉</span><br><span class="hljs-comment">	 *bit [13]: 1 pull功能</span><br><span class="hljs-comment">	 *bit [12]: 1 pull/keeper使能</span><br><span class="hljs-comment">	 *bit [11]: 0 关闭开路输出</span><br><span class="hljs-comment">	 *bit [7:6]: 10 速度100Mhz</span><br><span class="hljs-comment">	 *bit [5:3]: 000 关闭输出</span><br><span class="hljs-comment">	 *bit [0]: 0 低转换率</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">IOMUXC_SetPinConfig</span>(IOMUXC_UART1_CTS_B_GPIO1_IO18,<span class="hljs-number">0xF080</span>);<br>	<br>	<span class="hljs-comment">/* 3、初始化GPIO */</span><br>	<span class="hljs-comment">//GPIO1-&gt;GDIR &amp;= ~(1 &lt;&lt; 18);	/* GPIO1_IO18设置为输入 */	</span><br>	key_config.direction = kGPIO_DigitalInput;<br>	<span class="hljs-built_in">gpio_init</span>(GPIO1,<span class="hljs-number">18</span>, &amp;key_config);<br>	<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description	: 获取按键值 </span><br><span class="hljs-comment"> * @param 		: 无</span><br><span class="hljs-comment"> * @return 		: 0 没有按键按下，其他值:对应的按键值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">key_getvalue</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> release = <span class="hljs-number">1</span>; <span class="hljs-comment">/* 按键松开 */</span> <br><br>	<span class="hljs-keyword">if</span>((release==<span class="hljs-number">1</span>)&amp;&amp;(<span class="hljs-built_in">gpio_pinread</span>(GPIO1, <span class="hljs-number">18</span>) == <span class="hljs-number">0</span>)) 		<span class="hljs-comment">/* KEY0 	*/</span><br>	&#123;	<br>		<span class="hljs-built_in">delay</span>(<span class="hljs-number">10</span>);		<span class="hljs-comment">/* 延时消抖 		*/</span><br>		release = <span class="hljs-number">0</span>;	<span class="hljs-comment">/* 标记按键按下 */</span><br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">gpio_pinread</span>(GPIO1, <span class="hljs-number">18</span>) == <span class="hljs-number">0</span>)<br>			ret = KEY0_VALUE;<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gpio_pinread</span>(GPIO1, <span class="hljs-number">18</span>) == <span class="hljs-number">1</span>)<br>	&#123;<br>		ret = <span class="hljs-number">0</span>;<br>		release = <span class="hljs-number">1</span>; 	<span class="hljs-comment">/* 标记按键释放 */</span><br>	&#125;<br><br>	<span class="hljs-keyword">return</span> ret;	<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>bsp_key.c中一共有两个函数：key_init和key_getvalue，key_init是按键初始化函数，用来初始化按键所使用的UART1_CTS这个IO。函数key_init先设置UART1_CTS复用为GPIO1_IO18，然后配置UART1_CTS这个IO为速度为100MHz，默认22K上拉。最后调用函数gpio_init来设置GPIO1_IO18为输入功能。</p>
<p>最后就是main.c文件的内容了，在main.c中输入如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_clk.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_delay.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_led.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_beep.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_key.h&quot;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description	: main函数</span><br><span class="hljs-comment"> * @param 		: 无</span><br><span class="hljs-comment"> * @return 		: 无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> keyvalue = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> led_state = OFF;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> beep_state = OFF;<br>	<br>	<span class="hljs-built_in">clk_enable</span>();		<span class="hljs-comment">/* 使能所有的时钟 			*/</span><br>	<span class="hljs-built_in">led_init</span>();			<span class="hljs-comment">/* 初始化led 			*/</span><br>	<span class="hljs-built_in">beep_init</span>();		<span class="hljs-comment">/* 初始化beep	 		*/</span><br>	<span class="hljs-built_in">key_init</span>();			<span class="hljs-comment">/* 初始化key 			*/</span><br><br>	<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)			<br>	&#123;	<br>		keyvalue = <span class="hljs-built_in">key_getvalue</span>();<br>		<span class="hljs-keyword">if</span>(keyvalue)<br>		&#123;<br>			<span class="hljs-keyword">switch</span> ((keyvalue))<br>			&#123;<br>				<span class="hljs-keyword">case</span> KEY0_VALUE:<br>					beep_state = !beep_state;<br>					<span class="hljs-built_in">beep_switch</span>(beep_state);<br>					<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br><br>		i++;<br>		<span class="hljs-keyword">if</span>(i==<span class="hljs-number">20</span>)<br>		&#123;<br>			i = <span class="hljs-number">0</span>;<br>			led_state = !led_state;<br>			<span class="hljs-built_in">led_switch</span>(LED0, led_state);<br>		&#125;<br>		<span class="hljs-built_in">delay</span>(<span class="hljs-number">10</span>);<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="编译下载验证-3"><a href="#编译下载验证-3" class="headerlink" title="编译下载验证"></a>编译下载验证</h3><p>Makefile在之前章节的基础上修改变量TARGET为key，在变量INCDIRS和SRCDIRS中追加“bsp&#x2F;gpio”和“bsp&#x2F;key”，修改完成以后如下所示：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">CROSS_COMPILE 	?= arm-linux-gnueabihf-<br>TARGET		  	?= key<br><br><span class="hljs-comment">/* 省略掉其它代码...... */</span><br><br>INCDIRS 		:= imx6ul \<br>				   <span class="hljs-keyword">bsp/clk </span>\<br>				   <span class="hljs-keyword">bsp/led </span>\<br>				   <span class="hljs-keyword">bsp/delay </span>\<br>				   <span class="hljs-keyword">bsp/beep </span>\<br>				   <span class="hljs-keyword">bsp/gpio </span>\<br>				   <span class="hljs-keyword">bsp/key</span><br><span class="hljs-keyword"></span>				   			   <br>SRCDIRS			:= project \<br>				   <span class="hljs-keyword">bsp/clk </span>\<br>				   <span class="hljs-keyword">bsp/led </span>\<br>				   <span class="hljs-keyword">bsp/delay </span>\<br>				   <span class="hljs-keyword">bsp/beep </span>\<br>				   <span class="hljs-keyword">bsp/gpio </span>\<br>				   <span class="hljs-keyword">bsp/key</span><br><span class="hljs-keyword"></span>				   <br>				   <br><span class="hljs-comment">/* 省略掉其它代码...... */</span><br><span class="hljs-symbol">	</span><br><span class="hljs-symbol">clean:</span><br>	rm -rf $(TARGET).elf $(TARGET).<span class="hljs-keyword">dis </span>$(TARGET).<span class="hljs-keyword">bin </span>$(COBJS) $(SOBJS)<br></code></pre></td></tr></table></figure>

<p>烧写成功以后将SD卡插到开发板的SD卡槽中，然后复位开发板。如果代码运行正常的话LED0会以大约500ms周期闪烁，按下开发板上的KEY0按键，蜂鸣器打开，再按下KEY0按键，蜂鸣器关闭。</p>
<h2 id="主频和时钟配置实验"><a href="#主频和时钟配置实验" class="headerlink" title="主频和时钟配置实验"></a>主频和时钟配置实验</h2><p>系统会有时钟默认配置，所以不修改的时钟理论是不需要再单独设置，保持默认即可。但如果该时钟的上一级时钟更改了，就要看是否会影响到默认设置再做修改。</p>
<h3 id="I-MX6U时钟系统详解"><a href="#I-MX6U时钟系统详解" class="headerlink" title="I.MX6U时钟系统详解"></a>I.MX6U时钟系统详解</h3><p>I.MX6U的系统主频为528MHz，有些型号可以跑到696MHz，但是默认情况下内部bootrom会将I.MX6U的主频设置为396MHz。我们在使用I.MX6U的时候肯定是要发挥它的最大性能，那么主频肯定要设置到528MHz(其它型号可以设置更高，比如696MHz)，其它的外设时钟也要设置到NXP推荐的值。I.MX6U的系统时钟在《I.MX6ULL&#x2F;I.MX6UL参考手册》的第10章“Chapter 10Clock and Power Management”和第18章“Chapter 18Clock Controller Module (CCM)”这两章有详细的讲解。</p>
<h4 id="系统时钟来源"><a href="#系统时钟来源" class="headerlink" title="系统时钟来源"></a>系统时钟来源</h4><p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%8F%91%E6%9D%BF%E6%97%B6%E9%92%9F%E5%8E%9F%E7%90%86%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>I.MX6U-ALPHA开发板的系统时钟来源于两部分：32.768KHz和24MHz的晶振，其中32.768KHz晶振是I.MX6U 的RTC时钟源，24MHz晶振是I.MX6U内核和其它外设的时钟源，也是我们重点要分析的。</p>
<h4 id="7路PLL时钟源"><a href="#7路PLL时钟源" class="headerlink" title="7路PLL时钟源"></a>7路PLL时钟源</h4><p>I.MX6U的外设有很多，不同的外设时钟源不同，NXP将这些外设的时钟源进行了分组，一共有7组，这7组时钟源都是从24MHz晶振PLL而来的，因此也叫做7组PLL，这7组PLL结构如图所示：</p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7PLLs%E6%97%B6%E9%92%9F%E6%BA%90%E7%94%9F%E6%88%90%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<ol>
<li>ARM_PLL（PLL1），此路PLL是供ARM内核使用的，ARM内核时钟就是由此PLL生成的，此PLL通过编程的方式最高可倍频到1.3GHz。</li>
<li>528_PLL(PLL2)，此路PLL也叫做System_PLL，此路PLL是固定的22倍频，不可编程修改。因此，此路PLL时钟&#x3D;24MHz* 22 &#x3D;528MHz，这也是为什么此PLL叫做528_PLL的原因。此PLL分出了4路PFD，分别为：PLL2_PFD0~PLL2_PFD3，这4路PFD和528_PLL共同作为其它很多外设的根时钟源。通常528_PLL和这4路PFD是I.MX6U内部系统总线的时钟源，比如内处理逻辑单元、DDR接口、NAND&#x2F;NOR接口等等。</li>
<li>USB1_PLL(PLL3)，此路PLL主要用于USBPHY，此PLL也有四路PFD，为：PLL3_PFD0~PLL3_PFD3，USB1_PLL是固定的20倍频，因此USB1_PLL&#x3D;24MHz *20&#x3D;480MHz。USB1_PLL虽然主要用于USB1PHY，但是其和四路PFD同样也可以作为其他外设的根时钟源。</li>
<li>USB2_PLL(PLL7)，看名字就知道此路PLL是给USB2PHY使用的。同样的，此路PLL固定为20倍频，因此也是480MHz。</li>
<li>ENET_PLL(PLL6),此路PLL固定为20+5&#x2F;6倍频，因此ENET_PLL&#x3D;24MHz *(20+5&#x2F;6) &#x3D; 500MHz。此路PLL用于生成网络所需的时钟，可以在此PLL的基础上生成25&#x2F;50&#x2F;100&#x2F;125MHz的网络时钟。</li>
<li>VIDEO_PLL(PLL5),此路PLL用于显示相关的外设，比如LCD，此路PLL的倍频可以调整，PLL的输出范围在650MHz~1300MHz。此路PLL在最终输出的时候还可以进行分频，可选1&#x2F;2&#x2F;4&#x2F;8&#x2F;16分频。</li>
<li>AUDIO_PLL(PLL4),此路PLL用于音频相关的外设，此路PLL的倍频可以调整，PLL的输出范围同样也是650MHz~1300MHz，此路PLL在最终输出的时候也可以进行分频，可选1&#x2F;2&#x2F;4分频。</li>
</ol>
<h4 id="时钟树简介"><a href="#时钟树简介" class="headerlink" title="时钟树简介"></a>时钟树简介</h4><p>《IMX6ULL参考手册》里时钟树在“Chapter 18Clock Controller Module (CCM)”的18.3小节给出了I.MX6U详细的时钟树图：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/I.MX6U%E6%97%B6%E9%92%9F%E6%A0%91.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>左边的CLOCK_SWITCHER就是我们上一小节讲解的那7路PLL和8路PFD，右边的SYSTEM CLOCKS就是芯片外设，中间的CLOCK ROOT GENERATOR是最复杂的！这一部分就像“月老”一样，给左边的CLOCK_SWITCHER和右边的SYSTEM CLOCKS进行牵线搭桥。外设时钟源是有多路可以选择的，CLOCK ROOT GENERATOR就负责从7路PLL和8路PFD中选择合适的时钟源给外设使用。</p>
<p>《IMX6ULL参考手册》里时钟树在“Chapter 18Clock Controller Module (CCM)”的18.5.1.5.1 Clock Switcher<br>Switcher clocks 见下图</p>
<p><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Switcher_clock_generation.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<h4 id="内核时钟设置"><a href="#内核时钟设置" class="headerlink" title="内核时钟设置"></a>内核时钟设置</h4><p>先从主频开始，我们将I.MX6U的主频设置为528MHz，ARM内核时钟如图所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ARM%E5%86%85%E6%A0%B8%E6%97%B6%E9%92%9F%E6%A0%91.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<ul>
<li>① 内核时钟源来自于PLL1</li>
<li>② 通过寄存器CCM_CACRR的ARM_PODF位对PLL1进行分频，可选择1&#x2F;2&#x2F;4&#x2F;8分频，</li>
<li>③ 大家不要被此处的2分频给骗了，此处没有进行2分频(我就被这个2分频骗了好久，主频一直配置不正确！)。</li>
<li>④ 经过第②步2分频以后的就是ARM的内核时钟，也就是I.MX6U的主频。</li>
</ul>
<p>经过上面几步的分析可知，假如我们要设置内核主频为528MHz，那么PLL1可以设置为1056MHz，寄存器CCM_CACRR的ARM_PODF位设置为2分频即可。<br>同理，如果要将主频设置为696MHz，那么PLL1就可以设置为696MHz，CCM_CACRR的ARM_PODF设置为1分频即可。  </p>
<p>修改I.MX6U主频的修改步骤如下：</p>
<ol>
<li>设置寄存器CCSR的STEP_SEL位，设置step_clk的时钟源为24M的晶振。</li>
<li>设置寄存器CCSR的PLL1_SW_CLK_SEL位，设置pll1_sw_clk的时钟源为step_clk&#x3D;24MHz，通过这一步我们就将I.MX6U的主频先设置为24MHz，直接来自于外部的24M晶振。</li>
<li>设置寄存器CCM_ANALOG_PLL_ARMn，将pll1_main_clk(PLL1)设置为1056MHz。</li>
<li>设置寄存器CCSR的PLL1_SW_CLK_SEL位，重新将pll1_sw_clk的时钟源切换回pll1_main_clk，切换回来以后的pll1_sw_clk就等于1056MHz。</li>
<li>最后设置寄存器CCM_CACRR的ARM_PODF为2分频，I.MX6U的内核主频就为1056&#x2F;2&#x3D;528MHz。</li>
</ol>
<h4 id="PFD时钟设置"><a href="#PFD时钟设置" class="headerlink" title="PFD时钟设置"></a>PFD时钟设置</h4><p>置好主频以后我们还需要设置好其他的PLL和PFD时钟，PLL1上一小节已经设置了，PLL2、PLL3和PLL7固定为528MHz、480MHz和480MHz，PLL4~PLL6都是针对特殊外设的，用到的时候再设置。因此，接下来重点就是设置<strong>PLL2和PLL3</strong>的各自4路PFD，NXP推荐的这8路PFD频率如表所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/NXP%E6%8E%A8%E8%8D%90%E7%9A%84PFD%E9%A2%91%E7%8E%87.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<h4 id="AHB、IPG和PERCLK外设时钟设置"><a href="#AHB、IPG和PERCLK外设时钟设置" class="headerlink" title="AHB、IPG和PERCLK外设时钟设置"></a>AHB、IPG和PERCLK外设时钟设置</h4><p>这里正点原子教程称为根时钟，但自认为叫外设时钟要好一下，概念越多容易混乱。参考时钟树知道：</p>
<ul>
<li>AHB：即AHB_CLK_ROOT。用于 uSDHC。</li>
<li>IPG：即IPG_CLK_ROOT。用于 ADC-WDOG。貌似目前并没有用到这个外设。</li>
<li>PERCLK：即PERCLK_CLK_ROOT。用于EPIT-I2C。貌似目前并没有用到这个外设。</li>
</ul>
<p>I.MX6U外设时钟可设置范围如图所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%96%E8%AE%BE%E6%A0%B9%E6%97%B6%E9%92%9F%E5%8F%AF%E8%AE%BE%E7%BD%AE%E8%8C%83%E5%9B%B4.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<p>图给出了大多数外设的根时钟设置范围，AHB_CLK_ROOT最高可以设置132MHz，IPG_CLK_ROOT和PERCLK_CLK_ROOT最高可以设置66MHz。</p>
<p>AHB_CLK_ROOT和IPG_CLK_ROOT的涉及如图所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%80%BB%E7%BA%BF%E6%97%B6%E9%92%9F%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="enter description here"></p>
<ul>
<li>① 此选择器用来选择pre_periph_clk的时钟源，可以选择PLL2、PLL2_PFD2、PLL2_PFD0和PLL2_PFD2&#x2F;2。寄存器CCM_CBCMR的PRE_PERIPH_CLK_SEL位决定选择哪一个，默认选择PLL2_PFD2，因此pre_periph_clk&#x3D;PLL2_PFD2&#x3D;396MHz。</li>
<li>② 此选择器用来选择periph_clk的时钟源，由寄存器CCM_CBCDR的PERIPH_CLK_SEL位与PLL_bypass_en2组成的或来选择。当CCM_CBCDR的PERIPH_CLK_SEL位为0的时候periph_clk&#x3D;pr_periph_clk&#x3D;396MHz。</li>
<li>③ 通过CBCDR的AHB_PODF位来设置AHB_CLK_ROOT的分频值，可以设置1~8分频，如果想要AHB_CLK_ROOT&#x3D;132MHz的话就应该设置为3分频：396&#x2F;3&#x3D;132MHz。图16.1.2中虽然写的是默认4分频，但是I.MX6U的内部bootrom将其改为了3分频！</li>
<li>④ 通过CBCDR的IPG_PODF位来设置IPG_CLK_ROOT的分频值，可以设置1~4分频，IPG_CLK_ROOT时钟源是AHB_CLK_ROOT，要想IPG_CLK_ROOT&#x3D;66MHz的话就应该设置2分频：132&#x2F;2&#x3D;66MHz。</li>
</ul>
<p>最后要设置的就是PERCLK_CLK_ROOT时钟频率，其时钟结构图如图16.1.6.3所示：<br><img src="https://lonly-hexo-img.oss-cn-shanghai.aliyuncs.com/hexo_images/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/PERCLK_CLK_ROOT%E6%97%B6%E9%92%9F%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt="enter description here"><br>PERCLK_CLK_ROOT来 源 有 两 种 ：OSC(24MHz)和IPG_CLK_ROOT，由寄存器CCM_CSCMR1的PERCLK_CLK_SEL位来决定，如果为0的话PERCLK_CLK_ROOT的时钟源就是IPG_CLK_ROOT&#x3D;66MHz。可以通过寄存器CCM_CSCMR1的PERCLK_PODF位来设置分频，如果要设置PERCLK_CLK_ROOT为66MHz的话就要设置为1分频。</p>
<p>在修改如下时钟选择器或者分频器的时候会引起与MMDC的握手发生：</p>
<ul>
<li>mmdc_podf</li>
<li>periph_clk_sel</li>
<li>periph2_clk_sel</li>
<li>arm_podf</li>
<li>ahb_podf</li>
<li> 发生握手信号以后需要等待握手完成，寄存器CCM_CDHIPR中保存着握手信号是否完成，如果相应的位为1的话就表示握手没有完成，如果为0的话就表示握手完成。另外在修改arm_podf和ahb_podf的时候需要先关闭其时钟输出，等修改完成以后再打开，否则的话可能会出现在修改完成以后没有时钟输出的问题。本教程需要修改寄存器CCM_CBCDR的AHB_PODF位来设置AHB_ROOT_CLK的时钟，所以在修改之前必须先关闭AHB_ROOT_CLK的输出。但是笔者<strong>没有找到相应的寄存器，因此目前没法关闭，那也就没法设置AHB_PODF了。不过AHB_PODF内部bootrom设置为了3分频</strong>，如果pre_periph_clk的时钟源选择PLL2_PFD2的话，AHB_ROOT_CLK也是396MHz&#x2F;3&#x3D;132MHz。</li>
</ul>
<h3 id="实验程序编写-5"><a href="#实验程序编写-5" class="headerlink" title="实验程序编写"></a>实验程序编写</h3><p> 本试验在上一章试验“7_key”的基础上完成，因为本试验只配置I.MX6U的系统时钟，因此我们直接在文件“bsp_clk.c”上做修改，修改bsp_clk.c的内容如下：   s</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/01-%E4%B8%93%E4%B8%9A/" class="category-chain-item">01-专业</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>嵌入式Linux学习笔记-精简版</div>
      <div>http://lonlypan.com/2022/04/06/嵌入式Linux学习笔记-精简版/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>LonlyPan</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年4月6日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
              <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
              <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                <i class="iconfont icon-nc"></i>
              </span>
              </a>
            
              <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
              <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                <i class="iconfont icon-sa"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/05/03/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-Github/" title="Hexo博客搭建-Github">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Hexo博客搭建-Github</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/06/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="嵌入式Linux学习笔记-入门与裸机开发篇">
                        <span class="hidden-mobile">嵌入式Linux学习笔记-入门与裸机开发篇</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.16/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"geH90Q7ihl9Si5Llagt8GcC2-MdYXbMMI","appKey":"fO2rYFt9wStdv0SX7C7omkal","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://geh90q7i.api.lncldglobal.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <i class="iconfont icon-copyright"> 2019-2022 |</i> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?f56279d43c733d547ea06f75f8e05d89";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  

  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
